Directory Structure:
-------------------
/
├── .github/
│   └── workflows/
│       └── release.yml
├── .husky/
│   └── pre-commit
├── .vscode/
│   └── launch.json
├── prisma/
│   └── schema.prisma
├── src/
│   ├── common/
│   │   ├── base/
│   │   │   ├── base.controller.ts
│   │   │   ├── base.repository.ts
│   │   │   └── base.services.ts
│   │   ├── jwt/
│   │   │   └── jwt.ts
│   │   ├── mail-sender/
│   │   │   └── mail-sender.ts
│   │   ├── multer/
│   │   │   ├── delete-file-from-disk.ts
│   │   │   ├── multer.ts
│   │   │   ├── save-file-to-disk.ts
│   │   │   └── update-file-to-disk.ts
│   │   ├── swagger/
│   │   │   ├── swagger-document-generator.ts
│   │   │   ├── swagger-response-builder.ts
│   │   │   ├── swagger-response.ts
│   │   │   └── swagger.router.ts
│   │   └── winston/
│   │       └── winston.ts
│   ├── config/
│   │   ├── prisma/
│   │   │   ├── errors.prisma.ts
│   │   │   └── prisma.ts
│   │   ├── redis/
│   │   │   └── redis.ts
│   │   └── env.ts
│   ├── entities/
│   │   ├── auth/
│   │   │   ├── auth.controller.ts
│   │   │   ├── auth.dto.ts
│   │   │   ├── auth.route.ts
│   │   │   └── auth.services.ts
│   │   ├── file/
│   │   │   ├── file.controller.ts
│   │   │   ├── file.dto.ts
│   │   │   ├── file.route.ts
│   │   │   └── file.service.ts
│   │   ├── health/
│   │   │   ├── health.controller.ts
│   │   │   ├── health.helper.ts
│   │   │   └── health.route.ts
│   │   ├── user/
│   │   │   ├── user.controller.ts
│   │   │   ├── user.dto.ts
│   │   │   ├── user.route.ts
│   │   │   └── user.service.ts
│   ├── generated/
│   │   └── zod/
│   │       └── index.ts
│   ├── middlewares/
│   │   ├── auth-middleware.ts
│   │   ├── cors.ts
│   │   ├── error-middleware.ts
│   │   ├── index.ts
│   │   └── zod-validation.ts
│   ├── routes/
│   │   └── routes.ts
│   ├── schemas/
│   │   ├── find-by-query.ts
│   │   ├── import-file.ts
│   │   └── query-examples.txt
│   ├── template/
│   │   ├── create-template.ts
│   │   └── forgot-password.hbs
│   ├── types/
│   │   ├── pagination.ts
│   │   └── request.ts
│   ├── utils/
│   │   ├── create-response.ts
│   │   ├── csv-to-json.ts
│   │   └── utils.ts
│   ├── .DS_Store
│   ├── app.ts
│   └── server.ts
├── tests/
│   ├── auth.validation.test.ts
│   ├── files.test.ts
│   └── test.helper.ts
├── .DS_Store
├── .env
├── .env.example
├── .gitignore
├── .prettierignore
├── .prettierrc
├── code.txt
├── CODE_OF_CONDUCT.md
├── CONTRIBUTING.md
├── eslint.config.mjs
├── jest.config.ts
├── jest.setup.ts
├── LICENSE.md
├── nodemon.json
├── package.json
├── README.md
├── SECURITY.md
├── test-data.example.json
├── test-data.json
└── tsconfig.json

File: ./.prettierignore
--------------------------------------------------
Content of ./.prettierignore:
# Ignore artifacts:
node_modules
build
coverage
dist

File: ./README.md
--------------------------------------------------
Content of ./README.md:
# Advance Node.js Express TypeScript Boilerplate

This is a **Node.js Express TypeScript** boilerplate designed to follow a structured architecture similar to **NestJS**, making it highly **scalable, maintainable, and modular**.  
It is built with best practices in mind, incorporating **Prisma ORM**, **Swagger API documentation**, **Redis caching**, and **Winston logging**.

## 🚀 Why Use This Boilerplate?

Unlike basic Express.js boilerplates that lack structure and scalability, this boilerplate offers:

✅ **Modular Architecture** – Inspired by NestJS, separating concerns into `controllers`, `services`, and `routes`.  
✅ **Pre-configured TypeScript** – Ensuring type safety, better development experience, and maintainability.  
✅ **Built-in Authentication** – Includes JWT authentication out of the box.  
✅ **Prisma ORM Integration** – Provides an easy-to-use and scalable database management system.  
✅ **Redis Caching** – Optimized for performance with `ioredis` for caching.  
✅ **Centralized Logging** – Uses `winston` for logging with MongoDB and file-based storage.  
✅ **API Documentation** – Auto-generated API documentation using `swagger-ui-express`.  
✅ **Security Best Practices** – Pre-configured `helmet`, `hpp`, `cors`, and rate limiting for enhanced security.  
✅ **Unit Testing Setup** – Pre-configured with Jest & Supertest.  
✅ **Production-Ready** – Includes scripts for deployment and Docker support (if needed).  

## 🛠 Features

- **Express.js** - Minimal and fast web framework.
- **TypeScript** - Static typing for better maintainability.
- **Prisma ORM** - Database management with migrations and type safety.
- **Swagger** - API documentation (`swagger-ui-express`).
- **Redis** - Caching for improved performance (`ioredis`).
- **Winston** - Logging to both files and MongoDB.
- **JWT Authentication** - Secure authentication flow.
- **Security Middleware** - `helmet`, `hpp`, `cors`, rate limiting, and more.
- **File Uploads** - `multer` integration for handling file uploads.
- **Testing Framework** - Uses Jest & Supertest.
- **ESLint & Prettier** - Code linting and formatting.

---

## 🚀 Quick Start

### Clone the Repository
```sh
git clone https://github.com/TKAkhter/advance-expressjs-boilerplate.git
cd advance-expressjs-boilerplate
```

### Install Dependencies
```sh
npm install
```

### Setup Environment Variables
Create a `.env` file and configure necessary variables:
```
DATABASE_URL=your_database_url
REDIS_URL=your_redis_url
JWT_SECRET=your_jwt_secret
```

### Run the Development Server
```sh
npm run dev
```

### Build and Run in Production
```sh
npm run build
npm start
```

### Run Tests
```sh
npm test
```

### Lint and Format Code
```sh
npm run lint
npm run prettier
```

### Prisma Database Setup
```sh
npm run prisma:gen     # Generate Prisma client
npm run prisma:push    # Push schema to the database
```

---

## 📖 Project Structure

This project follows a modular and scalable structure, similar to NestJS.

```
/src
├── controllers/   # Handles HTTP requests and responses
├── services/      # Business logic and database interactions
├── middleware/    # Express middlewares for security, logging, etc.
├── models/        # Database models (Prisma schemas)
├── routes/        # API route definitions
├── utils/         # Utility functions and helpers
├── config/        # Configuration files (env, database, etc.)
├── tests/         # Unit and integration tests
├── server.ts      # Application entry point
```

### 🔹 Code Structure Explained

- **Controllers** → Handle incoming requests and return responses.
- **Services** → Contain the business logic and interact with the database via Prisma.
- **Middleware** → Includes authentication, logging, and security layers.
- **Routes** → Define API endpoints, connecting controllers to Express.
- **Models** → Represent the database schema using Prisma.
- **Utils** → Common utility functions like error handling, response formatting, etc.
- **Config** → Stores configuration variables (like env settings).

---

## 📜 API Documentation

Swagger documentation is auto-generated and available at:
```
http://localhost:3000/api-docs
```

---

## **🚀 GitHub Releases & Versioning**

This project follows **Semantic Versioning (`vX.Y.Z`)** with automatic **tags and releases** on every PR merged into `main`.

### **🔹 Version Rules:**
| Change Type | Keyword in PR Title/Body | Example Version Change
|--|--|--| 
| Major Update | `#major` |`v1.0.0 → v2.0.0` |
| Minor Update | `#minor` |`v1.0.0 → v1.1.0` |
| Patch Update | _(Default, no keyword)_ |`v1.0.0 → v1.0.1` |

### Example PRs and Resulting Versions

#### **PR with a Patch Version Bump (Default)**

📌 **PR Title:** `Fixed authentication bug`  
📌 **PR Body:** _"Resolved a minor issue in login flow."_  
🔹 **Result:** `v1.0.0 → v1.0.1`

----------

#### **PR with a Minor Version Bump**

📌 **PR Title:** `Added new profile feature #minor`  
📌 **PR Body:** _"Implemented user profile page."_  
🔹 **Result:** `v1.0.0 → v1.1.0`

----------

#### **PR with a Major Version Bump**

📌 **PR Title:** `Revamped API structure #major`  
📌 **PR Body:** _"Breaking changes: Updated API structure."_  
🔹 **Result:** `v1.0.0 → v2.0.0`

----------

### **🛠 How Releases Work Automatically**

**When a PR is merged into `main`**, GitHub Actions runs the release workflow.  
It checks the **PR title and body** for `#major` or `#minor`.  
**Creates a new tag and GitHub release** based on the versioning rule.

### **🎯 Steps to Enable Auto Releases**
1.  **Ensure the GitHub workflow file is in place** at `.github/workflows/release.yml`.
2.  **Create PRs with meaningful titles & descriptions**.
3.  **Merge the PR into `main`**, and a new version **tag & release** will be created automatically.

## 🏗 Deployment

### **Docker (Optional)**
This project can be easily containerized using Docker. A `Dockerfile` can be created as follows:

```dockerfile
FROM node:18
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
CMD ["npm", "start"]
EXPOSE 3000
```

### **Deploying to Production**
Ensure to set the correct environment variables and use a process manager like `pm2`:

```sh
pm2 start dist/server.js --name "express-app"
pm2 save
pm2 startup
```

---

## 📜 License

This project is licensed under the MIT License.


File: ./jest.setup.ts
--------------------------------------------------
Content of ./jest.setup.ts:
afterAll(async () => {
  // eslint-disable-next-line no-underscore-dangle
  const app = (global as any).__APP__; // eslint-disable-line @typescript-eslint/no-explicit-any
  if (app && app.close) {
    await app.close(); // Gracefully shutdown app instance if applicable
  }
});


File: ./.gitignore
--------------------------------------------------
Content of ./.gitignore:
# Node modules
node_modules/

# Build output
dist/
build/

# TypeScript files
*.tsbuildinfo

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE and editor folders
.vscode/
.idea/
*.swp
*.swo
*.sublime-project
*.sublime-workspace

# Temporary files
.DS_Store
Thumbs.db
*.tmp
*.temp

# OS generated files
ehthumbs.db
Icon?
Desktop.ini

# Coverage directory used by tools like istanbul
coverage/

# Jest test results
jest/

uploads/
test-data.json

File: ./package.json
--------------------------------------------------
Content of ./package.json:
{
  "name": "express-typescript-boilerplate-advance",
  "version": "1.0.0",
  "description": "",
  "main": "build/src/server.js",
  "scripts": {
    "clean": "rimraf build/",
    "build": "npm run clean && tsc && tsc-alias",
    "start": "npm run build && node --optimize_for_size build/src/server.js",
    "dev": "nodemon -exec --config nodemon.json 'ts-node' src/server.ts",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "prisma:pull": "prisma db pull --force",
    "prisma:push": "prisma db push",
    "prisma:gen": "prisma generate",
    "prisma:validate": "prisma validate",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "prettier": "prettier --write src/**",
    "prettier:check": "prettier --check src/**",
    "prepare": "husky"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/TKAkhter/express-typescript-boilerplate-advance"
  },
  "bugs": {
    "url": "https://github.com/TKAkhter/express-typescript-boilerplate-advance/issues"
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ]
  },
  "homepage": "https://github.com/TKAkhter/express-typescript-boilerplate-advance#readme",
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@asteasolutions/zod-to-openapi": "^7.3.0",
    "@prisma/client": "^6.5.0",
    "@typescript-eslint/eslint-plugin": "^8.28.0",
    "@typescript-eslint/parser": "^8.28.0",
    "axios": "^1.8.4",
    "bcryptjs": "^3.0.2",
    "colors": "^1.4.0",
    "compression": "^1.8.0",
    "connect-timeout": "^1.9.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "csv-parser": "^3.2.0",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-rate-limit": "^7.5.0",
    "form-data": "^4.0.2",
    "handlebars": "^4.7.8",
    "helmet": "^8.1.0",
    "hpp": "^0.2.3",
    "http-errors": "^2.0.0",
    "http-status-codes": "^2.3.0",
    "ioredis": "^5.6.0",
    "json2csv": "^6.0.0-alpha.2",
    "jsonwebtoken": "^9.0.2",
    "juice": "^11.0.1",
    "lodash": "^4.17.21",
    "mailgun.js": "^12.0.1",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.2",
    "nodemon": "^3.1.9",
    "prisma-zod-generator": "^0.8.13",
    "redis": "^4.7.0",
    "reflect-metadata": "^0.2.2",
    "response-time": "^2.3.3",
    "swagger-ui-express": "^5.0.1",
    "winston": "^3.17.0",
    "winston-daily-rotate-file": "^5.0.0",
    "winston-mongodb": "^6.0.0",
    "zod": "^3.24.2",
    "zod-prisma-types": "^3.2.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.23.0",
    "@types/compression": "^1.7.5",
    "@types/connect-timeout": "^0.0.39",
    "@types/cookie-parser": "^1.4.8",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.1",
    "@types/hpp": "^0.2.6",
    "@types/jest": "^29.5.14",
    "@types/json2csv": "^5.0.7",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/lodash": "^4.17.16",
    "@types/morgan": "^1.9.9",
    "@types/multer": "^1.4.12",
    "@types/node": "^22.13.13",
    "@types/response-time": "^2.3.8",
    "@types/supertest": "^6.0.3",
    "@types/swagger-ui-express": "^4.1.8",
    "eslint": "^9.23.0",
    "eslint-plugin-import": "^2.31.0",
    "globals": "^16.0.0",
    "husky": "^9.1.7",
    "jest": "^29.7.0",
    "lint-staged": "^15.5.0",
    "prettier": "^3.5.3",
    "prisma": "^6.5.0",
    "supertest": "^7.1.0",
    "ts-jest": "^29.3.0",
    "ts-node": "^10.9.2",
    "tsc-alias": "^1.8.11",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.8.2",
    "typescript-eslint": "^8.28.0"
  }
}

File: ./CONTRIBUTING.md
--------------------------------------------------
Content of ./CONTRIBUTING.md:
# Contributing

When contributing to this repository, please first discuss the change you wish to make via issue,
email, or any other method with the owners of this repository before making a change. 

Please note we have a code of conduct, please follow it in all your interactions with the project.

### Pull Request Process

1. Ensure any install or build dependencies are removed before the end of the layer when doing a 
   build.
2. Update the README.md with details of changes to the interface, this includes new environment 
   variables, exposed ports, useful file locations and container parameters.
3. Increase the version numbers in any examples files and the README.md to the new version that this
   Pull Request would represent. The versioning scheme I use is [SemVer](http://semver.org/).
4. You may merge the Pull Request in once you have the sign-off of two other developers, or if you 
   do not have permission to do that, you may request the second reviewer to merge it for you.
5. You should not use any NPM's package or module into the repository & be sure you should not have 
   package.json or package-lock.json file anywhere in this repository.

File: ./.prettierrc
--------------------------------------------------
Content of ./.prettierrc:
{
  "bracketSameLine": false,
  "bracketSpacing": true,
  "endOfLine": "lf",
  "semi": true,
  "singleQuote": false,
  "tabWidth": 2,
  "trailingComma": "all",
  "useTabs": false,
  "printWidth": 100,
  "arrowParens": "always",
  "embeddedLanguageFormatting": "auto"
}


File: ./test-data.example.json
--------------------------------------------------
Content of ./test-data.example.json:
{
  "register": {
    "name": "name",
    "email": "email",
    "password": "password",
    "confirmPassword": "confirmPassword"
  },
  "login": {
    "email": "email",
    "password": "password"
  },
  "newPassword": "newPassword",
  "invalidLogin": {
    "email": "email",
    "password": "password"
  }
}


File: ./tsconfig.json
--------------------------------------------------
Content of ./tsconfig.json:
{
  "compilerOptions": {
    "incremental": true,
    "target": "es2019",
    "module": "commonjs",
    "declaration": true,
    "sourceMap": true,
    "removeComments": true,
    "outDir": "./build",
    "skipLibCheck": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictBindCallApply": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": "./",
    "resolveJsonModule": true,
    "paths": {
      "@/*": ["./src/*"]
    },
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "tsc-alias": {
    "verbose": false,
    "resolveFullPaths": true
  },
  "include": ["src", "src/types", "./node_modules/@types", "@types/jest", "tests"],
  "exclude": ["node_modules", "build"]
}


File: ./.env.example
--------------------------------------------------
Content of ./.env.example:
NODE_ENV=NODE_ENV
TZ=TZ
BASE_URL=BASE_URL
BASE_URL_HTTPS=BASE_URL_HTTPS
PORT=PORT
SERVER_TIMEOUT=SERVER_TIMEOUT
LOG_FILE_DURATION=LOG_FILE_DURATION
ALLOW_ORIGIN=ALLOW_ORIGIN
APP_URL=APP_URL
LOGS_DIRECTORY=LOGS_DIRECTORY

## Basic Auth Secrets
JWT_SECRET=JWT_SECRET
JWT_SECRET_EXPIRATION=JWT_SECRET_EXPIRATION
HASH=HASH
GENERATED_PASSWORD_LENGTH=GENERATED_PASSWORD_LENGTH

## DB Configuration
REDIS_URL=REDIS_URL
MONGODB_URI=MONGODB_URI

ENABLE_WINSTON=ENABLE_WINSTON
LOGS_TYPE=LOGS_TYPE
MONGODB_ERROR_COLLECTION_NAME=MONGODB_ERROR_COLLECTION_NAME

# Mail Sender
MAILGUN_API_KEY=MAILGUN_API_KEY
MAILGUN_DOMAIN=MAILGUN_DOMAIN
MAILGUN_NAME=MAILGUN_NAME
MAILGUN_SENDER_EMAIL=MAILGUN_SENDER_EMAIL


File: ./eslint.config.mjs
--------------------------------------------------
Content of ./eslint.config.mjs:
import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";
import importPlugin from "eslint-plugin-import";


export default [{ files: ["**/*.{js,mjs,cjs,ts}"] },
{ languageOptions: { globals: globals.browser } },
pluginJs.configs.recommended,
...tseslint.configs.recommended,
{
  plugins: {
    importPlugin
  },
  "rules": {
    "accessor-pairs": ["error"],
    // "array-bracket-newline": ["error"],
    "array-bracket-spacing": ["error"],
    "array-callback-return": ["error"],
    // "array-element-newline": ["error"],
    // "arrow-body-style": ["error"],
    "arrow-parens": ["error"],
    "arrow-spacing": ["error"],
    "block-scoped-var": ["error"],
    "block-spacing": ["error"],
    // "brace-style": ["error"],
    "camelcase": ["error"],
    "capitalized-comments": ["error"],
    // "class-methods-use-this": "off",
    "comma-dangle": ["error"],
    "comma-spacing": ["error"],
    // "comma-style": ["error"],
    "computed-property-spacing": ["error"],
    "consistent-this": ["error"],
    "constructor-super": ["error"],
    "curly": ["error"],
    "default-case": ["error"],
    "default-case-last": ["error"],
    "default-param-last": ["error"],
    "dot-location": ["error"],
    "dot-notation": ["error"],
    "eol-last": ["error"],
    "eqeqeq": ["error"],
    "for-direction": ["error"],
    "func-call-spacing": ["error"],
    "func-name-matching": ["error"],
    "func-names": ["error"],
    // "function-call-argument-newline": ["error"],
    // "function-paren-newline": ["error"],
    "generator-star-spacing": ["error"],
    "getter-return": ["error"],
    "global-require": ["error"],
    "grouped-accessor-pairs": ["error"],
    "guard-for-in": ["error"],
    "handle-callback-err": ["error"],
    "id-blacklist": ["error"],
    "id-denylist": ["error"],
    "id-match": ["error"],
    // "implicit-arrow-linebreak": ["error"],
    "indent": ["error"],
    // "indent-legacy": ["error"],
    // "init-declarations": ["error"],
    "jsx-quotes": ["error"],
    "key-spacing": ["error"],
    "keyword-spacing": ["error"],
    // "linebreak-style": ["error"],
    // "lines-around-comment": ["error"],
    // "lines-around-directive": ["error"],
    "lines-between-class-members": "off",
    "logical-assignment-operators": ["error"],
    "max-classes-per-file": ["error"],
    "max-depth": ["error"],
    // "max-lines": ["error"],
    "max-nested-callbacks": ["error"],
    // "max-statements-per-line": ["error"],
    // "multiline-comment-style": ["error"],
    "multiline-ternary": ["error"],
    "new-parens": ["error"],
    // "newline-after-var": ["error"],
    // "newline-before-return": ["error"],
    // "newline-per-chained-call": ["error"],
    "no-alert": ["error"],
    "no-array-constructor": ["error"],
    "no-async-promise-executor": ["error"],
    "no-await-in-loop": ["error"],
    "no-bitwise": ["error"],
    "no-buffer-constructor": ["error"],
    "no-caller": ["error"],
    "no-case-declarations": ["error"],
    "no-catch-shadow": ["error"],
    "no-class-assign": ["error"],
    "no-compare-neg-zero": ["error"],
    "no-cond-assign": ["error"],
    "no-confusing-arrow": ["error"],
    "no-const-assign": ["error"],
    "no-constant-binary-expression": ["error"],
    "no-constant-condition": ["error"],
    "no-constructor-return": ["error"],
    "no-continue": ["error"],
    "no-control-regex": ["error"],
    "no-debugger": ["error"],
    "no-delete-var": ["error"],
    "no-div-regex": ["error"],
    "no-dupe-args": ["error"],
    "no-dupe-class-members": ["error"],
    "no-dupe-else-if": ["error"],
    "no-dupe-keys": ["error"],
    "no-duplicate-case": ["error"],
    "no-duplicate-imports": ["error"],
    "no-else-return": ["error"],
    "no-empty": ["error"],
    "no-empty-character-class": ["error"],
    "no-empty-function": ["error"],
    "no-empty-pattern": ["error"],
    "no-empty-static-block": ["error"],
    "no-eq-null": ["error"],
    "no-eval": ["error"],
    "no-ex-assign": ["error"],
    "no-extend-native": ["error"],
    "no-extra-bind": ["error"],
    "no-extra-boolean-cast": ["error"],
    "no-extra-label": ["error"],
    "no-extra-parens": ["error"],
    "no-extra-semi": ["error"],
    "no-fallthrough": ["error"],
    "no-floating-decimal": ["error"],
    "no-func-assign": ["error"],
    "no-global-assign": ["error"],
    "no-implicit-coercion": ["error"],
    "no-implicit-globals": ["error"],
    "no-implied-eval": ["error"],
    "no-import-assign": ["error"],
    "no-inner-declarations": ["error"],
    "no-invalid-regexp": ["error"],
    "no-invalid-this": ["error"],
    "no-irregular-whitespace": ["error"],
    "no-iterator": ["error"],
    "no-label-var": ["error"],
    "no-labels": ["error"],
    "no-lone-blocks": ["error"],
    "no-lonely-if": ["error"],
    "no-loop-func": ["error"],
    "no-loss-of-precision": ["error"],
    "no-misleading-character-class": ["error"],
    "no-mixed-operators": ["error"],
    "no-mixed-requires": ["error"],
    "no-mixed-spaces-and-tabs": ["error"],
    "no-multi-assign": ["error"],
    "no-multi-spaces": ["error"],
    "no-multi-str": ["error"],
    "no-multiple-empty-lines": ["error", { max: 1 }],
    "no-native-reassign": ["error"],
    // "no-negated-condition": ["error"],
    "no-negated-in-lhs": ["error"],
    "no-new": ["error"],
    "no-new-func": ["error"],
    "no-new-native-nonconstructor": ["error"],
    "no-new-object": ["error"],
    "no-new-require": ["error"],
    "no-new-symbol": ["error"],
    "no-new-wrappers": ["error"],
    "no-nonoctal-decimal-escape": ["error"],
    "no-obj-calls": ["error"],
    "no-object-constructor": ["error"],
    "no-octal": ["error"],
    "no-octal-escape": ["error"],
    "no-param-reassign": ["error"],
    "no-path-concat": ["error"],
    "no-plusplus": ["error"],
    "no-process-exit": ["error"],
    "no-promise-executor-return": ["error"],
    "no-proto": ["error"],
    "no-prototype-builtins": ["error"],
    "no-redeclare": ["error"],
    "no-regex-spaces": ["error"],
    "no-restricted-exports": ["error"],
    "no-restricted-globals": ["error"],
    "no-restricted-imports": ["error"],
    "no-restricted-modules": ["error"],
    "no-restricted-properties": ["error"],
    "no-restricted-syntax": ["error"],
    "no-return-assign": ["error"],
    "no-return-await": ["error"],
    "no-script-url": ["error"],
    "no-self-assign": ["error"],
    "no-self-compare": ["error"],
    "no-sequences": ["error"],
    "no-setter-return": ["error"],
    "no-shadow": ["error"],
    "no-shadow-restricted-names": ["error"],
    "no-spaced-func": ["error"],
    "no-sparse-arrays": ["error"],
    "no-sync": "off",
    "no-tabs": ["error"],
    "no-template-curly-in-string": ["error"],
    "no-this-before-super": ["error"],
    "no-throw-literal": ["error"],
    "no-trailing-spaces": ["error"],
    "no-undef-init": ["error"],
    // "no-undefined": ["error"],
    "no-underscore-dangle": ["error"],
    "no-unexpected-multiline": ["error"],
    "no-unmodified-loop-condition": ["error"],
    "no-unneeded-ternary": ["error"],
    "no-unreachable": ["error"],
    "no-unreachable-loop": ["error"],
    "no-unsafe-finally": ["error"],
    "no-unsafe-negation": ["error"],
    "no-unsafe-optional-chaining": ["error"],
    "no-unused-expressions": "off",
    "@typescript-eslint/no-unused-expressions": ["error", { "allowShortCircuit": true }],
    "no-unused-labels": ["error"],
    "no-unused-private-class-members": ["error"],
    "no-use-before-define": ["error"],
    "no-useless-assignment": ["error"],
    "no-useless-backreference": ["error"],
    "no-useless-call": ["error"],
    "no-useless-catch": ["error"],
    "no-useless-computed-key": ["error"],
    "no-useless-concat": ["error"],
    "no-useless-constructor": ["error"],
    "no-useless-escape": ["error"],
    "no-useless-rename": ["error"],
    "no-useless-return": ["error"],
    "no-var": ["error"],
    "no-void": ["error"],
    "no-warning-comments": ["error"],
    "no-whitespace-before-property": ["error"],
    "no-with": ["error"],
    "nonblock-statement-body-position": ["error"],
    // "object-curly-newline": ["error"],
    // "object-curly-spacing": ["error"],
    // "object-property-newline": ["error"],
    "object-shorthand": ["error"],
    "one-var-declaration-per-line": ["error"],
    "operator-assignment": ["error"],
    // "operator-linebreak": ["error"],
    "padded-blocks": "off",
    "padding-line-between-statements": "off",
    "prefer-arrow-callback": ["error"],
    "prefer-const": ["error"],
    "prefer-destructuring": ["error"],
    "prefer-exponentiation-operator": ["error"],
    "prefer-numeric-literals": ["error"],
    "prefer-object-has-own": ["error"],
    "prefer-object-spread": ["error"],
    "prefer-promise-reject-errors": ["error"],
    "prefer-reflect": ["error"],
    "prefer-regex-literals": ["error"],
    "prefer-rest-params": ["error"],
    "prefer-spread": ["error"],
    "prefer-template": ["error"],
    "quote-props": ["error"],
    "quotes": ["error"],
    "radix": ["error"],
    // "require-atomic-updates": "off",
    "require-yield": ["error"],
    "rest-spread-spacing": ["error"],
    "semi": ["error"],
    "semi-spacing": ["error"],
    // "semi-style": ["error"],
    "sort-imports": ["off"],
    // "space-before-blocks": ["error"],
    // "space-before-function-paren": ["error"],
    // "space-in-parens": ["error"],
    // "space-infix-ops": ["error"],
    // "space-unary-ops": ["error"],
    // "spaced-comment": ["error"],
    "strict": ["error"],
    // "switch-colon-spacing": ["error"],
    // "symbol-description": ["error"],
    // "template-curly-spacing": ["error"],
    // "template-tag-spacing": ["error"],
    "unicode-bom": ["error"],
    "use-isnan": ["error"],
    "valid-typeof": ["error"],
    "vars-on-top": ["error"],
    "wrap-iife": ["error"],
    "wrap-regex": ["error"],
    // "yield-star-spacing": ["error"],
    "yoda": ["error"],
  }
}
];

File: ./SECURITY.md
--------------------------------------------------
Content of ./SECURITY.md:
# Security Policy

## Supported Branch

| Branch  | Supported          |
| ------- | ------------------ |
| master  | :white_check_mark: |

## Reporting a Vulnerability

#### Reporting a General Vulnerability

If you are aware of a potential general security vulnerability, we encourage you to contact the 3rd party package developers.

#### Reporting a Express Typescript Vulnerability

If you are aware of a potential security vulnerability with anything, we encourage you to contact us immediately through GitHub Issues.
Once your communication is received, our personnel will contact you.

File: ./jest.config.ts
--------------------------------------------------
Content of ./jest.config.ts:
/**
 * For a detailed explanation regarding each configuration property, visit:
 * https://jestjs.io/docs/configuration
 */

import { pathsToModuleNameMapper, JestConfigWithTsJest } from "ts-jest";
import { compilerOptions } from "./tsconfig.json";

/** @type {import('jest').Config} */
const jestConfig: JestConfigWithTsJest = {
  // All imported modules in your tests should be mocked automatically
  // Automock: false,

  // Stop running tests after `n` failures
  // Bail: 0,

  // The directory where Jest should store its cached dependency information
  // CacheDirectory: "/private/var/folders/b9/m478lz_d2632k8g9wfsm5lj00000gn/T/jest_dx",

  // Automatically clear mock calls, instances, contexts and results before every test
  clearMocks: true,

  // Indicates whether the coverage information should be collected while executing the test
  // CollectCoverage: false,

  // An array of glob patterns indicating a set of files for which coverage information should be collected
  // CollectCoverageFrom: undefined,

  // The directory where Jest should output its coverage files
  // CoverageDirectory: undefined,

  // An array of regexp pattern strings used to skip coverage collection
  // CoveragePathIgnorePatterns: [
  //   "/node_modules/"
  // ],

  // Indicates which provider should be used to instrument code for coverage
  // CoverageProvider: "babel",

  // A list of reporter names that Jest uses when writing coverage reports
  // CoverageReporters: [
  //   "json",
  //   "text",
  //   "lcov",
  //   "clover"
  // ],

  // An object that configures minimum threshold enforcement for coverage results
  // CoverageThreshold: undefined,

  // A path to a custom dependency extractor
  // DependencyExtractor: undefined,

  // Make calling deprecated APIs throw helpful error messages
  // ErrorOnDeprecated: false,

  // The default configuration for fake timers
  // FakeTimers: {
  //   "enableGlobally": false
  // },

  // Force coverage collection from ignored files using an array of glob patterns
  // ForceCoverageMatch: [],

  // A path to a module which exports an async function that is triggered once before all test suites
  // GlobalSetup: undefined,

  // A path to a module which exports an async function that is triggered once after all test suites
  // GlobalTeardown: undefined,

  // A set of global variables that need to be available in all test environments
  // Globals: {},

  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.
  // MaxWorkers: "50%",

  // An array of directory names to be searched recursively up from the requiring module's location
  moduleDirectories: ["node_modules", "./src"],

  // An array of file extensions your modules use
  // ModuleFileExtensions: [
  //   "js",
  //   "mjs",
  //   "cjs",
  //   "jsx",
  //   "ts",
  //   "tsx",
  //   "json",
  //   "node"
  // ],

  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module
  moduleNameMapper: pathsToModuleNameMapper(compilerOptions.paths, { prefix: "<rootDir>/" }),

  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader
  // ModulePathIgnorePatterns: [],

  // Activates notifications for test results
  // Notify: false,

  // An enum that specifies notification mode. Requires { notify: true }
  // NotifyMode: "failure-change",

  // A preset that is used as a base for Jest's configuration
  preset: "ts-jest",

  // Run tests from one or more projects
  // Projects: undefined,

  // Use this configuration option to add custom reporters to Jest
  reporters: ["default"],

  // Automatically reset mock state before every test
  // ResetMocks: false,

  // Reset the module registry before running each individual test
  // ResetModules: false,

  // A path to a custom resolver
  // Resolver: undefined,

  // Automatically restore mock state and implementation before every test
  // RestoreMocks: false,

  // The root directory that Jest should scan for tests and modules within
  // RootDir: undefined,

  // A list of paths to directories that Jest should use to search for files in
  // Roots: [
  //   "<rootDir>"
  // ],

  // Allows you to use a custom runner instead of Jest's default test runner
  // Runner: "jest-runner",

  // The paths to modules that run some code to configure or set up the testing environment before each test
  // SetupFiles: [],

  // A list of paths to modules that run some code to configure or set up the testing framework before each test
  setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"],

  // The number of seconds after which a test is considered as slow and reported as such in the results.
  // SlowTestThreshold: 5,

  // A list of paths to snapshot serializer modules Jest should use for snapshot testing
  // SnapshotSerializers: [],

  // The test environment that will be used for testing
  testEnvironment: "node",

  // Options that will be passed to the testEnvironment
  // TestEnvironmentOptions: {},

  // Adds a location field to test results
  // TestLocationInResults: false,

  // The glob patterns Jest uses to detect test files
  // TestMatch: [
  //   "**/__tests__/**/*.[jt]s?(x)",
  //   "**/?(*.)+(spec|test).[tj]s?(x)"
  // ],

  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped
  // TestPathIgnorePatterns: [
  //   "/node_modules/"
  // ],

  // The regexp pattern or array of patterns that Jest uses to detect test files
  // TestRegex: [],

  // This option allows the use of a custom results processor
  // TestResultsProcessor: undefined,

  // This option allows use of a custom test runner
  // TestRunner: "jest-circus/runner",

  // A map from regular expressions to paths to transformers
  // Transform: undefined,

  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation
  // TransformIgnorePatterns: [
  //   "/node_modules/",
  //   "\\.pnp\\.[^\\/]+$"
  // ],

  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them
  // UnmockedModulePathPatterns: undefined,

  // Indicates whether each individual test should be reported during the run
  // Verbose: undefined,

  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode
  // WatchPathIgnorePatterns: [],

  // Whether to use watchman for file crawling
  // Watchman: true,
  testTimeout: 30000,
  // Silent: true,
  detectOpenHandles: true,
  forceExit: true,
};

export default jestConfig;


File: .husky/pre-commit
--------------------------------------------------
Content of .husky/pre-commit:
npx lint-staged


File: .husky/_/pre-rebase
--------------------------------------------------
Content of .husky/_/pre-rebase:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-applypatch
--------------------------------------------------
Content of .husky/_/pre-applypatch:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/husky.sh
--------------------------------------------------
Content of .husky/_/husky.sh:
echo "husky - DEPRECATED

Please remove the following two lines from $0:

#!/usr/bin/env sh
. \"\$(dirname -- \"\$0\")/_/husky.sh\"

They WILL FAIL in v10.0.0
"

File: .husky/_/pre-auto-gc
--------------------------------------------------
Content of .husky/_/pre-auto-gc:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-merge-commit
--------------------------------------------------
Content of .husky/_/pre-merge-commit:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/post-commit
--------------------------------------------------
Content of .husky/_/post-commit:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/applypatch-msg
--------------------------------------------------
Content of .husky/_/applypatch-msg:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/prepare-commit-msg
--------------------------------------------------
Content of .husky/_/prepare-commit-msg:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/h
--------------------------------------------------
Content of .husky/_/h:
#!/usr/bin/env sh
[ "$HUSKY" = "2" ] && set -x
n=$(basename "$0")
s=$(dirname "$(dirname "$0")")/$n

[ ! -f "$s" ] && exit 0

if [ -f "$HOME/.huskyrc" ]; then
	echo "husky - '~/.huskyrc' is DEPRECATED, please move your code to ~/.config/husky/init.sh"
fi
i="${XDG_CONFIG_HOME:-$HOME/.config}/husky/init.sh"
[ -f "$i" ] && . "$i"

[ "${HUSKY-}" = "0" ] && exit 0

export PATH="node_modules/.bin:$PATH"
sh -e "$s" "$@"
c=$?

[ $c != 0 ] && echo "husky - $n script failed (code $c)"
[ $c = 127 ] && echo "husky - command not found in PATH=$PATH"
exit $c


File: .husky/_/post-checkout
--------------------------------------------------
Content of .husky/_/post-checkout:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/post-applypatch
--------------------------------------------------
Content of .husky/_/post-applypatch:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/.gitignore
--------------------------------------------------
Content of .husky/_/.gitignore:
*

File: .husky/_/post-rewrite
--------------------------------------------------
Content of .husky/_/post-rewrite:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/commit-msg
--------------------------------------------------
Content of .husky/_/commit-msg:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-push
--------------------------------------------------
Content of .husky/_/pre-push:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/post-merge
--------------------------------------------------
Content of .husky/_/post-merge:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-commit
--------------------------------------------------
Content of .husky/_/pre-commit:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: prisma/schema.prisma
--------------------------------------------------
Content of prisma/schema.prisma:
generator client {
  provider = "prisma-client-js"
}

generator zod {
  provider                         = "zod-prisma-types"
  output                           = "../src/generated/zod"
  useMultipleFiles                 = false
  writeBarrelFiles                 = false
  createInputTypes                 = false
  createModelTypes                 = true
  addInputTypeValidation           = false
  addIncludeType                   = false
  addSelectType                    = false
  validateWhereUniqueInput         = false
  createOptionalDefaultValuesTypes = false
  createRelationValuesTypes        = false
  createPartialTypes               = false
  useDefaultValidators             = false
  coerceDate                       = false
  writeNullishInModelTypes         = false
}

datasource db {
  provider = "mongodb"
  url      = env("MONGODB_URI")
}

model user {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  name        String?
  email       String
  password    String?
  resetToken  String?
  createdAt   DateTime? @default(now())
  updatedAt   DateTime? @updatedAt
  phoneNumber String?
  bio         String?
  file        file[]
}

model file {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  user      user?     @relation(fields: [userId], references: [id])
  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt
  name      String?
  path      String?
  text      String?
  tags      String?
  views     Int?
  userId    String?   @db.ObjectId
}

model errorLogs {
  id         String    @id @default(auto()) @map("_id") @db.ObjectId
  status     String?
  message    String?
  method     String?
  url        String?
  loggedUser String?
  name       String?
  stack      String?
  details    Json?
  createdAt  DateTime? @default(now())
  updatedAt  DateTime? @updatedAt
}


File: tests/auth.validation.test.ts
--------------------------------------------------
Content of tests/auth.validation.test.ts:
import request from "supertest";
import app from "../src/app";
import { RedisClient } from "../src/config/redis/redis";
import { logger } from "../src/common/winston/winston";
import { loadTestData } from "./test.helper";
import { user as User } from "@prisma/client";

const ROUTE = "/api/auth";

// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "info").mockImplementation(() => {});
// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "warn").mockImplementation(() => {});
// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "error").mockImplementation(() => {});

describe("Auth API Tests", () => {
  let authToken: string;
  let testUser: User;

  afterAll(async () => {
    await RedisClient.disconnect();
  });

  test("User Registration - Success", async () => {
    const { register } = loadTestData();

    const res = await request(app).post(`${ROUTE}/register`).send(register);
    if (res.error) {
      console.log("User Login - Success", JSON.parse(res.text));
    }
    if (res.status >= 200) {
      authToken = res.body.data.token;
      testUser = res.body.data.user;
    }
    expect(res.status).toBe(200);
    expect(res.body).toHaveProperty("message", "User registered successfully");
  });

  test("User Login - Success", async () => {
    const { login } = loadTestData();

    const res = await request(app).post(`${ROUTE}/login`).send(login);

    if (res.error) {
      console.log("User Login - Success", JSON.parse(res.text));
    }

    expect(res.status).toBe(200);
    expect(res.body.data).toHaveProperty("token");
    authToken = res.body.data.token;
    testUser = res.body.data.user;
  });

  test("Login with Invalid Credentials - Failure", async () => {
    const { invalidLogin } = loadTestData();

    const res = await request(app).post(`${ROUTE}/login`).send(invalidLogin);

    expect(res.status).toBe(400);
  });

  test("Register with Existing Email - Failure", async () => {
    const { register } = loadTestData();

    const res = await request(app).post(`${ROUTE}/register`).send(register);

    expect(res.status).toBe(400);
  });

  test("Password Reset Request - Success", async () => {
    const res = await request(app).post(`${ROUTE}/forgot-password`).send({
      email: testUser.email,
    });

    if (res.error) {
      console.log("Password Reset Request - Success", JSON.parse(res.text));
    }

    expect(res.status).toBe(200);
  });

  test("Password Reset with Valid Token - Success", async () => {
    const { login, newPassword } = loadTestData();

    const loginRes = await request(app).post(`${ROUTE}/login`).send(login);

    const res = await request(app).post(`${ROUTE}/reset-password`).send({
      resetToken: loginRes.body.data.user.resetToken,
      password: newPassword,
      confirmPassword: newPassword,
    });

    if (res.error) {
      console.log("Password Reset with Valid Token - Failure", JSON.parse(res.text));
    }

    expect(res.status).toBe(200);
  });

  test("Password Reset with Invalid Token - Success", async () => {
    const { newPassword } = loadTestData();

    const res = await request(app).post(`${ROUTE}/reset-password`).send({
      resetToken: "invalidToken",
      password: newPassword,
      confirmPassword: newPassword,
    });

    expect(res.status).toBe(400);
  });

  test("Access Protected Route Without Token - Failure", async () => {
    const res = await request(app).get("/api/user");
    expect(res.status).toBe(401);
  });

  test("Access Protected Route With Valid Token - Failure", async () => {
    const res = await request(app).get("/api/user").set("Authorization", `Bearer ${authToken}`);
    expect(res.status).toBe(200);
  });

  // Test("Invalid Email Format in Registration - Failure", async () => {
  //   Const res = await request(app).post(`${ROUTE}/register`).send({
  //     Email: "invalid-email",
  //     Password: "Test@123",
  //     Name: "Test User"
  //   });
  //   Expect(res.status).toBe(400);
  // });

  // Test("Short Password in Registration - Failure", async () => {
  //   Const res = await request(app).post(`${ROUTE}/register`).send({
  //     Email: "valid@email.com",
  //     Password: "123",
  //     Name: "User"
  //   });
  //   Expect(res.status).toBe(400);
  // });
});


File: tests/test.helper.ts
--------------------------------------------------
Content of tests/test.helper.ts:
import fs from "fs";

const filePath = "./test-data.json";

// Export const saveTestData = (newData: object) => {
//     Let existingData = {};

//     If (fs.existsSync(filePath)) {
//         ExistingData = JSON.parse(fs.readFileSync(filePath, "utf-8"));
//     }

//     Const updatedData = { ...existingData, ...newData };
//     Fs.writeFileSync(filePath, JSON.stringify(updatedData, null, 2));

// };

export const loadTestData = () => {
  if (fs.existsSync(filePath)) {
    return JSON.parse(fs.readFileSync(filePath, "utf-8"));
  }
  return {};
};


File: tests/files.test.ts
--------------------------------------------------
Content of tests/files.test.ts:
import request from "supertest";
import path from "path";
import app from "../src/app";
import { RedisClient } from "../src/config/redis/redis";
import { logger } from "../src/common/winston/winston";
import { loadTestData } from "./test.helper";
import { user as User, file as File } from "@prisma/client";

const ROUTE = "/api/file";

// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "info").mockImplementation(() => {});
// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "warn").mockImplementation(() => {});
// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "error").mockImplementation(() => {});

afterAll(async () => {
  await RedisClient.disconnect();
});

describe("Files API Tests", () => {
  let authToken: string;
  let testUser: User;
  let testFile: File;

  beforeAll(async () => {
    const { login } = loadTestData();
    // Authenticate user and get token
    const loginResponse = await request(app).post("/api/auth/login").send(login);

    authToken = loginResponse.body.data.token;
    testUser = loginResponse.body.data.user;
  });

  // Should successfully upload a file
  it("should successfully upload a file", async () => {
    const response = await request(app)
      .post(`${ROUTE}/upload`)
      .set("Authorization", `Bearer ${authToken}`)
      .field({
        tags: "test, file",
        userRef: testUser.id,
      })
      .attach("file", path.join(__dirname, "test-file.png"));

    testFile = response.body.data;

    expect(response.status).toBe(200);
    expect(response.body.data).toHaveProperty("filePath");
  });

  it("should fetch uploaded file", async () => {
    const response = await request(app).get(ROUTE).set("Authorization", `Bearer ${authToken}`);

    expect(response.status).toBe(200);
    expect(Array.isArray(response.body.data)).toBe(true);
  });

  it("should fetch uploaded file by id", async () => {
    const response = await request(app)
      .get(`${ROUTE}/id/${testFile.id}`)
      .set("Authorization", `Bearer ${authToken}`);

    expect(response.status).toBe(200);
  });

  it("should fetch uploaded file by user id", async () => {
    const response = await request(app)
      .get(`${ROUTE}/user/${testFile.userId}`)
      .set("Authorization", `Bearer ${authToken}`);

    expect(response.status).toBe(200);
  });
});


File: .github/workflows/release.yml
--------------------------------------------------
Content of .github/workflows/release.yml:
name: Create Release on Merge to Main

on:
  pull_request:
    types:
      - closed
    branches:
      - main

jobs:
  release:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Latest Tag
        id: get_tag
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Extract major, minor, patch numbers
          MAJOR=$(echo $LATEST_TAG | cut -d. -f1 | tr -d 'v')
          MINOR=$(echo $LATEST_TAG | cut -d. -f2)
          PATCH=$(echo $LATEST_TAG | cut -d. -f3)

          # Determine version bump from PR title or body
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_BODY="${{ github.event.pull_request.body }}"
          echo "PR Title: $PR_TITLE"
          echo "PR Body: $PR_BODY"

          if [[ "$PR_TITLE" == *"#major"* || "$PR_BODY" == *"#major"* ]]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [[ "$PR_TITLE" == *"#minor"* || "$PR_BODY" == *"#minor"* ]]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          NEW_TAG="v$MAJOR.$MINOR.$PATCH"
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_ENV

      - name: Create Git Tag
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
          git tag $NEW_TAG
          git push origin $NEW_TAG

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.NEW_TAG }}
          name: Release ${{ env.NEW_TAG }}
          body: "Automated release for PR #${{ github.event.pull_request.number }} - ${{ github.event.pull_request.title }}"
          draft: false
          prerelease: false


File: .vscode/launch.json
--------------------------------------------------
Content of .vscode/launch.json:
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "node",
            "request": "launch",
            "name": "Launch Program",
            "skipFiles": [
                "<node_internals>/**"
            ],
            "program": "${workspaceFolder}/src/app.ts",
            "outFiles": [
                "${workspaceFolder}/**/*.js"
            ]
        }
    ]
}

File: src/app.ts
--------------------------------------------------
Content of src/app.ts:
import { errorMiddleware, cors } from "@/middlewares";
import express, { NextFunction, Request, Response } from "express";
import { apiRoutes } from "@/routes/routes";
import { env } from "@/config/env";
import { logger, morganStream } from "@/common/winston/winston";
import { openAPIRouter } from "@/common/swagger/swagger.router";
import compression from "compression";
import cookieParser from "cookie-parser";
import helmet from "helmet";
import hpp from "hpp";
import morgan from "morgan";
import path from "node:path";
import rateLimit from "express-rate-limit";
import responseTime from "response-time";
import timeout from "connect-timeout";

const app = express();

// Middlewares
app.use(cors); // Make sure this middleware is defined properly
logger.info("CORS middleware applied");

app.use(helmet({ crossOriginResourcePolicy: { policy: "cross-origin" } }));
logger.info("Helmet middleware applied");

// Rate limiting middleware
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 500, // Limit each IP to 500 requests per windowMs
  message: {
    success: false,
    message: "Too many requests, please try again later.",
  },
  headers: true,
});
logger.info("Rate limiting middleware created");

app.use(cookieParser());
logger.info("Cookie parser middleware applied");

if (env.ENABLE_WINSTON === "1") {
  app.use(morgan("dev", { stream: morganStream }));
} else {
  app.use(morgan("dev"));
}
logger.info("Morgan middleware applied");

app.use(express.json());
app.use(express.urlencoded({ extended: false }));
logger.info("Body parser middleware applied");

app.use(compression({ level: 1 }));
logger.info("Compression middleware applied");

app.use(hpp());
logger.info("hpp middleware applied");

app.use(limiter);
logger.info("Rate limiting middleware applied");

// Response Time Middleware
app.use(responseTime());
logger.info("Response time middleware applied");

// Timeout Middleware
app.use(timeout(env.SERVER_TIMEOUT, { respond: true })); // Set a 30-second timeout for all routes
logger.info("Timeout middleware applied"); // Log timeout middleware

// Routes
app.use("/uploads", express.static(path.join(__dirname, "../uploads")));
logger.info("Uploads routes set up");

app.use("/logs", express.static(path.join(__dirname, "../logs")));
logger.info("Logs routes set up");

app.use("/api", apiRoutes);
logger.info("API routes set up");

// Swagger UI
app.use(openAPIRouter);
logger.info("Swagger UI routes set up");

// Custom Error Handler Middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  errorMiddleware(err, req, res, next);
});

// Catch 404 and forward to error handler
app.use((_: Request, res: Response) => {
  logger.warn("Route not found");
  res.status(404).send("Route not found");
});

export default app;


File: src/server.ts
--------------------------------------------------
Content of src/server.ts:
import app from "@/app";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";
import { checkRedis } from "@/entities/health/health.helper";
import { connectPrisma } from "@/config/prisma/prisma";
import { RedisClient } from "@/config/redis/redis";

const { PORT, NODE_ENV, BASE_URL, ALLOW_ORIGIN } = env;

/**
 * Function to check the connection status for Redis, and MongoDB.
 * Logs the success or failure of each connection check.
 */
async function checkConnections() {
  try {
    logger.info("Checking database connections...");
    await checkRedis();
    logger.info("Redis connections verified successfully.");
    await connectPrisma();
    logger.info("Prisma connections verified successfully.");
  } catch (error) {
    if (error instanceof Error) {
      logger.warn("MongoDB, or Redis connection failed", { error: error.message });
    } else {
      logger.warn("Unknown error occurred during connection checks");
    }

    // eslint-disable-next-line no-process-exit
    process.exit(1); // Exit the process if any connection check fails
  }
}

/**
 * Function to start the server and handle termination signals (SIGINT, SIGTERM).
 * Logs the server status on startup and graceful shutdown.
 */
checkConnections().then(() => {
  const server = app.listen(PORT, () =>
    logger.info(
      `Server running on PORT: ${PORT}, ==> ENV: ${NODE_ENV}, ==> API: ${BASE_URL}, ==> ALLOW_ORIGIN: ${ALLOW_ORIGIN}`,
    ),
  );

  // Graceful shutdown logic
  const onCloseSignal = async () => {
    logger.info("SIGTERM signal received. Closing server...");
    const redis = RedisClient.getInstance();

    // Close Prisma connection
    try {
      await redis.disconnect();
      logger.info("Prisma disconnected successfully.");
    } catch (err) {
      logger.error("Error disconnecting Prisma:", { err });
    }

    // Close Redis connection
    try {
      await redis.quit();
      logger.info("Redis disconnected successfully.");
    } catch (err) {
      logger.error("Error disconnecting Redis:", { err });
    }

    // Close Express server
    server.close(() => {
      logger.info("HTTP server closed.");
      // eslint-disable-next-line no-process-exit
      process.exit(); // Ensure the process exits after server closure
    });
  };

  process.on("SIGINT", onCloseSignal); // Gracefully handle SIGINT (Ctrl+C or control+C)
  process.on("SIGTERM", onCloseSignal); // Gracefully handle SIGTERM (from Docker, etc.)
});


File: src/generated/zod/index.ts
--------------------------------------------------
Content of src/generated/zod/index.ts:
import { z } from "zod";
import { Prisma } from "@prisma/client";

/////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////

// JSON
//------------------------------------------------------

export type NullableJsonInput =
  | Prisma.JsonValue
  | null
  | "JsonNull"
  | "DbNull"
  | Prisma.NullTypes.DbNull
  | Prisma.NullTypes.JsonNull;

export const transformJsonNull = (v?: NullableJsonInput) => {
  if (!v || v === "DbNull") {
    return Prisma.DbNull;
  }
  if (v === "JsonNull") {
    return Prisma.JsonNull;
  }
  return v;
};

export const JsonValueSchema: z.ZodType<Prisma.JsonValue> = z.lazy(() =>
  z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.literal(null),
    z.record(z.lazy(() => JsonValueSchema.optional())),
    z.array(z.lazy(() => JsonValueSchema)),
  ]),
);

export type JsonValueType = z.infer<typeof JsonValueSchema>;

export const NullableJsonValue = z
  .union([JsonValueSchema, z.literal("DbNull"), z.literal("JsonNull")])
  .nullable()
  .transform((v) => transformJsonNull(v));

export type NullableJsonValueType = z.infer<typeof NullableJsonValue>;

export const InputJsonValueSchema: z.ZodType<Prisma.InputJsonValue> = z.lazy(() =>
  z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.object({ toJSON: z.function(z.tuple([]), z.any()) }),
    z.record(z.lazy(() => z.union([InputJsonValueSchema, z.literal(null)]))),
    z.array(z.lazy(() => z.union([InputJsonValueSchema, z.literal(null)]))),
  ]),
);

export type InputJsonValueType = z.infer<typeof InputJsonValueSchema>;

/////////////////////////////////////////
// ENUMS
/////////////////////////////////////////

export const UserScalarFieldEnumSchema = z.enum([
  "id",
  "name",
  "email",
  "password",
  "resetToken",
  "createdAt",
  "updatedAt",
  "phoneNumber",
  "bio",
]);

export const FileScalarFieldEnumSchema = z.enum([
  "id",
  "createdAt",
  "updatedAt",
  "name",
  "path",
  "text",
  "tags",
  "views",
  "userId",
]);

export const ErrorLogsScalarFieldEnumSchema = z.enum([
  "id",
  "status",
  "message",
  "method",
  "url",
  "loggedUser",
  "name",
  "stack",
  "details",
  "createdAt",
  "updatedAt",
]);

export const SortOrderSchema = z.enum(["asc", "desc"]);

export const QueryModeSchema = z.enum(["default", "insensitive"]);
/////////////////////////////////////////
// MODELS
/////////////////////////////////////////

/////////////////////////////////////////
// USER SCHEMA
/////////////////////////////////////////

export const userSchema = z.object({
  id: z.string(),
  name: z.string().nullable(),
  email: z.string(),
  password: z.string().nullable(),
  resetToken: z.string().nullable(),
  createdAt: z.date().nullable(),
  updatedAt: z.date().nullable(),
  phoneNumber: z.string().nullable(),
  bio: z.string().nullable(),
});

export type user = z.infer<typeof userSchema>;

/////////////////////////////////////////
// FILE SCHEMA
/////////////////////////////////////////

export const fileSchema = z.object({
  id: z.string(),
  createdAt: z.date().nullable(),
  updatedAt: z.date().nullable(),
  name: z.string().nullable(),
  path: z.string().nullable(),
  text: z.string().nullable(),
  tags: z.string().nullable(),
  views: z.number().nullable(),
  userId: z.string().nullable(),
});

export type file = z.infer<typeof fileSchema>;

/////////////////////////////////////////
// ERROR LOGS SCHEMA
/////////////////////////////////////////

export const errorLogsSchema = z.object({
  id: z.string(),
  status: z.string().nullable(),
  message: z.string().nullable(),
  method: z.string().nullable(),
  url: z.string().nullable(),
  loggedUser: z.string().nullable(),
  name: z.string().nullable(),
  stack: z.string().nullable(),
  details: JsonValueSchema.nullable(),
  createdAt: z.date().nullable(),
  updatedAt: z.date().nullable(),
});

export type errorLogs = z.infer<typeof errorLogsSchema>;


File: src/types/pagination.ts
--------------------------------------------------
Content of src/types/pagination.ts:
export interface FilterCondition {
  $eq?: string | number;
  $regex?: string;
  $between?: [string | number, string | number];
  $gte?: number;
  $lte?: number;
  $isNull?: boolean;
  $isNotNull?: boolean;
}

export type Filter = Record<string, FilterCondition>;

export interface LogicalFilter {
  $and?: Filter[];
  $or?: Filter[];
}

export interface OrderBy {
  sort: string;
  order: "asc" | "desc";
}

export interface Paginate {
  page: number;
  perPage: number;
}

export interface QueryOptions {
  filter?: Filter;
  paginate?: Paginate;
  orderBy?: OrderBy[];
}

export interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  perPage: number;
}


File: src/types/request.ts
--------------------------------------------------
Content of src/types/request.ts:
import { Request } from "express";

export interface CustomRequest extends Request {
  loggedUser?: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  file?: any;
}


File: src/config/env.ts
--------------------------------------------------
Content of src/config/env.ts:
import dotenv from "dotenv";
import { z } from "zod";

dotenv.config();

const envSchema = z.object({
  NODE_ENV: z.enum(["development", "test", "production"]).default("development"),
  TZ: z.string().default("UTC"),
  BASE_URL: z.string().url(),
  BASE_URL_HTTPS: z.string().url().optional(),
  PORT: z.string().transform((val) => parseInt(val, 10)),
  SERVER_TIMEOUT: z.string().default("150s"),
  LOG_FILE_DURATION: z.string().default("3d"),
  ALLOW_ORIGIN: z.string(),
  APP_URL: z.string().url(),
  LOGS_DIRECTORY: z.string(),

  // Basic Auth Secrets
  JWT_SECRET: z.string(),
  JWT_SECRET_EXPIRATION: z.string().default("1d"),
  HASH: z.string().transform((val) => parseInt(val, 10)),
  GENERATED_PASSWORD_LENGTH: z.string().default("10"),

  // DB Configuration
  REDIS_URL: z.string(),
  MONGODB_URI: z.string().url(),

  ENABLE_WINSTON: z.enum(["0", "1"]).default("0"),
  LOGS_TYPE: z.enum(["mongodb", "directory"]).default("mongodb"),
  MONGODB_ERROR_COLLECTION_NAME: z.string(),

  // Mail sender
  MAILGUN_API_KEY: z.string().optional(),
  MAILGUN_DOMAIN: z.string().optional(),
  MAILGUN_SENDER_EMAIL: z.string().optional(),
  MAILGUN_NAME: z.string().optional(),
});

export const env = envSchema.parse(process.env);


File: src/config/redis/redis.ts
--------------------------------------------------
Content of src/config/redis/redis.ts:
import Redis from "ioredis";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";

class RedisClient {
  private static instance: Redis;

  static getInstance(): Redis {
    if (!RedisClient.instance) {
      RedisClient.instance = new Redis(env.REDIS_URL);
      RedisClient.instance.on("connect", () => logger.info("Redis connected"));
      RedisClient.instance.on("end", () => logger.info("Redis disconnected"));
    }
    return RedisClient.instance;
  }

  static async disconnect(): Promise<void> {
    if (RedisClient.instance) {
      await RedisClient.instance.quit();
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      RedisClient.instance = undefined as any;
    }
  }
}

export { RedisClient };


File: src/config/prisma/prisma.ts
--------------------------------------------------
Content of src/config/prisma/prisma.ts:
import { logger } from "@/common/winston/winston";
import { PrismaClient } from "@prisma/client";

const Prisma = new PrismaClient();

export const prismaInstance = () => Prisma;

export const connectPrisma = async () => {
  try {
    const prisma = Prisma;
    await prisma.$connect();
  } catch (error) {
    logger.error("Error connecting to Prisma:", { error });
    throw new Error("Error connecting to Prisma");
  }
};


File: src/config/prisma/errors.prisma.ts
--------------------------------------------------
Content of src/config/prisma/errors.prisma.ts:
import { Prisma } from "@prisma/client";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const formatValidationError = (error: any): string => {
  const { message } = error;
  const match = message.match(/Unknown argument `(\w+)`. Did you mean `(\w+)`?/);

  const unknownArg = match?.[1] || "Unknown";
  const suggestedArg = match?.[2] || "Check schema";

  return `-> Prisma Validation Error:
    - Unknown argument: \`${unknownArg}\`
    - Suggested fix: Replace \`${unknownArg}\` with \`${suggestedArg}\`
    - Full Message: ${message}`;
};

const formatKnownRequestError = (error: Prisma.PrismaClientKnownRequestError): string => {
  switch (error.code) {
    case "P2002":
      return "A record with this value already exists.";
    case "P2003":
      return "Foreign key constraint failed.";
    case "P2023":
      return "Invalid ID format. Please provide a correct ID.";
    case "P2025":
      return "Record Not Found: The requested record does not exist.";
    default:
      return `Prisma Request Error (${error.code}): ${error.message}`;
  }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const formatPrismaError = (error: any): string => {
  if (error instanceof Prisma.PrismaClientValidationError) {
    return formatValidationError(error);
  } else if (error instanceof Prisma.PrismaClientKnownRequestError) {
    return formatKnownRequestError(error);
  } else if (error instanceof Prisma.PrismaClientUnknownRequestError) {
    return `-> Prisma Unknown Request Error: ${error.message}`;
  } else if (error instanceof Prisma.PrismaClientInitializationError) {
    return `-> Prisma Initialization Error: ${error.message}`;
  } else if (error instanceof Prisma.PrismaClientRustPanicError) {
    return `-> Prisma Rust Panic Error: ${error.message}`;
  }
  return `-> Unknown Error: ${error.message || error}`;
};


File: src/template/forgot-password.hbs
--------------------------------------------------
Content of src/template/forgot-password.hbs:
<html
  xmlns:v="urn:schemas-microsoft-com:vml"
  xmlns:o="urn:schemas-microsoft-com:office:office"
  lang="en"
>

  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reset password requested</title>
    <style>
      .email-container * { font-family: 'Barlow'; font-size: 16px; } p { font-family: 'Barlow';
      font-style: normal; font-weight: 400; font-size: 18px; line-height: 24px; color: #181920; }
      .button-reset { max-width: 120px; text-decoration: none; cursor: pointer; font-size:
      16px;padding: 10px 20px; position: absolute; height: 44px; background: #36854C; border-radius:
      50px; border: none; }
    </style>
  </head>

  <body>
    <div class="email-container" style="padding-left: 10px; padding-top: 10px;">
      <p style="text-transform: capitalize;">Hi {{accountName}},</p>
      <p>We received a request to reset the password for your account.</p>
      <p>To reset your Password, click on the button below:</p>
      <a
        class="button-reset"
        href="{{URL}}"
        style="font-weight:700;color:#ffffff;max-width: 120px;justify-content: center;align-items: center;"
      >
        Reset Password
      </a>
      <br />
      <br />
      <p style="margin-bottom: 30px;">Or copy and paste the URL into your browser:</p>
      <a href="{{URL}}">{{URL}}</a>
      <br />
      <br />
      <p>If you did not request a password reset, please ignore this email or reply to let us know.</p>
      <p>This password reset link is only valid for 10 minutes.</p>
      <br />
      <p>Thank you,</p>
      <p>The Bulletproof Team</p>
    </div>
  </body>
</html>

File: src/template/create-template.ts
--------------------------------------------------
Content of src/template/create-template.ts:
import fs from "fs";
import path from "path";
import handlebars from "handlebars";
import juice from "juice";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function createTemplate(name: string, context: any) {
  if (!/^[a-zA-Z0-9-_]+$/.test(name)) {
    throw new Error("Invalid template name");
  }

  const templatePath = path.join(__dirname, `${name}.hbs`);

  if (!fs.existsSync(templatePath)) {
    throw new Error("Template not found");
  }

  const source = fs.readFileSync(templatePath, "utf8");
  const template = handlebars.compile(source);
  const html = template(context);
  return juice(html);
}


File: src/middlewares/auth-middleware.ts
--------------------------------------------------
Content of src/middlewares/auth-middleware.ts:
import { NextFunction, Response } from "express";
import { CustomRequest } from "@/types/request";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { verifyToken } from "@/common/jwt/jwt";
import { winstonLogger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const authMiddleware = (req: CustomRequest, _: Response, next: NextFunction): any => {
  const token = req.headers.authorization?.split(" ")[1];
  if (!token) {
    throw createHttpError(StatusCodes.UNAUTHORIZED, "Unauthorized", {
      resource: "Auth Middleware",
    });
  }

  const verify = verifyToken(token);
  req.loggedUser = verify.email || verify.type;
  winstonLogger.defaultMeta = { loggedUser: verify.email || verify.type };
  next();
};


File: src/middlewares/error-middleware.ts
--------------------------------------------------
Content of src/middlewares/error-middleware.ts:
import { NextFunction, Response } from "express";
import { HttpError } from "http-errors";
import { StatusCodes } from "http-status-codes";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import { prismaInstance } from "@/config/prisma/prisma";

const prisma = prismaInstance();

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const findDeep = (obj: any, keys: string[]): any => {
  if (!obj || typeof obj !== "object") {
    return null;
  }
  for (const key of keys) {
    if (key in obj) {
      return obj[key];
    }
  }
  for (const value of Object.values(obj)) {
    const found = findDeep(value, keys);
    if (found) {
      return found;
    }
  }
  return null;
};

/**
 * Error middleware for catching and logging errors.
 *
 * Params:
 * - err: The error object (could be a HttpError or general error).
 * - req: The request object (with optional user data).
 * - res: The response object.
 * - _: The NextFunction (unused in this case).
 *
 * Response:
 * - Responds with the appropriate status code and error message in the response.
 * - If not in production, detailed error info is included (method, URL, stack trace).
 */
export const errorMiddleware = (
  err: Error | HttpError,
  req: CustomRequest,
  res: Response,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _: NextFunction,
): Response => {
  const { message, ...details } = err;
  const isHttpError = err instanceof HttpError;

  const statusCode = isHttpError
    ? err.status || StatusCodes.INTERNAL_SERVER_ERROR
    : StatusCodes.INTERNAL_SERVER_ERROR;

  const appName = isHttpError ? err.name : "AppError";

  const loggedUser = req.loggedUser || "Unknown User";
  const { method } = req;
  const url = req.originalUrl;

  const stack = err.stack || "";

  // Extract email or id using the helper function
  const email = findDeep(req.body, ["email"]);
  const id = findDeep(req.body, ["id"]);

  // Extract common properties
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { code, meta, name, response }: any = details;

  const transformDetails = {
    code,
    meta: { ...meta },
    data: { ...response?.data },
    status: response?.status,
    statusText: response?.statusText,
    name,
    email,
    id,
  };

  const errorPayload = {
    status: statusCode,
    message: message.trim(),
    method,
    url,
    loggedUser,
    name: appName,
    details: transformDetails,
    stack,
  };

  logger.error(errorPayload.message, errorPayload);

  if (env.ENABLE_WINSTON !== "1") {
    const errorLogs = {
      level: "error",
      message,
      metadata: errorPayload,
    };

    prisma.errorLogs
      .create({
        data: errorLogs,
      })
      .then(() => logger.info("Error logs saved successfully"))
      .catch((error) => logger.error("Error saving error logs", error));
  }

  const responsePayload = {
    status: statusCode,
    message: message.trim(),
    ...(env.NODE_ENV !== "production" && {
      method,
      url,
      loggedUser,
      name,
      details: transformDetails,
      stack,
    }),
  };

  return res.status(statusCode).json(responsePayload);
};


File: src/middlewares/index.ts
--------------------------------------------------
Content of src/middlewares/index.ts:
export { cors } from "@/middlewares/cors";
export { authMiddleware } from "@/middlewares/auth-middleware";
export { errorMiddleware } from "@/middlewares/error-middleware";
export { zodValidation } from "@/middlewares/zod-validation";


File: src/middlewares/cors.ts
--------------------------------------------------
Content of src/middlewares/cors.ts:
import corsLibrary from "cors";
import { StatusCodes } from "http-status-codes";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";

const allowedOrigins = (env.ALLOW_ORIGIN || "").split(",");

/**
 * CORS configuration to check allowed origins and set the appropriate headers
 *
 * Params:
 * - origin (string | undefined): Origin of the request, or undefined if not present.
 * - callback (function): Callback to confirm if origin is allowed or not.
 *
 * Response:
 * - Calls the callback with null and true if origin is allowed, otherwise calls callback with an error.
 */
export const config = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  origin: (origin: string | undefined, callback: any) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      logger.warn("Origin not allowed by CORS", { origin });

      callback(new Error("Not allowed by CORS"));
    }
  },
  optionsSuccessStatus: StatusCodes.OK,
};

// Initialize the CORS middleware with the configured settings
export const cors = corsLibrary(config);

export default { cors, config };


File: src/middlewares/zod-validation.ts
--------------------------------------------------
Content of src/middlewares/zod-validation.ts:
import { NextFunction, Request, Response } from "express";
import { StatusCodes } from "http-status-codes";
import { ZodError, ZodTypeAny } from "zod";
import { logger } from "@/common/winston/winston";
import { createResponse } from "@/utils/create-response";

export const zodValidation =
  (zSchema: ZodTypeAny) =>
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async (req: Request, res: Response, next: NextFunction): Promise<any> => {
    try {
      const data = zSchema.parse(req.body);
      if (data) {
        req.body = data;
        next();
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      const errorMessage = `Validation Error: ${(error as ZodError).errors.map((e) => e.message).join(", ")}`;
      logger.warn(errorMessage, error);
      return res.status(StatusCodes.BAD_REQUEST).json(
        createResponse({
          req,
          data: error,
          message: errorMessage,
          status: StatusCodes.BAD_REQUEST,
        }),
      );
    }
  };


File: src/utils/create-response.ts
--------------------------------------------------
Content of src/utils/create-response.ts:
import { Request } from "express";
import { StatusCodes, ReasonPhrases } from "http-status-codes";

export const createResponse = ({
  req,
  data,
  message = ReasonPhrases.OK,
  status = StatusCodes.OK,
  success = true,
}: {
  req?: Request;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  data: any;
  message?: string;
  status?: number;
  success?: boolean;
}) => {
  if (req) {
    return {
      success,
      statusCode: status,
      message,
      method: req.method,
      url: req.originalUrl,
      data,
    };
  }
  return {
    success,
    statusCode: status,
    message,
    data,
  };
};


File: src/utils/utils.ts
--------------------------------------------------
Content of src/utils/utils.ts:
import { env } from "@/config/env";

export const generatePassword = (): string => {
  const getRandomChar = (characters: string): string =>
    characters[Math.floor(Math.random() * characters.length)];

  const categories = [
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ", // Uppercase letters
    "abcdefghijklmnopqrstuvwxyz", // Lowercase letters
    "0123456789", // Digits
    "!@#$%^&*()_-+=<>?/", // Special characters
  ];

  const password = categories.map(getRandomChar).join("");

  const remainingLength = Number(env.GENERATED_PASSWORD_LENGTH || 10) - password.length;
  const allCharacters = categories.join("");
  const randomChars = Array.from({ length: remainingLength }, () => getRandomChar(allCharacters));

  console.log(`Generated Password ==> ${password + randomChars.join("")}`);
  return password + randomChars.join("");
};

export const extractDomainFromEmailAddress = (email: string): string | null => {
  const match = email.match(/@([\w.-]+)/);
  if (!match) {
    return null;
  }

  return match[1].toLowerCase();
};


File: src/utils/csv-to-json.ts
--------------------------------------------------
Content of src/utils/csv-to-json.ts:
import * as fs from "fs";
import csv from "csv-parser";
import { Readable } from "stream";
import _ from "lodash";
import { hash } from "bcryptjs";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const transformData = async (value: string, key?: string): Promise<any> => {
  if (key?.toLowerCase() === "password") {
    try {
      return await hash(value, env.HASH!);
    } catch (error) {
      logger.info(`Error hashing password: ${error}`);
      throw new Error(`Error hashing password: ${error}`);
    }
  }
  if (value === "NULL") {
    return null;
  }
  if (value === "FALSE") {
    return false;
  }
  if (value === "TRUE") {
    return true;
  }
  if (value === "UNDEFINED") {
    return undefined;
  }
  return value;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const sanitizeEntry = ([key, value]: [string, any]): [string, any] => {
  const sanitizedKey = _.trim(_.toLower(key.replace(/\s+/g, "")));
  const sanitizedValue = _.trim(value);
  return [sanitizedKey, sanitizedValue];
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const csvToJson = (filePath: string): Promise<any[]> => {
  return new Promise((resolve, reject) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result: any[] = [];
    const stream = fs.createReadStream(filePath);

    stream
      .pipe(csv())
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      .on("data", (row: Record<string, any>) => {
        result.push(
          Object.entries(row).reduce(
            (acc, entry) => {
              const [sanitizedKey, sanitizedValue] = sanitizeEntry(entry);
              acc[sanitizedKey] = transformData(sanitizedValue, sanitizedKey); // Collect promises
              return acc;
            },
            {
              // Add default fields here
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
            } as Record<string, any>,
          ),
        );
      })
      .on("end", async () => {
        try {
          // Wait for all promises to resolve
          const resolvedResults = await Promise.all(
            result.map(async (row) => {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const resolvedRow: Record<string, any> = {};
              for (const [key, value] of Object.entries(row)) {
                // eslint-disable-next-line no-await-in-loop
                resolvedRow[key] = await value;
              }
              return resolvedRow;
            }),
          );
          resolve(resolvedResults);
        } catch (err) {
          reject(err);
        } finally {
          fs.unlinkSync(filePath);
        }
      })
      .on("error", (error) => {
        reject(error);
        fs.unlinkSync(filePath);
      });
  });
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const csvBufferToJson = (buffer: string): Promise<any[]> => {
  return new Promise((resolve, reject) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result: any[] = [];
    const stream = Readable.from(buffer.toString());

    stream
      .pipe(csv())
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      .on("data", (row: Record<string, any>) => {
        result.push(
          Object.entries(row).reduce(
            (acc, entry) => {
              const [sanitizedKey, sanitizedValue] = sanitizeEntry(entry);
              acc[sanitizedKey] = transformData(sanitizedValue, sanitizedKey); // Collect promises
              return acc;
            },
            {
              // Add default fields here
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
            } as Record<string, any>,
          ),
        );
      })
      .on("end", async () => {
        try {
          // Wait for all promises to resolve
          const resolvedResults = await Promise.all(
            result.map(async (row) => {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const resolvedRow: Record<string, any> = {};
              for (const [key, value] of Object.entries(row)) {
                // eslint-disable-next-line no-await-in-loop
                resolvedRow[key] = await value;
              }
              return resolvedRow;
            }),
          );
          resolve(resolvedResults);
        } catch (err) {
          reject(err);
        }
      })
      .on("error", (err) => reject(err));
  });
};


File: src/schemas/query-examples.txt
--------------------------------------------------
Content of src/schemas/query-examples.txt:
1. Simple Equality Filter
{
  "filter": {
    "data.number": { "$eq": "12345" }
  },
  "paginate": {
    "page": 1,
      "perPage": 10
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" }
  ]
}

2. Case-Insensitive Text Search
{
  "filter": {
    "data.email": { "$regex": "test" }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.email", "order": "desc" }
  ]
}

3. Range Filter
json
{
  "filter": {
    "data.age": { "$between": [25, 35] }
  },
  "paginate": {
    "page": 2,
    "perPage": 20
  },
  "orderBy": [
    { "sort": "data.age", "order": "asc" }
  ]
}

4. Null and Not Null Filters
{
  "filter": {
    "data.address": { "$isNull": true }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.id", "order": "asc" }
  ]
}
{
  "filter": {
    "data.phone": { "$isNotNull": true }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.phone", "order": "asc" }
  ]
}

5. Combining $or and $and
{
  "filter": {
    "$or": [
      {
        "$and": [
          { "data.number": { "$eq": "12345" } },
          { "data.email": { "$regex": "test" } }
        ]
      },
      {
        "data.age": { "$gte": 30 }
      }
    ]
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" }
  ]
}

6. Using $and with Multiple Conditions
{
  "filter": {
    "$and": [
      { "data.status": { "$eq": "active" } },
      { "data.created_at": { "$between": ["2024-01-01", "2024-12-31"] } }
    ]
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.created_at", "order": "desc" }
  ]
}

7. $or Condition with Multiple Filters
{
  "filter": {
    "$or": [
      { "data.name": { "$regex": "john" } },
      { "data.email": { "$regex": "example" } },
      { "data.age": { "$lt": 30 } }
    ]
  },
  "paginate": {
    "page": 3,
    "perPage": 15
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" },
    { "sort": "data.age", "order": "desc" }
  ]
}

8. Filter with Multiple $and and $or Combinations
{
  "filter": {
    "$and": [
      {
        "$or": [
          { "data.city": { "$eq": "New York" } },
          { "data.city": { "$eq": "Los Angeles" } }
        ]
      },
      { "data.status": { "$eq": "verified" } },
      {
        "$or": [
          { "data.age": { "$gte": 25 } },
          { "data.email": { "$regex": "test" } }
        ]
      }
    ]
  },
  "paginate": {
    "page": 2,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.city", "order": "asc" },
    { "sort": "data.age", "order": "desc" }
  ]
}

9. Sorting by Multiple Columns
{
  "filter": {
    "data.status": { "$eq": "active" }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" },
    { "sort": "data.created_at", "order": "desc" }
  ]
}

10. Combining All Features
{
  "filter": {
    "$and": [
      { "data.status": { "$eq": "active" } },
      {
        "$or": [
          { "data.number": { "$eq": "12345" } },
          { "data.email": { "$regex": "test" } }
        ]
      },
      { "data.age": { "$between": [20, 30] } },
      { "data.address": { "$isNotNull": true } }
    ]
  },
  "paginate": {
    "page": 4,
    "perPage": 20
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" },
    { "sort": "data.age", "order": "desc" },
    { "sort": "data.created_at", "order": "asc" }
  ]
}

File: src/schemas/find-by-query.ts
--------------------------------------------------
Content of src/schemas/find-by-query.ts:
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { z } from "zod";

extendZodWithOpenApi(z);

// See query examples in query-examples.txt

const orderBySchema = z.object({
  sort: z.string().default("id"),
  order: z.enum(["asc", "desc"]),
});

const paginateSchema = z.object({
  page: z.number().min(1).default(1),
  perPage: z.number().min(1).default(10),
});

export const findByQuerySchema = z.object({
  filter: z.object({}),
  paginate: paginateSchema.optional(),
  orderBy: z.array(orderBySchema).optional(),
});

export interface FindByQueryResult<T> {
  data: T[];
  total: number;
  page: number;
  perPage: number;
  totalPages: number;
}

export interface ImportResult<T> {
  createdEntities: T[];
  createdCount: number;
  skippedCount: number;
}

export type FindByQueryDto = z.infer<typeof findByQuerySchema>;


File: src/schemas/import-file.ts
--------------------------------------------------
Content of src/schemas/import-file.ts:
import { z } from "zod";

export const importFileSchema = z.object({
  file: z
    .any()
    .openapi({
      type: "string",
      format: "binary",
    })
    .describe("The file to upload"),
});


File: src/common/jwt/jwt.ts
--------------------------------------------------
Content of src/common/jwt/jwt.ts:
import { sign, verify } from "jsonwebtoken";
import { env } from "@/config/env";
import { StatusCodes } from "http-status-codes";
import createHttpError from "http-errors";

export const generateToken = (payload: object): string => {
  // @ts-expect-error - The payload is an object
  return sign(payload, env.JWT_SECRET, { expiresIn: env.JWT_SECRET_EXPIRATION });
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const verifyToken = (token: string): any => {
  try {
    return verify(token, env.JWT_SECRET);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  } catch (error) {
    throw createHttpError(StatusCodes.FORBIDDEN, "Invalid or expired token", {
      resource: "Auth Middleware",
    });
  }
};


File: src/common/swagger/swagger.router.ts
--------------------------------------------------
Content of src/common/swagger/swagger.router.ts:
import express, { type Request, type Response, type Router } from "express";
import { generateOpenAPIDocument } from "@/common/swagger/swagger-document-generator";
import swaggerUi from "swagger-ui-express";
import { env } from "@/config/env";

export const openAPIRouter: Router = express.Router();
const openAPIDocument = generateOpenAPIDocument();

if (!["testing", "production"].includes(env.NODE_ENV!)) {
  openAPIRouter.get("/docs/swagger.json", (_req: Request, res: Response) => {
    res.setHeader("Content-Type", "application/json");
    res.send(openAPIDocument);
  });

  openAPIRouter.use("/docs", swaggerUi.serve, swaggerUi.setup(openAPIDocument));
}


File: src/common/swagger/swagger-response-builder.ts
--------------------------------------------------
Content of src/common/swagger/swagger-response-builder.ts:
import { ServiceResponseSchema } from "@/common/swagger/swagger-response";
import { StatusCodes } from "http-status-codes";
import type { z } from "zod";

export function createApiResponse(
  schema: z.ZodTypeAny,
  description: string,
  statusCode = StatusCodes.OK,
) {
  return {
    [statusCode]: {
      description,
      content: {
        "application/json": {
          schema: ServiceResponseSchema(schema),
        },
      },
    },
  };
}

// Use if you want multiple responses for a single endpoint

// Import { ResponseConfig } from '@asteasolutions/zod-to-openapi';
// Import { ApiResponseConfig } from '@common/models/openAPIResponseConfig';
// Export type ApiResponseConfig = {
//   Schema: z.ZodTypeAny;
//   Description: string;
//   StatusCode: StatusCodes;
// };
// Export function createApiResponses(configs: ApiResponseConfig[]) {
//   Const responses: { [key: string]: ResponseConfig } = {};
//   Configs.forEach(({ schema, description, statusCode }) => {
//     Responses[statusCode] = {
//       Description,
//       Content: {
//         'application/json': {
//           Schema: ServiceResponseSchema(schema),
//         },
//       },
//     };
//   });
//   Return responses;
// }


File: src/common/swagger/swagger-response.ts
--------------------------------------------------
Content of src/common/swagger/swagger-response.ts:
import { StatusCodes } from "http-status-codes";
import { z } from "zod";

export class ServiceResponse<T = null> {
  readonly success: boolean;
  readonly message: string;
  readonly data: T;
  readonly statusCode: number;

  private constructor(success: boolean, message: string, data: T, statusCode: number) {
    this.success = success;
    this.message = message;
    this.data = data;
    this.statusCode = statusCode;
  }

  // eslint-disable-next-line no-shadow
  static success<T>(message: string, data: T, statusCode: number = StatusCodes.OK) {
    return new ServiceResponse(true, message, data, statusCode);
  }

  // eslint-disable-next-line no-shadow
  static failure<T>(message: string, data: T, statusCode: number = StatusCodes.BAD_REQUEST) {
    return new ServiceResponse(false, message, data, statusCode);
  }
}

export const ServiceResponseSchema = <T extends z.ZodTypeAny>(dataSchema: T) =>
  z.object({
    success: z.boolean(),
    statusCode: z.number(),
    message: z.string(),
    data: dataSchema.optional(),
  });


File: src/common/swagger/swagger-document-generator.ts
--------------------------------------------------
Content of src/common/swagger/swagger-document-generator.ts:
import { OpenAPIRegistry, OpenApiGeneratorV3 } from "@asteasolutions/zod-to-openapi";
import { env } from "@/config/env";
import { healthRegistry } from "@/entities/health/health.route";
import { authRegistry } from "@/entities/auth/auth.route";
import { userRegistry } from "@/entities/user/user.route";
import { fileRegistry } from "@/entities/file/file.route";

export function generateOpenAPIDocument() {
  const registry = new OpenAPIRegistry([healthRegistry, authRegistry, userRegistry, fileRegistry]);

  registry.registerComponent("securitySchemes", "bearerAuth", {
    type: "http",
    scheme: "bearer",
    bearerFormat: "JWT",
  });

  const generator = new OpenApiGeneratorV3(registry.definitions);

  return generator.generateDocument({
    openapi: "3.1.0",
    info: {
      version: "1.0.0",
      title: "Swagger API",
      description:
        "This is a simple CRUD API application made with Express and documented with Swagger",
      termsOfService: "http://swagger.io/terms/",
    },
    externalDocs: {
      description: "View the raw OpenAPI Specification in JSON format",
      url: "/swagger.json",
    },
    servers: [
      {
        url: `${env.BASE_URL}/api`,
        description: "http protocol",
      },
      ...(env.BASE_URL_HTTPS
        ? [
            {
              url: `${env.BASE_URL_HTTPS}/api`,
              description: "https protocol",
            },
          ]
        : []),
    ],
    security: [
      {
        bearerAuth: [],
      },
    ],
  });
}


File: src/common/multer/multer.ts
--------------------------------------------------
Content of src/common/multer/multer.ts:
import { Request } from "express";
import multer from "multer";
import path from "path";
import fs from "fs";

//====================================================================================================

const storage = multer.memoryStorage();

const fileFilter = (_: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ["image/jpeg", "image/png", "video/mp4", "video/mkv"];

  if (!allowedTypes.includes(file.mimetype)) {
    return cb(
      new Error("Invalid file type. Only images (JPEG, PNG) and videos (MP4, MKV) are allowed."),
    );
  }

  cb(null, true);
};

const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024,
  },
});

export const uploadMiddleware = upload.single("file");

//====================================================================================================

const importStorage = multer.diskStorage({
  destination: (_, __, cb) => {
    const uploadDir = "./uploads";
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir);
    }
    cb(null, uploadDir);
  },
  filename: (_, file, cb) => {
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;
    cb(null, `${file.fieldname}-${uniqueSuffix}${path.extname(file.originalname)}`);
  },
});

const importFileFilter = (_: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ["text/csv"];

  if (!allowedTypes.includes(file.mimetype)) {
    return cb(new Error("Invalid file type. Only CSV file is allowed."));
  }

  cb(null, true);
};

const importUpload = multer({
  storage: importStorage,
  fileFilter: importFileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024,
  },
});

export const uploadImportMiddleware = importUpload.single("file");


File: src/common/multer/save-file-to-disk.ts
--------------------------------------------------
Content of src/common/multer/save-file-to-disk.ts:
import path from "path";
import fs from "fs";
import { logger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const saveFileToDisk = async (file: any) => {
  try {
    const fileBuffer = file.buffer;

    const uploadDir = "./uploads";
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;
    const fileName = `${file.fieldname}-${uniqueSuffix}${path.extname(file.originalname)}`;
    const filePath = path.join(uploadDir, fileName);

    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir);
    }

    fs.writeFile(filePath, fileBuffer, (err) => {
      if (err) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        logger.warn("Error saving file to disk:", err as any);
        throw new Error("Failed to save file.");
      }

      logger.info(`File saved to: ${filePath}`);
    });
    return { name: fileName, path: filePath };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    logger.warn("Error saving file:", error);
    throw new Error("Failed to save file.");
  }
};


File: src/common/multer/update-file-to-disk.ts
--------------------------------------------------
Content of src/common/multer/update-file-to-disk.ts:
import fs from "fs";
import path from "path";
import { logger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const updateFileToDisk = async (fileName: string, file: any) => {
  try {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let response: any;
    const uploadDir = "./uploads";

    const newFilePath = path.join(uploadDir, fileName);
    const tempFilePath = path.join(uploadDir, `${fileName}_temp${path.extname(file.originalname)}`);

    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir);
    }

    fs.writeFile(tempFilePath, file.buffer, (err) => {
      if (err) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        logger.warn("Error saving file to disk:", err as any);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        throw new Error(err as any);
      }

      response = fs.rename(tempFilePath, newFilePath, (renameErr) => {
        if (renameErr) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          logger.warn("Error replacing file:", renameErr as any);

          return false;
        }

        logger.info(`File updated successfully: ${newFilePath}`);
        // Was removed from the response
        return { fileName, filePath: newFilePath };
      });
    });
    // Added return statement
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    logger.warn("Error updating file:", error);
    throw new Error(error);
  }
};


File: src/common/multer/delete-file-from-disk.ts
--------------------------------------------------
Content of src/common/multer/delete-file-from-disk.ts:
import fs from "fs";
import path from "path";
import { logger } from "@/common/winston/winston";

export const deleteFileFromDisk = async (fileName: string) => {
  try {
    const uploadDir = "./uploads";
    const filePath = path.join(uploadDir, fileName);

    if (!fs.existsSync(filePath)) {
      throw new Error("File not found.");
    }

    fs.unlink(filePath, (err) => {
      if (err) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        logger.warn("Error deleting file:", err as any);
        throw new Error("Failed to delete the file.");
      }

      logger.info(`File deleted successfully: ${filePath}`);
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    logger.warn("Error deleting file:", error);
    throw new Error("Failed to delete the file.");
  }
};


File: src/common/mail-sender/mail-sender.ts
--------------------------------------------------
Content of src/common/mail-sender/mail-sender.ts:
import { env } from "@/config/env";
import formData from "form-data";
import Mailgun from "mailgun.js";

const mailgun = new Mailgun(formData);

const options = {
  auth: {
    api_key: env.MAILGUN_API_KEY as string,
    domain: env.MAILGUN_DOMAIN as string,
  },
};

const mg = mailgun.client({ username: "api", key: options.auth.api_key }).messages;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const sendMail = async (mail: any) => {
  try {
    return await mg.create(options.auth.domain, mail);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    throw new Error(error);
  }
};


File: src/common/base/base.repository.ts
--------------------------------------------------
Content of src/common/base/base.repository.ts:
import { FindByQueryDto, FindByQueryResult, ImportResult } from "@/schemas/find-by-query";
import { logger } from "@/common/winston/winston";
import { formatPrismaError } from "@/config/prisma/errors.prisma";

export class BaseRepository<T, TCreateDto, TUpdateDto> {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private model: any;
  private collectionName: string;
  private ignoreFields: Record<string, boolean>;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string, ignoreFields: Record<string, boolean> = {}) {
    this.model = model;
    this.collectionName = collectionName;
    this.ignoreFields = ignoreFields;
  }

  /**
   * Fetches all entities from the collection.
   * @returns Array of entities
   */
  getAll = async (): Promise<T[]> => {
    try {
      logger.info(`[${this.collectionName} Repository] Fetching all from ${this.collectionName}`);
      const getAll = await this.model.findMany({ omit: this.ignoreFields });
      return getAll;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error fetching all from ${this.collectionName}`,
        {
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Fetches an entity by ID.
   * @param id - Entity's unique identifier
   * @returns Entity data or null if not found
   */
  getById = async (id: string): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Fetching ${this.collectionName} with id: ${id}`,
      );
      return await this.model.findUnique({ where: { id }, omit: this.ignoreFields });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error fetching ${this.collectionName} by id`,
        {
          id,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Fetches a entity or entities by their userId.
   * @param id - entity's unique identifier
   * @returns entity data or null if not found
   */
  getByUser = async (userId: string): Promise<T | T[] | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Fetching ${this.collectionName} with userId: ${userId}`,
      );
      return await this.model.findMany({ where: { userId }, omit: this.ignoreFields });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error fetching ${this.collectionName} by userId`,
        {
          userId,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Fetches a entity by their email.
   * @param email - entity's email
   * @returns entity data or null if not found
   */
  getByEmail = async (email: string): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Fetching ${this.collectionName} with email: ${email}`,
      );
      return await this.model.findFirst({ where: { email } });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error fetching ${this.collectionName} by email`,
        {
          email,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Fetches a document based on a specified field and its value.
   * @param field - The field name to search by.
   * @param value - The value to match for the specified field.
   * @returns The matched document or null if not found.
   */
  getByField = async (field: string, value: string | number): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Fetching ${this.collectionName} where ${field}: ${value}`,
      );
      return await this.model.findMany({ where: { [field]: value }, omit: this.ignoreFields });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error fetching ${this.collectionName} by ${field}`,
        {
          field,
          value,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Finds entities with pagination.
   * @param options - Query options
   * @returns Paginated data
   */
  findByQuery = async (options: FindByQueryDto): Promise<FindByQueryResult<T>> => {
    const { filter = {}, paginate = { page: 1, perPage: 10 }, orderBy = [] } = options;
    const { page, perPage } = paginate;

    try {
      const sortOptions = orderBy.reduce(
        (acc, { sort, order }) => {
          acc[sort] = order;
          return acc;
        },
        {} as Record<string, "asc" | "desc">,
      );

      const [data, total] = await Promise.all([
        this.model.findMany({
          where: filter,
          orderBy: sortOptions,
          skip: (page - 1) * perPage,
          take: perPage,
          omit: this.ignoreFields,
        }),
        this.model.count({ where: filter }),
      ]);

      return { data, total, page, perPage, totalPages: Math.ceil(total / perPage) };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`[${this.collectionName} Repository] Error querying ${this.collectionName}`, {
        options,
        error: error.message,
      });
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Creates a new entity.
   * @param createDto - Data for creating a new entity
   * @returns Created entity data
   */
  create = async (createDto: TCreateDto): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Creating document in ${this.collectionName}`,
      );
      const created = await this.model.create({ data: createDto });
      return created;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error creating entry in ${this.collectionName}`,
        {
          createDto,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Updates an existing entity.
   * @param id - Entity's unique identifier
   * @param updateDto - Data to update the entity
   * @returns Updated entity data
   */
  update = async (id: string, updateDto: TUpdateDto): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Updating ${this.collectionName} with id: ${id}`,
      );
      return await this.model.update({ where: { id }, data: updateDto });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`[${this.collectionName} Repository] Error updating ${this.collectionName}`, {
        id,
        updateDto,
        error: error.message,
      });
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Deletes an entity by id.
   * @param id - Entity's unique identifier
   * @returns Deleted entity data
   */
  delete = async (id: string): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Deleting ${this.collectionName} with id: ${id}`,
      );
      return await this.model.delete({ where: { id } });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`[${this.collectionName} Repository] Error deleting ${this.collectionName}`, {
        id,
        error: error.message,
      });
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Deletes multiple entities by their ids.
   * @param ids - List of entity ids to delete
   * @returns Deletion result
   */
  deleteMany = async (ids: string[]): Promise<{ deletedCount: number }> => {
    try {
      const result = await this.model.deleteMany({ where: { id: { in: ids } } });
      return { deletedCount: result.count };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error deleting multiple ${this.collectionName}`,
        {
          ids,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Imports multiple entity objects into the database.
   * Skips objects where email already exist in the database.
   * @param entities - Array of entity objects to be saved
   * @returns Object containing created entities, created count, and skipped count
   */
  import = async (entities: TCreateDto[]): Promise<ImportResult<T>> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Importing ${entities.length} documents into ${this.collectionName}`,
      );

      const uniqueEntities = [];
      const skippedEntities = [];
      let createdEntities = [];

      for (const entity of entities) {
        // eslint-disable-next-line no-await-in-loop
        const exists = await this.model.findFirst({
          where: {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            OR: [{ email: (entity as any).email }],
          },
        });

        if (exists) {
          skippedEntities.push(entity);
        } else {
          uniqueEntities.push(entity);
        }
      }
      if (uniqueEntities.length !== 0) {
        createdEntities = await this.model.createMany({
          data: uniqueEntities,
        });
      }

      logger.info(`[${this.collectionName} Repository] Import Summary:`, {
        createdEntities: uniqueEntities,
        createdCount: createdEntities.count ?? createdEntities.length,
        skippedCount: skippedEntities.length,
      });

      return {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        createdEntities: uniqueEntities as any,
        createdCount: createdEntities.count ?? createdEntities.length,
        skippedCount: skippedEntities.length,
      };

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error importing into ${this.collectionName}`,
        {
          totalEntities: entities.length,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };
}


File: src/common/base/base.services.ts
--------------------------------------------------
Content of src/common/base/base.services.ts:
import { BaseRepository } from "@/common/base/base.repository";
import { FindByQueryDto, FindByQueryResult, ImportResult } from "@/schemas/find-by-query";
import { logger } from "@/common/winston/winston";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { parseAsync } from "json2csv";

export class BaseService<T, TCreateDto, TUpdateDto> {
  private collectionName: string;
  protected baseRepository: BaseRepository<T, TCreateDto, TUpdateDto>;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string, ignoreFields?: Record<string, boolean>) {
    this.collectionName = collectionName;
    this.baseRepository = new BaseRepository<T, TCreateDto, TUpdateDto>(
      model,
      collectionName,
      ignoreFields,
    );
  }

  /**
   * Fetches all entities from the database.
   * @returns Array of entities
   */
  getAll = async (): Promise<T[]> => {
    try {
      logger.info(`[${this.collectionName} Service] Fetching all ${this.collectionName}`);
      const data = await this.baseRepository.getAll();
      return data;
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error fetching all ${this.collectionName}`, {
          error: error.message,
        });
        throw new Error(`Error fetching ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while fetching all ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName}`);
    }
  };

  /**
   * Fetches a entity by their id.
   * @param id - entity's unique identifier
   * @returns entity data
   */
  getById = async (id: string): Promise<T> => {
    try {
      logger.info(
        `[${this.collectionName} Service] Fetching ${this.collectionName} with id: ${id}`,
      );
      const data = await this.baseRepository.getById(id);

      if (!data) {
        logger.warn(
          `[${this.collectionName} Service] ${this.collectionName} with id ${id} not found`,
        );
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} not found`, {
          resource: this.collectionName,
        });
      }

      return data;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Service] Error fetching ${this.collectionName} by id`,
          {
            id,
            error: error.message,
          },
        );
        throw new Error(`Error fetching ${this.collectionName} by id: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while fetching ${this.collectionName} by id`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName} by id`);
    }
  };

  /**
   * Fetches a entity by their email.
   * @param email - entity's email
   * @returns entity data or false if not found
   */
  getByEmail = async (email: string): Promise<T | false> => {
    try {
      logger.info(
        `[${this.collectionName} Service] Fetching ${this.collectionName} with email: ${email}`,
      );
      const data = await this.baseRepository.getByEmail(email);

      if (!data) {
        logger.warn(
          `[${this.collectionName} Service] ${this.collectionName} with email ${email} not found`,
        );
        return false;
      }

      return data;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Service] Error fetching ${this.collectionName} by email`,
          {
            email,
            error: error.message,
          },
        );
        throw new Error(`Error fetching ${this.collectionName} by email: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while fetching ${this.collectionName} by email`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName} by email`);
    }
  };

  /**
   * Finds entities based on query parameters.
   * @param options - Query parameters like pagination, sorting, and filtering
   * @returns Paginated entity data
   */
  findByQuery = async (options: FindByQueryDto): Promise<FindByQueryResult<T>> => {
    try {
      logger.info(
        `[${this.collectionName} Service] Querying ${this.collectionName} with options: ${JSON.stringify(options)}`,
      );
      return await this.baseRepository.findByQuery(options);
    } catch (error) {
      logger.warn(`[${this.collectionName} Service] Error querying ${this.collectionName}`, {
        options,
        error: error instanceof Error ? error.message : "Unknown error",
      });
      throw new Error(`Error querying ${this.collectionName}`);
    }
  };

  /**
   * Creates a new entity.
   * @param createDto - Data for creating a new entity
   * @returns Created entity data
   */
  create = async (createDto: TCreateDto): Promise<T | null> => {
    try {
      logger.info(`[${this.collectionName} Service] Creating ${this.collectionName} ${createDto}`);
      return await this.baseRepository.create(createDto);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error creating ${this.collectionName}`, {
          createDto,
          error: error.message,
        });
        throw new Error(`Error creating ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while creating ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while creating ${this.collectionName}`);
    }
  };

  /**
   * Updates an existing entity.
   * @param id - entity's unique identifier
   * @param updateDto - Data to update the entity with
   * @returns Updated entity data
   */
  update = async (id: string, updateDto: TUpdateDto): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Service] Updating ${this.collectionName} with id: ${id}`,
      );
      return await this.baseRepository.update(id, updateDto);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error updating ${this.collectionName}`, {
          id,
          updateDto,
          error: error.message,
        });
        throw new Error(`Error updating ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while updating ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while updating ${this.collectionName}`);
    }
  };

  /**
   * Deletes a entity.
   * @param id - entity's unique identifier
   * @returns Deletion result
   */
  delete = async (id: string): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Service] Deleting ${this.collectionName} with id: ${id}`,
      );
      const data = await this.getById(id);

      if (!data) {
        logger.warn(
          `[${this.collectionName} Service] ${this.collectionName} with id ${id} does not exist!`,
        );
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: this.collectionName,
        });
      }

      return await this.baseRepository.delete(id);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error deleting ${this.collectionName}`, {
          id,
          error: error.message,
        });
        throw new Error(`Error deleting ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while deleting ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while deleting ${this.collectionName}`);
    }
  };

  /**
   * Deletes multiple entities by their ids.
   * @param ids - List of entity ids to delete
   * @returns Deletion result
   */
  deleteMany = async (ids: string[]): Promise<{ deletedCount: number }> => {
    if (!Array.isArray(ids) || ids.length === 0) {
      logger.warn(`[${this.collectionName} Service] Invalid array of ids for bulk delete`);
      throw new Error("Invalid array of ids");
    }

    const result = await this.baseRepository.deleteMany(ids);

    if (result.deletedCount === 0) {
      logger.warn(`[${this.collectionName} Service] No ${this.collectionName} found to delete`, {
        ids,
      });
      throw new Error(`No ${this.collectionName} found to delete`);
    }

    return result;
  };

  /**
   * Import entities.
   * @param importDto - Data for creating entities
   * @param accountId - account id for creating entities
   * @returns number of imported entities
   */
  import = async (importDto: TCreateDto[]): Promise<ImportResult<T>> => {
    try {
      logger.info(`[${this.collectionName} Service] Starting import ${this.collectionName}`);

      const imported = await this.baseRepository.import(importDto);

      logger.info(
        `[${this.collectionName} Service] ${imported.createdCount} completed, ${imported.skippedCount} skipped for ${this.collectionName}`,
      );

      return imported;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error creating ${this.collectionName}`, {
          importDto,
          error: error.message,
        });
        throw new Error(`Error creating ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while creating ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while creating ${this.collectionName}`);
    }
  };

  /**
   * Export entities from the database.
   * @returns csv of entities
   */
  export = async (): Promise<string> => {
    try {
      logger.info(`[${this.collectionName} Service] Fetching all ${this.collectionName}`);
      const data = await this.baseRepository.getAll();

      if (data.length === 0) {
        throw createHttpError(StatusCodes.NOT_FOUND, `No ${this.collectionName} found to export`);
      }

      const csv = await parseAsync(data);

      return csv;
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error fetching all ${this.collectionName}`, {
          error: error.message,
        });
        throw new Error(`Error fetching ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while fetching all ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName}`);
    }
  };
}


File: src/common/base/base.controller.ts
--------------------------------------------------
Content of src/common/base/base.controller.ts:
import { NextFunction, Response } from "express";
import { BaseService } from "@/common/base/base.services";
import { CustomRequest } from "@/types/request";
import { logger } from "@/common/winston/winston";
import { StatusCodes } from "http-status-codes";
import createHttpError from "http-errors";
import { csvBufferToJson, csvToJson } from "@/utils/csv-to-json";
import { createResponse } from "@/utils/create-response";

export class BaseController<T, TCreateDto, TUpdateDto> {
  public collectionName: string;
  protected baseService: BaseService<T, TCreateDto, TUpdateDto>;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string, ignoreFields?: Record<string, boolean>) {
    this.collectionName = collectionName;
    this.baseService = new BaseService<T, TCreateDto, TUpdateDto>(
      model,
      collectionName,
      ignoreFields,
    );
  }

  /**
   * Get all entities objects
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON list of entities
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getAll = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    try {
      logger.info(`[${this.collectionName} Controller] Fetching all ${this.collectionName}`, {
        loggedUser,
      });
      const data = await this.baseService.getAll();

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Controller] Error fetching all ${this.collectionName}`,
          {
            error: error.message,
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Get entity by ID
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON entity object
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getById = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { id } = req.params;
    try {
      logger.info(`[${this.collectionName} Controller] Fetching ${this.collectionName} by ID`, {
        id,
        loggedUser,
      });
      const data = await this.baseService.getById(id);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Controller] Error fetching ${this.collectionName} by ID`,
          {
            error: error.message,
            id,
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Get entity by email
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON entity object
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getByEmail = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { email } = req.params;
    try {
      logger.info(`[${this.collectionName} Controller] Fetching ${this.collectionName} by email`, {
        email,
        loggedUser,
      });
      const data = await this.baseService.getByEmail(email);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Controller] Error fetching ${this.collectionName} by email`,
          {
            error: error.message,
            email,
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Find entities by query (pagination, sorting, filtering)
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON result of the query
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  findByQuery = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { paginate, orderBy, filter } = req.body;
    try {
      const queryOptions = { paginate, orderBy, filter };
      logger.info(`[${this.collectionName} Controller] Finding ${this.collectionName} by query`, {
        queryOptions,
        loggedUser,
      });

      const data = await this.baseService.findByQuery(queryOptions);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Controller] Error finding ${this.collectionName} by query`,
          {
            error: error.message,
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Create a new entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON created entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  create = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const createDto = req.body;
    try {
      logger.info(`[${this.collectionName} Controller] Creating new ${this.collectionName}`, {
        createDto,
        loggedUser,
      });
      const created = await this.baseService.create(createDto);
      return res.json(createResponse({ data: created, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error creating ${this.collectionName}`, {
          error: error.message,
          createDto,
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Update an existing entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON updated entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  update = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { id } = req.params;
    const updateDto = req.body;
    try {
      logger.info(`[${this.collectionName} Controller] Updating ${this.collectionName}`, {
        id,
        updateDto,
        loggedUser,
      });
      const updated = await this.baseService.update(id, updateDto);
      return res.json(createResponse({ data: updated }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error updating ${this.collectionName}`, {
          error: error.message,
          id,
          updateDto,
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Delete a entity by ID
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON success message
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  delete = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { id } = req.params;
    try {
      logger.info(`[${this.collectionName} Controller] Deleting ${this.collectionName} by id`, {
        id,
        loggedUser,
      });
      const data = await this.baseService.delete(id);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error deleting ${this.collectionName}`, {
          error: error.message,
          id,
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Delete multiple entities
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON success message
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  deleteMany = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { ids } = req.body;
    try {
      if (!Array.isArray(ids) || ids.length === 0) {
        throw createHttpError(StatusCodes.BAD_REQUEST, "Invalid or empty array of ids", {
          resource: this.collectionName,
          loggedUser,
        });
      }

      logger.info(`[${this.collectionName} Controller] Deleting multiple ${this.collectionName}`, {
        ids,
        loggedUser,
      });
      const data = await this.baseService.deleteMany(ids);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error deleting ${this.collectionName}`, {
          error: error.message,
          ids,
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Import entities
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON created entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  import = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser, file } = req;
    if (!file) {
      return next(createHttpError(StatusCodes.BAD_REQUEST, "No file uploaded."));
    }
    try {
      logger.info(`[${this.collectionName} Controller] Importing new ${this.collectionName}`, {
        loggedUser,
      });
      let importEntries;

      if (file.buffer) {
        importEntries = await csvBufferToJson(file.buffer);
      } else {
        importEntries = await csvToJson(file.path);
      }

      const imported = await this.baseService.import(importEntries);

      return res.json(createResponse({ data: imported }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error creating ${this.collectionName}`, {
          error: error.message,
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Export entities
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON list of entities
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  export = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    try {
      logger.info(`[${this.collectionName} Controller] Exporting ${this.collectionName}`, {
        loggedUser,
      });
      const csv = await this.baseService.export();
      res.setHeader("Content-Type", "text/csv");
      res.attachment(`${this.collectionName}.csv`);
      res.status(StatusCodes.OK).send(csv);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error exporting ${this.collectionName}`, {
          error: error.message,
          loggedUser,
        });
      }
      next(error);
    }
  };
}


File: src/common/winston/winston.ts
--------------------------------------------------
Content of src/common/winston/winston.ts:
import "winston-daily-rotate-file";
import { createLogger, format, transports, Logger } from "winston";
import { StatusCodes } from "http-status-codes";
import { env } from "@/config/env";
import fs from "fs";
import colors from "colors/safe";
import "winston-mongodb";

const isWinstonEnabled = env.ENABLE_WINSTON === "1";
const logsDirectory = env.LOGS_DIRECTORY;
const logsType = env.LOGS_TYPE;
const timeZone = env.TZ;
const logsFileDuration = env.LOG_FILE_DURATION;
const mongodbURI = env.MONGODB_URI;

if (!fs.existsSync(logsDirectory) && isWinstonEnabled && logsType !== "mongodb") {
  fs.mkdirSync(logsDirectory);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const formatConsoleMetaData = (metadata: any) => {
  if (!metadata) {
    return "";
  }

  // Extract common properties
  const { code, message, meta, name, response, details, status } = metadata;

  // Use details as a fallback for missing properties in metadata
  const resolvedDetails = details || {};

  return {
    details: {
      code: code || resolvedDetails.code || null,
      message: message || resolvedDetails.message || null,
      meta: { ...(meta || resolvedDetails.meta || {}) },
      data: {
        ...(response?.data || resolvedDetails?.data || {}),
      },
      status: response?.status || resolvedDetails?.status || status || null,
      statusText: response?.statusText || resolvedDetails?.statusText || null,
      name: name || resolvedDetails.name || null,
    },
  };
};

// NestJS-like console log format
const consoleFormat = format.combine(
  format.colorize({ all: true }),
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  format.printf(({ level, message, timestamp, ...meta }: any) => {
    const metadata = meta && Object.keys(meta).length ? JSON.stringify(meta, null, 2) : "";
    return `[${colors.cyan(timestamp)} ${timeZone}] ${level}: ${meta.loggedUser ?? ""} ${message} ${metadata}`;
  }),
);

const fileFormat = format.combine(
  format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
  format.json(),
);

const createMongoTransport = () =>
  new transports.MongoDB({
    db: mongodbURI,
    dbName: env.NODE_ENV,
    collection: env.MONGODB_ERROR_COLLECTION_NAME,
    level: "error",
    format: format.combine(
      format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
      format.errors({ stack: true }),
      format.json(),
    ),
  });

const createDailyRotateTransport = (level: string) =>
  new transports.DailyRotateFile({
    filename: `${level}-%DATE%.log`,
    dirname: logsDirectory,
    datePattern: "YYYY-MM-DD",
    level,
    zippedArchive: true,
    maxSize: "20m",
    maxFiles: logsFileDuration,
    format: format.combine(
      // eslint-disable-next-line no-extra-parens
      format((info) => (info.level === level ? info : false))(),
      fileFormat,
    ),
  });

const logLevels = {
  levels: {
    error: 0,
    warn: 1,
    http: 2,
    info: 3,
    debug: 4,
  },
  colors: {
    error: "red",
    warn: "yellow",
    info: "green",
    http: "blue",
    debug: "magenta",
  },
};

const transportsList = [];
if (isWinstonEnabled) {
  transportsList.push(new transports.Console({ level: "info", format: consoleFormat }));
  if (logsType === "mongodb") {
    transportsList.push(createMongoTransport());
  } else {
    transportsList.push(createDailyRotateTransport("info"));
    transportsList.push(createDailyRotateTransport("error"));
  }
}

export const winstonLogger: Logger = createLogger({
  levels: logLevels.levels,
  format: format.combine(
    format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
    format.errors({ stack: true }),
    format.splat(),
    format.align(),
  ),
  transports: transportsList,
});

// Export logger functions with fallback to console logs if disabled
export const logger = {
  // eslint-disable-next-line no-extra-parens
  info: (message: string, metadata?: Record<string, unknown>) =>
    isWinstonEnabled
      ? winstonLogger.info(message, metadata)
      : console.log(colors.green(message), metadata ?? ""),
  // eslint-disable-next-line no-extra-parens
  debug: (message: string, metadata?: Record<string, unknown>) =>
    isWinstonEnabled
      ? winstonLogger.debug(message, metadata)
      : console.log(colors.magenta(message), metadata ?? ""),
  // eslint-disable-next-line no-extra-parens
  warn: (message: string, metadata?: Record<string, unknown>) =>
    isWinstonEnabled
      ? winstonLogger.warn(message, metadata)
      : console.log(colors.yellow(message), metadata ?? ""),
  // eslint-disable-next-line no-extra-parens
  http: (message: string, metadata?: Record<string, unknown>) =>
    isWinstonEnabled
      ? winstonLogger.http(message, metadata)
      : console.log(colors.blue(message), metadata ?? ""),
  // eslint-disable-next-line no-extra-parens
  error: (message: string, metadata?: Record<string, unknown>) =>
    isWinstonEnabled
      ? winstonLogger.error(message, metadata)
      : console.log(colors.red(message), formatConsoleMetaData(metadata) ?? ""),
};

export const morganStream = {
  write: (message: string) => {
    const statusCode = parseInt(message.split(" ")[2], 10);
    if (statusCode >= StatusCodes.BAD_REQUEST) {
      logger.warn(message.trim());
    } else {
      logger.http(message.trim());
    }
  },
};


File: src/routes/routes.ts
--------------------------------------------------
Content of src/routes/routes.ts:
import { Router } from "express";
import authRouter from "@/entities/auth/auth.route";
import userRouter from "@/entities/user/user.route";
import fileRouter from "@/entities/file/file.route";
import healthRouter from "@/entities/health/health.route";

export const apiRoutes = Router();

apiRoutes.use("/health", healthRouter);
apiRoutes.use("/auth", authRouter);
apiRoutes.use("/user", userRouter);
apiRoutes.use("/file", fileRouter);


File: src/entities/file/file.service.ts
--------------------------------------------------
Content of src/entities/file/file.service.ts:
import createHttpError from "http-errors";
import { logger } from "@/common/winston/winston";
import { BaseService } from "@/common/base/base.services";
import { UpdateFileDto, UploadFileDto } from "./file.dto";
import { file as File } from "@prisma/client";

export class FileService extends BaseService<File, UploadFileDto, UpdateFileDto> {
  private collectionNameService: string;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string, ignoreFields?: Record<string, boolean>) {
    super(model, collectionName, ignoreFields);
    this.collectionNameService = collectionName;
  }

  /**
   * Fetches a entity by their userId.
   * @param userId - entity's userId
   * @returns entity data or false if not found
   */
  getByUser = async (userId: string): Promise<File | File[] | false> => {
    try {
      logger.info(
        `[${this.collectionNameService} Service] Fetching ${this.collectionNameService} with userId: ${userId}`,
      );
      const data = await this.baseRepository.getByUser(userId);

      if (!data) {
        logger.warn(
          `[${this.collectionNameService} Service] ${this.collectionNameService} with userId ${userId} not found`,
        );
        return false;
      }

      return data;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionNameService} Service] Error fetching ${this.collectionNameService} by userId`,
          {
            userId,
            error: error.message,
          },
        );
        throw new Error(`Error fetching ${this.collectionNameService} by email: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionNameService} Service] Unknown error occurred while fetching ${this.collectionNameService} by email`,
      );
      throw new Error(
        `Unknown error occurred while fetching ${this.collectionNameService} by email`,
      );
    }
  };
}


File: src/entities/file/file.dto.ts
--------------------------------------------------
Content of src/entities/file/file.dto.ts:
import { fileSchema } from "@/generated/zod";
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { z } from "zod";

extendZodWithOpenApi(z);

const fileUploadSchema = {
  file: z
    .any()
    .openapi({
      type: "string",
      format: "binary",
    })
    .describe("The file to upload")
    .optional(),
  views: z
    .string()
    .refine((data) => !Number.isNaN(Number(data)), "ID must be a numeric value")
    .transform(Number)
    .refine((num) => num > 0, "ID must be a positive number"),
};

export const uploadFileSchema = fileSchema
  .omit({
    id: true,
    path: true,
    text: true,
    views: true,
    createdAt: true,
    updatedAt: true,
  })
  .extend(fileUploadSchema)
  .partial();

export const updateFileSchema = fileSchema
  .omit({
    id: true,
    path: true,
    text: true,
    views: true,
    createdAt: true,
    updatedAt: true,
  })
  .extend(fileUploadSchema)
  .partial();

export type UploadFileDto = z.infer<typeof uploadFileSchema>;
export type UpdateFileDto = z.infer<typeof updateFileSchema>;


File: src/entities/file/file.route.ts
--------------------------------------------------
Content of src/entities/file/file.route.ts:
import { Router } from "express";
import { uploadMiddleware } from "@/common/multer/multer";
import { FileController } from "@/entities/file/file.controller";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { updateFileSchema, uploadFileSchema } from "@/entities/file/file.dto";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import { z } from "zod";
import { authMiddleware, zodValidation } from "@/middlewares";
import { findByQuerySchema } from "@/schemas/find-by-query";
import { fileSchema } from "@/generated/zod";

const fileRouter = Router();
fileRouter.use(authMiddleware);

const TAG = "File";
const ROUTE = `/${TAG.toLowerCase()}`;

export const fileRegistry = new OpenAPIRegistry();
const fileController = new FileController();

fileRegistry.register(TAG, fileSchema);

fileRegistry.registerPath({
  method: "get",
  path: ROUTE,
  summary: `Get all ${TAG}`,
  tags: [TAG],
  responses: createApiResponse(z.array(fileSchema), "Success"),
});
fileRouter.get("/", fileController.getAll);

//====================================================================================================

fileRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  summary: `Get ${TAG} by id`,
  request: {
    params: z.object({ id: z.string() }),
  },
  responses: createApiResponse(fileSchema, "Success"),
});
fileRouter.get("/:id", fileController.getById);

//====================================================================================================

fileRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/user/{userId}`,
  tags: [TAG],
  summary: `Get ${TAG} by userId`,
  request: {
    params: z.object({ userId: z.string() }),
  },
  responses: createApiResponse(fileSchema, "Success"),
});
fileRouter.get("/user/:userId", fileController.getByUser);

//====================================================================================================

fileRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/find`,
  tags: [TAG],
  summary: `Find ${TAG} by query`,
  request: {
    body: {
      content: { "application/json": { schema: findByQuerySchema } },
    },
  },
  responses: createApiResponse(z.array(findByQuerySchema), "Success"),
});
fileRouter.post("/find", zodValidation(findByQuerySchema), fileController.findByQuery);

//====================================================================================================

fileRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/upload`,
  tags: [TAG],
  summary: `Upload ${TAG}`,
  request: {
    body: {
      content: { "multipart/form-data": { schema: uploadFileSchema } },
    },
  },
  responses: createApiResponse(uploadFileSchema, "File uploaded Successfully"),
});
fileRouter.post(
  "/upload",
  uploadMiddleware,
  zodValidation(uploadFileSchema),
  fileController.upload,
);

//====================================================================================================

fileRegistry.registerPath({
  method: "put",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  request: {
    params: z.object({ id: z.string() }),
    body: {
      content: { "multipart/form-data": { schema: updateFileSchema } },
    },
  },
  responses: createApiResponse(updateFileSchema, "File updated Successfully"),
});
fileRouter.put("/:id", uploadMiddleware, zodValidation(updateFileSchema), fileController.update);

//====================================================================================================

fileRegistry.registerPath({
  method: "delete",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  summary: `Delete ${TAG}`,
  request: {
    params: z.object({ id: z.string() }),
  },
  responses: createApiResponse(z.null(), `${TAG} Deleted Successfully`),
});
fileRouter.delete("/:id", fileController.delete);

export default fileRouter;


File: src/entities/file/file.controller.ts
--------------------------------------------------
Content of src/entities/file/file.controller.ts:
import { NextFunction, Response } from "express";
import { UpdateFileDto, UploadFileDto } from "@/entities/file/file.dto";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import { saveFileToDisk } from "@/common/multer/save-file-to-disk";
import { updateFileToDisk } from "@/common/multer/update-file-to-disk";
import { deleteFileFromDisk } from "@/common/multer/delete-file-from-disk";
import { BaseController } from "@/common/base/base.controller";
import { createResponse } from "@/utils/create-response";
import { StatusCodes } from "http-status-codes";
import { FileService } from "@/entities/file/file.service";
import { file as File } from "@prisma/client";
import { prismaInstance } from "@/config/prisma/prisma";
import _ from "lodash";

const prisma = prismaInstance();
const IGNORE_FIELDS = {};

export class FileController extends BaseController<File, UploadFileDto, UpdateFileDto> {
  public collectionName: string;
  public fileService: FileService;

  constructor() {
    super(prisma.file, "File", IGNORE_FIELDS);
    this.collectionName = "File";
    this.fileService = new FileService(prisma.file, this.collectionName, IGNORE_FIELDS);
  }

  /**
   * Get entity by ID
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON entity object
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getByUser = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { userId } = req.params;
    const { loggedUser } = req;
    try {
      logger.info(`[${this.collectionName} Controller] Fetching ${this.collectionName} by userId`, {
        loggedUser,
        userId,
      });
      const data = await this.fileService.getByUser(userId);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Controller] Error fetching ${this.collectionName} by userId`,
          {
            error: error.message,
            loggedUser,
            userId,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Upload an entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON updated entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  upload = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    try {
      const { tags, userId, name, views } = req.body;

      const { path } = await saveFileToDisk(req.file);
      logger.info(`[${this.collectionName} Controller] Creating new ${this.collectionName}`, {
        loggedUser,
        tags,
        name,
        path,
      });

      const fileUpload = {
        name,
        path,
        userId,
        tags,
        views: views ?? 0,
      };
      const created = await this.baseService.create(fileUpload);

      return res.json(createResponse({ data: created, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn("Error uploading file", { error: error.message, loggedUser });
      }
      next(error);
    }
  };

  /**
   * Update an existing entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON updated entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  update = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { id } = req.params;
    try {
      const updateData = req.body;
      const existFile = await this.baseService.getById(id);
      if (!existFile) {
        throw new Error("File not found");
      }
      const fileName = existFile.path!.split("/").pop();
      if (req.file) {
        await updateFileToDisk(fileName!, req.file);
      }
      const fileData = {
        name: _.isEmpty(updateData.name) ? existFile.name : updateData.name,
        userId: _.isEmpty(updateData.userId) ? existFile.userId : updateData.userId,
        tags: _.isEmpty(updateData.tags) ? existFile.tags : updateData.tags,
        views: _.isEmpty(updateData.views) ? existFile.views : updateData.views,
      };
      const updated = await this.baseService.update(id, fileData);

      return res.json(createResponse({ data: updated, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn("Error updating file", { error: error.message, loggedUser, id });
      }
      next(error);
    }
  };

  /**
   * Delete an existing entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON updated entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  delete = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { id } = req.params;
    try {
      const existFile = await this.baseService.getById(id);
      if (!existFile) {
        throw new Error("File not found");
      }
      const fileName = existFile.path!.split("/").pop();
      await deleteFileFromDisk(fileName!);
      const deleted = await this.baseService.delete(id);

      return res.json(createResponse({ data: deleted, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn("Error deleting file", { error: error.message, loggedUser, id });
      }
      next(error);
    }
  };
}


File: src/entities/auth/auth.controller.ts
--------------------------------------------------
Content of src/entities/auth/auth.controller.ts:
import { NextFunction, Response } from "express";
import { AuthDto, RegisterDto, ResetPasswordDto } from "@/entities/auth/auth.dto";
import { AuthService } from "@/entities/auth/auth.services";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import { StatusCodes } from "http-status-codes";
import { createResponse } from "@/utils/create-response";
import { prismaInstance } from "@/config/prisma/prisma";

const prisma = prismaInstance();

export class AuthController {
  private collectionName: string;
  private authService: AuthService;

  constructor() {
    this.collectionName = "User";
    this.authService = new AuthService(prisma.user, "User");
  }

  /**
   * Handles user login by verifying credentials and returning a token.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  login = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const loginDto: AuthDto = req.body;
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] login API invoked`, {
      email: loginDto.email,
      loggedUser,
    });

    try {
      const data = await this.authService.login(loginDto);
      logger.info(`[${this.collectionName} Controller] User login successful`, {
        email: loginDto.email,
        loggedUser,
      });

      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] login API error`, {
          email: loginDto.email,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(`[${this.collectionName} Controller] login API error: Unknown error occurred`, {
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Handles user registration by creating a new user and returning the registered user details.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  register = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const registerDto: RegisterDto = req.body;
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] Register API invoked`, {
      email: registerDto.email,
      loggedUser,
    });

    try {
      const data = await this.authService.register(registerDto);
      logger.info(`[${this.collectionName} Controller] User registration successful`, {
        email: registerDto.email,
        loggedUser,
      });

      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Register API error`, {
          email: registerDto.email,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(
          `[${this.collectionName} Controller] Register API error: Unknown error occurred`,
          {
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Handles user logout by invalidating the user's token.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  logout = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const token = req.headers.authorization?.split(" ")[1];
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] Logout API invoked`, { token, loggedUser });

    try {
      const data = await this.authService.logout(token!);
      logger.info(`[${this.collectionName} Controller] User logout successful`, {
        token,
        loggedUser,
      });

      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Logout API error`, {
          token,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(
          `[${this.collectionName} Controller] Logout API error: Unknown error occurred`,
          { loggedUser },
        );
      }
      next(error);
    }
  };

  /**
   * Extends the user's token and returns a new token.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extendToken = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const token = req.headers.authorization?.split(" ")[1];
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] ExtendToken API invoked`, {
      token,
      loggedUser,
    });

    try {
      const data = await this.authService.extendToken(token!);
      logger.info(`[${this.collectionName} Controller] Token extended successfully`, {
        data,
        loggedUser,
      });
      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] ExtendToken API error`, {
          token,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(
          `[${this.collectionName} Controller] ExtendToken API error: Unknown error occurred`,
          {
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Initiates the forgot password process for a user.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  forgotPassword = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { email } = req.body;
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] Forgot password API invoked`, {
      email,
      loggedUser,
    });

    try {
      const data = await this.authService.forgotPassword(email);
      logger.info(`[${this.collectionName} Controller] Forgot password successful`, {
        email,
        loggedUser,
      });
      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Forgot password API error`, {
          email,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(
          `[${this.collectionName} Controller] Forgot password API error: Unknown error occurred`,
          {
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Initiates the reset password process for a user.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  resetPassword = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { resetToken, password, confirmPassword } = req.body;
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] Reset password API invoked`, {
      resetToken,
      loggedUser,
    });

    const resetPasswordDto: ResetPasswordDto = {
      password,
      confirmPassword,
      resetToken,
    };
    try {
      const data = await this.authService.resetPassword(resetPasswordDto);
      logger.info(`[${this.collectionName} Controller] Reset password successful`, {
        resetToken,
        loggedUser,
      });
      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Reset password API error`, {
          resetToken,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(
          `[${this.collectionName} Controller] Reset password API error: Unknown error occurred`,
          {
            loggedUser,
          },
        );
      }
      next(error);
    }
  };
}


File: src/entities/auth/auth.dto.ts
--------------------------------------------------
Content of src/entities/auth/auth.dto.ts:
import { userSchema } from "@/generated/zod";
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { z } from "zod";

extendZodWithOpenApi(z);

const passwordSchema = z
  .string()
  .min(8)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  .superRefine((value: string, context: any) => {
    if (value === value.toLowerCase()) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a capital letter",
      });
    }

    if (value === value.toUpperCase()) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a lowercase letter",
      });
    }

    if (!/\d/.test(value)) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a number",
      });
    }

    // eslint-disable-next-line no-useless-escape
    if (!/[!"#$%&'()*+,./:;<=>?@[\\\]^_`{|}~\-]/.test(value)) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a special character",
      });
    }
  });

export const loginSchema = z.object({
  email: z.string().email(),
  password: passwordSchema,
});

export const authResponseSchema = z.object({
  user: userSchema,
  token: z.string(),
});

export const logoutSchema = z.object({
  success: z.boolean(),
});

export const extendTokenSchema = z.object({
  token: z.string(),
});

export const forgotPasswordSchema = z.object({
  email: z.string().email().trim(),
});

export const resetPasswordSchema = z
  .object({
    resetToken: z.string(),
    password: passwordSchema,
    confirmPassword: z.string().min(8),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });

export const registerSchema = z
  .object({
    name: z.string().min(2).max(50),
    email: z.string().email(),
    password: passwordSchema,
    confirmPassword: z.string().min(8),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });

export type RegisterDto = z.infer<typeof registerSchema>;
export type AuthDto = z.infer<typeof loginSchema>;
export type ResetPasswordDto = z.infer<typeof resetPasswordSchema>;


File: src/entities/auth/auth.route.ts
--------------------------------------------------
Content of src/entities/auth/auth.route.ts:
import { Router } from "express";
import { authMiddleware, zodValidation } from "@/middlewares";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import {
  loginSchema,
  extendTokenSchema,
  forgotPasswordSchema,
  logoutSchema,
  registerSchema,
  resetPasswordSchema,
  authResponseSchema,
} from "@/entities/auth/auth.dto";
import { AuthController } from "@/entities/auth/auth.controller";

const authRouter = Router();

const TAG = "Auth";
const ROUTE = `/${TAG.toLowerCase()}`;

export const authRegistry = new OpenAPIRegistry();
const authController = new AuthController();

authRegistry.register(TAG, loginSchema);

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/login`,
  tags: [TAG],
  summary: "Login",
  request: {
    body: {
      content: { "application/json": { schema: loginSchema } },
    },
  },
  responses: createApiResponse(authResponseSchema, "Login Successfully"),
});
authRouter.post("/login", zodValidation(loginSchema), authController.login);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/register`,
  tags: [TAG],
  summary: "Register",
  request: {
    body: {
      content: { "application/json": { schema: registerSchema } },
    },
  },
  responses: createApiResponse(authResponseSchema, "Register Successfully"),
});
authRouter.post("/register", zodValidation(registerSchema), authController.register);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/extend-token`,
  tags: [TAG],
  summary: "Extend Token",
  request: {
    body: {
      content: { "application/json": { schema: extendTokenSchema } },
    },
  },
  responses: createApiResponse(extendTokenSchema, "Token Extended Successfully"),
});
authRouter.post(
  "/extend-token",
  authMiddleware,
  zodValidation(extendTokenSchema),
  authController.extendToken,
);

//====================================================================================================

authRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/logout`,
  tags: [TAG],
  summary: "Logout",
  responses: createApiResponse(logoutSchema, "Logout Successfully"),
});
authRouter.get("/logout", authMiddleware, authController.logout);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/forgot-password`,
  tags: [TAG],
  summary: "Forgot Password",
  request: {
    body: {
      content: { "application/json": { schema: forgotPasswordSchema } },
    },
  },
  responses: createApiResponse(forgotPasswordSchema, "Reset link sent. Check you email"),
});
authRouter.post(
  "/forgot-password",
  zodValidation(forgotPasswordSchema),
  authController.forgotPassword,
);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/reset-password`,
  tags: [TAG],
  summary: "Reset Password",
  request: {
    body: {
      content: { "application/json": { schema: resetPasswordSchema } },
    },
  },
  responses: createApiResponse(resetPasswordSchema, "Password reset successful"),
});
authRouter.post(
  "/reset-password",
  zodValidation(resetPasswordSchema),
  authController.resetPassword,
);

export default authRouter;


File: src/entities/auth/auth.services.ts
--------------------------------------------------
Content of src/entities/auth/auth.services.ts:
import { compare, hash } from "bcryptjs";
import { logger } from "@/common/winston/winston";
import { AuthDto, RegisterDto, ResetPasswordDto } from "@/entities/auth/auth.dto";
import { generateToken, verifyToken } from "@/common/jwt/jwt";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { UserService } from "@/entities/user/user.service";
import { sendMail } from "@/common/mail-sender/mail-sender";
import { BaseRepository } from "@/common/base/base.repository";
import { CreateUserDto, UpdateUserDto } from "@/entities/user/user.dto";
import { env } from "@/config/env";
import { createTemplate } from "@/template/create-template";
import { user as User } from "@prisma/client";

export class AuthService {
  private collectionName: string;
  private userService: UserService;
  private userRepository: BaseRepository<User, UpdateUserDto, CreateUserDto>;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string) {
    this.collectionName = collectionName;
    this.userService = new UserService(model, "User");
    this.userRepository = new BaseRepository(model, "User");
  }

  /**
   * Handles user login by verifying the credentials and generating a token.
   * @param authData - Object containing user login credentials.
   * @returns Object containing the generated token.
   * @throws HTTP error if user not found or password is invalid.
   */
  login = async (authData: AuthDto) => {
    logger.info(`[${this.collectionName} Service] login service invoked`, {
      email: authData.email,
    });

    try {
      const user = await this.userService.getByEmail(authData.email);

      if (!user) {
        logger.warn(
          `[${this.collectionName} Service] ${this.collectionName} not found during login`,
          {
            email: authData.email,
          },
        );
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: "Auth",
        });
      }

      if (!(await compare(authData.password, user.password as string))) {
        logger.warn(`[${this.collectionName} Service] Invalid password during login`, {
          email: authData.email,
        });
        throw createHttpError(StatusCodes.BAD_REQUEST, "Invalid email or password", {
          resource: "Auth",
        });
      }

      const token = generateToken({
        id: user.id,
        name: user.name,
        email: user.email,
      });

      logger.info(`[${this.collectionName} Service] Token received successfully`, {
        email: authData.email,
      });
      return { user, token };
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error during login`, {
          error: error.message,
          email: authData.email,
        });
        throw new Error(`Error while login: ${error.message}`);
      }
      logger.warn(`[${this.collectionName} Service] Unknown error during login`, {
        email: authData.email,
      });
      throw new Error("Unknown error occurred while login");
    }
  };

  /**
   * Registers a new user and generates a token for the user.
   * @param registerDto - Registration data for a new user.
   * @returns Object containing the registered user and generated token.
   * @throws HTTP error if user already exists.
   */
  register = async (registerDto: RegisterDto) => {
    logger.info(`[${this.collectionName} Service] Register service invoked`, {
      email: registerDto.email,
    });

    try {
      await this.userService.create(registerDto);

      const login = await this.login(registerDto);

      logger.info(
        `[${this.collectionName} Service] ${this.collectionName} registered successfully`,
        {
          email: registerDto.email,
        },
      );
      return login;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error during registration`, {
          error: error.message,
          email: registerDto.email,
        });
        throw new Error(`[${this.collectionName} Service] Error while login: ${error.message}`);
      }
      logger.warn(`[${this.collectionName} Service] Unknown error during registration`, {
        email: registerDto.email,
      });
      throw new Error(`[${this.collectionName} Service] Unknown error occurred while login`);
    }
  };

  /**
   * Extends the user's token and returns a new token.
   * @param token - The current token to extend.
   * @returns The newly extended token.
   * @throws Error if token extension fails.
   */
  extendToken = async (token: string) => {
    logger.info(`[${this.collectionName} Service] Extend token service invoked`, { token });

    try {
      const payload = verifyToken(token);
      const newToken = generateToken({
        id: payload.id,
        name: payload.name,
        email: payload.email,
      });
      logger.info(`[${this.collectionName} Service] Token extended successfully`, { newToken });
      return newToken;
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error extending token`, {
          error: error.message,
          token,
        });
        throw new Error(`[${this.collectionName} Service] Error extend token: ${error.message}`);
      }
      logger.warn(`[${this.collectionName} Service] Unknown error while extending token`, {
        token,
      });
      throw new Error(`[${this.collectionName} Service] Unknown error occurred while extend token`);
    }
  };

  /**
   * Logs out the user by invalidating the token.
   * @param token - The token to invalidate.
   * @returns Object with the invalidated token and success status.
   * @throws Error if logout fails.
   */
  logout = async (token: string) => {
    logger.info(`[${this.collectionName} Service] Logout service invoked`, { token });

    try {
      return { token, success: true };
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error during logout`, {
          error: error.message,
          token,
        });
        throw new Error(`Error logout: ${error.message}`);
      }
      logger.warn(`[${this.collectionName} Service] Unknown error during logout`, { token });
      throw new Error("Unknown error occurred while logout");
    }
  };

  /**
   * Initiates the forgot password process for a user.
   * @param email User's email address
   * @returns message that email sent.
   * @throws HTTP error if any error occur.
   */
  forgotPassword = async (email: string) => {
    logger.info(`[${this.collectionName} Service] Forgot password service invoked`, { email });

    try {
      const user = await this.userService.getByEmail(email);

      if (!user) {
        logger.warn(`[${this.collectionName} Service] ${this.collectionName} does not exists!`, {
          email,
        });
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: "Auth",
        });
      }

      const resetToken = generateToken({
        id: user.id,
        name: user.name,
        email: user.email,
      });

      await this.userService.update(user.id as string, {
        resetToken,
        name: user.name!,
        email: user.email,
        updatedAt: new Date(),
      });

      // Send email
      try {
        const context = {
          accountName: user.name,
          URL: `${env.APP_URL}/reset-password?token=${resetToken}`,
        };

        const options = {
          from: `${env.MAILGUN_NAME} <${env.MAILGUN_SENDER_EMAIL}>`,
          to: email,
          subject: "Reset Password Requested",
          html: createTemplate("forgot-password", context),
        };

        await sendMail(options);
      } catch (error) {
        console.log(`Error: ${error}`);
        throw new Error(`Error while sending email: ${error}`);
      }

      logger.info(`[${this.collectionName} Service] Email reset link successfully sent`, {
        email,
        resetToken,
      });
      return { message: "Reset link sent. Check your inbox" };
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error during registration`, {
          error: error.message,
          email,
        });
        throw new Error(
          `[${this.collectionName} Service] Error while forgot password: ${error.message}`,
        );
      }
      logger.warn(`[${this.collectionName} Service] Unknown error during registration`, {
        email,
      });
      throw new Error(
        `[${this.collectionName} Service] Unknown error occurred while forgot password`,
      );
    }
  };

  resetPassword = async (resetPasswordDto: ResetPasswordDto) => {
    logger.info(`[${this.collectionName} Service] reset password service invoked`, {
      resetToken: resetPasswordDto.resetToken,
    });

    try {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const user: any = await this.userRepository.getByField(
        "resetToken",
        resetPasswordDto.resetToken,
      );

      if (user.length === 0) {
        logger.warn(`[${this.collectionName} Service] ${this.collectionName} does not exists!`, {
          resetToken: resetPasswordDto.resetToken,
        });
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: "Auth",
        });
      }

      if (!user[0].resetToken || resetPasswordDto.resetToken !== user[0].resetToken) {
        throw createHttpError(StatusCodes.BAD_REQUEST, "Invalid or expired reset token.");
      }

      const hashedPassword = await hash(resetPasswordDto.password, env.HASH!);

      await this.userService.update(user[0].id, {
        password: hashedPassword,
        resetToken: null,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any);

      logger.info(`[${this.collectionName} Service] Password reset successful`, {
        resetToken: resetPasswordDto.resetToken,
      });
      return { message: "Password reset successful" };
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error during registration`, {
          error: error.message,
          resetToken: resetPasswordDto.resetToken,
        });
        throw new Error(
          `[${this.collectionName} Service] Error while reset password: ${error.message}`,
        );
      }
      logger.warn(`[${this.collectionName} Service] Unknown error during registration`, {
        resetToken: resetPasswordDto.resetToken,
      });
      throw new Error(
        `[${this.collectionName} Service] Unknown error occurred while reset password`,
      );
    }
  };
}


File: src/entities/health/health.controller.ts
--------------------------------------------------
Content of src/entities/health/health.controller.ts:
import { NextFunction, Response } from "express";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import {
  checkRedis,
  createHealthCheckResponse,
  formatMemoryUsage,
} from "@/entities/health/health.helper";
import { StatusCodes } from "http-status-codes";
import fs from "fs";
import { env } from "@/config/env";
import path from "path";
import { RedisClient } from "@/config/redis/redis";

export class HealthController {
  private logFileName: string;

  constructor() {
    this.logFileName = "[Auth Controller]";
  }

  /**
   * Handles health of server.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  health = async (_: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    try {
      const healthCheck = {
        redis: await checkRedis(),
        server: {
          status: "healthy",
          uptime: process.uptime(),
          memoryUsage: formatMemoryUsage(),
        },
      };

      const overallStatus = Object.values(healthCheck)
        .map((service) => service.status)
        .includes("unhealthy")
        ? "unhealthy"
        : "healthy";

      res
        .status(overallStatus === "healthy" ? StatusCodes.OK : StatusCodes.INTERNAL_SERVER_ERROR)
        .json(createHealthCheckResponse(overallStatus, healthCheck));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} health API error`, {
          error: error.message,
        });
      } else {
        logger.warn(`${this.logFileName} health API error: Unknown error occurred`);
      }
      next(error);
    }
  };

  /**
   * * Clear Redis API cache.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  clearCache = async (_: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    try {
      const redis = RedisClient.getInstance();
      const stream = redis.scanStream({
        match: "apiResponseCache*", // Pattern to match keys
        count: 100, // Process 100 keys per iteration
      });

      const keysToDelete: string[] = [];

      for await (const keys of stream) {
        keysToDelete.push(...keys);
      }

      if (keysToDelete.length > 0) {
        await redis.del(...keysToDelete);
        logger.info(`Cleared ${keysToDelete.length} keys with prefix apiResponseCache`);
      } else {
        logger.info("No keys found with prefix apiResponseCache");
      }
      res.json({ message: "Cache cleared successfully" });
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} clearCache API error`, {
          error: error.message,
        });
      } else {
        logger.warn(`${this.logFileName} clearCache API error: Unknown error occurred`);
      }
      next(error);
    }
  };

  /**
   * Handles health of server.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  clearLogFiles = async (_: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!fs.existsSync(env.LOGS_DIRECTORY)) {
        fs.mkdirSync(env.LOGS_DIRECTORY);
      }

      const files = fs.readdirSync(env.LOGS_DIRECTORY);

      files.forEach((file) => {
        const filePath = path.join(env.LOGS_DIRECTORY, file);
        fs.unlinkSync(filePath);
      });

      res.json({ message: "All log files have been cleared." });
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} clearLogFiles API error`, {
          error: error.message,
        });
      } else {
        logger.warn(`${this.logFileName} clearLogFiles API error: Unknown error occurred`);
      }
      next(error);
    }
  };
}


File: src/entities/health/health.helper.ts
--------------------------------------------------
Content of src/entities/health/health.helper.ts:
import { RedisClient } from "@/config/redis/redis";

export const checkRedis = async () => {
  try {
    const redis = RedisClient.getInstance();
    await redis.ping();
    return { status: "healthy", details: {} };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    return { status: "unhealthy", details: { error: error.message } };
  }
};

export const formatMemoryUsage = () => {
  const memoryUsage = process.memoryUsage();
  return {
    rss: `${(memoryUsage.rss / 1024 / 1024).toFixed(2)} MB`,
    heapTotal: `${(memoryUsage.heapTotal / 1024 / 1024).toFixed(2)} MB`,
    heapUsed: `${(memoryUsage.heapUsed / 1024 / 1024).toFixed(2)} MB`,
    external: `${(memoryUsage.external / 1024 / 1024).toFixed(2)} MB`,
  };
};

export const createHealthCheckResponse = (status: string, details: Record<string, unknown>) => ({
  status,
  details,
});


File: src/entities/health/health.route.ts
--------------------------------------------------
Content of src/entities/health/health.route.ts:
import { Router } from "express";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import { HealthController } from "@/entities/health/health.controller";
import { z } from "zod";

const healthRouter = Router();

const TAG = "Health";
const ROUTE = `/${TAG.toLowerCase()}`;

export const healthRegistry = new OpenAPIRegistry();
const healthController = new HealthController();

healthRegistry.register(TAG, z.any());

//====================================================================================================

healthRegistry.registerPath({
  method: "get",
  path: ROUTE,
  summary: "Get health check",
  tags: [TAG],
  security: [],
  responses: createApiResponse(z.any(), "Success"),
});

healthRouter.get("/", healthController.health);

//====================================================================================================

healthRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/clear-cache`,
  summary: "Clear cache",
  tags: [TAG],
  security: [],
  responses: createApiResponse(z.any(), "Success"),
});

healthRouter.get("/clear-cache", healthController.clearCache);

//====================================================================================================

healthRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/clear-logs`,
  summary: "Clear log files",
  tags: [TAG],
  security: [],
  responses: createApiResponse(z.any(), "Success"),
});

healthRouter.get("/clear-logs", healthController.clearLogFiles);

export default healthRouter;


File: src/entities/user/user.dto.ts
--------------------------------------------------
Content of src/entities/user/user.dto.ts:
import { userSchema } from "@/generated/zod";
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { z } from "zod";

extendZodWithOpenApi(z);

export const createUserSchema = userSchema
  .omit({
    id: true,
    createdAt: true,
    updatedAt: true,
  })
  .partial();

export const updateUserSchema = userSchema
  .omit({
    id: true,
    password: true,
    createdAt: true,
  })
  .partial();

export type UserDto = z.infer<typeof userSchema>;
export type CreateUserDto = z.infer<typeof createUserSchema>;
export type UpdateUserDto = z.infer<typeof updateUserSchema>;


File: src/entities/user/user.controller.ts
--------------------------------------------------
Content of src/entities/user/user.controller.ts:
import { NextFunction, Response } from "express";
import { UserService } from "@/entities/user/user.service";
import { StatusCodes } from "http-status-codes";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import { createResponse } from "@/utils/create-response";
import { BaseController } from "@/common/base/base.controller";
import { CreateUserDto, UpdateUserDto } from "@/entities/user/user.dto";
import { file as File, user as User } from "@prisma/client";
import { prismaInstance } from "@/config/prisma/prisma";
import { FileService } from "../file/file.service";
import { deleteFileFromDisk } from "@/common/multer/delete-file-from-disk";

const prisma = prismaInstance();
const IGNORE_FIELDS = { password: true };

export class UserController extends BaseController<User, CreateUserDto, UpdateUserDto> {
  public collectionName: string;
  public userService: UserService;
  public fileService: FileService;

  constructor() {
    super(prisma.user, "User", IGNORE_FIELDS);
    this.collectionName = "User";
    this.userService = new UserService(prisma.user, this.collectionName, IGNORE_FIELDS);
    this.fileService = new FileService(prisma.file, "Files", {});
  }

  /**
   * Create a new entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON created entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  create = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const createDto = req.body;
    const { loggedUser } = req;
    try {
      logger.info(`[${this.collectionName} Controller] Creating new ${this.collectionName}`, {
        loggedUser,
        createDto,
      });
      const created = await this.userService.create(createDto);
      return res.json(createResponse({ data: created, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error creating ${this.collectionName}`, {
          error: error.message,
          loggedUser,
          createDto,
        });
      }
      next(error);
    }
  };

  /**
   * Update an existing entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON updated entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  update = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { id } = req.params;
    const updateDto = req.body;
    const { loggedUser } = req;
    try {
      logger.info(`[${this.collectionName} Controller] Updating ${this.collectionName}`, {
        loggedUser,
        id,
        updateDto,
      });
      const updatedData = await this.userService.update(id, updateDto);
      return res.json(createResponse({ data: updatedData, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error updating ${this.collectionName}`, {
          error: error.message,
          loggedUser,
          id,
          updateDto,
        });
      }
      next(error);
    }
  };

  /**
   * Delete a entity by ID
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON success message
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  delete = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { id } = req.params;
    try {
      logger.info(`[${this.collectionName} Controller] Deleting ${this.collectionName} by id`, {
        id,
        loggedUser,
      });

      const files = await this.fileService.getByUser(id);

      if (Array.isArray(files) && files.length > 0) {
        (files as File[]).map(async (file: File) => {
          const fileName = file.path!.split("/").pop();
          await deleteFileFromDisk(fileName!);
        });
        await this.fileService.deleteMany((files as File[]).map((file: File) => file.id));
      }

      const data = await this.baseService.delete(id);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error deleting ${this.collectionName}`, {
          error: error.message,
          id,
          loggedUser,
        });
      }
      next(error);
    }
  };
}


File: src/entities/user/user.service.ts
--------------------------------------------------
Content of src/entities/user/user.service.ts:
import { UpdateUserDto, CreateUserDto } from "@/entities/user/user.dto";
import { env } from "@/config/env";
import { hash } from "bcryptjs";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { logger } from "@/common/winston/winston";
import { BaseService } from "@/common/base/base.services";
import { user as User } from "@prisma/client";

export class UserService extends BaseService<User, CreateUserDto, UpdateUserDto> {
  private collectionNameService: string;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string, ignoreFields?: Record<string, boolean>) {
    super(model, collectionName, ignoreFields);
    this.collectionNameService = collectionName;
  }

  /**
   * Creates a new entity.
   * @param createDto - Data for creating a new entity
   * @returns Created entity data
   */
  create = async (createDto: CreateUserDto): Promise<User | null> => {
    try {
      logger.info(
        `[${this.collectionNameService} Service] Creating ${this.collectionNameService} with email: ${createDto.email}`,
      );
      const data = await this.baseRepository.getByEmail(createDto.email!);

      if (data) {
        logger.warn(
          `[${this.collectionNameService} Service] ${this.collectionNameService} with email ${createDto.email} already exists`,
        );
        throw createHttpError(
          StatusCodes.BAD_REQUEST,
          `${this.collectionNameService} already exists!`,
          {
            resource: this.collectionNameService,
          },
        );
      }

      const hashedPassword = await hash(createDto.password!, env.HASH!);

      const newDto = {
        name: createDto.name,
        email: createDto.email,
        password: hashedPassword,
      };

      return await this.baseRepository.create(newDto);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionNameService} Service] Error creating ${this.collectionNameService}`,
          {
            createDto,
            error: error.message,
          },
        );
        throw new Error(`Error creating ${this.collectionNameService}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionNameService} Service] Unknown error occurred while creating ${this.collectionNameService}`,
      );
      throw new Error(`Unknown error occurred while creating ${this.collectionNameService}`);
    }
  };

  /**
   * Updates an existing entity.
   * @param id - entity's unique identifier
   * @param updateDto - Data to update the entity with
   * @returns Updated entity data
   */
  update = async (id: string, updateDto: UpdateUserDto): Promise<User | null> => {
    try {
      logger.info(
        `[${this.collectionNameService} Service] Updating ${this.collectionNameService} with id: ${id}`,
      );
      const data = await this.getById(id);

      if (!data) {
        logger.warn(
          `[${this.collectionNameService} Service] ${this.collectionNameService} with id ${id} does not exist!`,
        );
        throw createHttpError(
          StatusCodes.BAD_REQUEST,
          `${this.collectionNameService} does not exist!`,
          {
            resource: this.collectionNameService,
          },
        );
      }

      if (updateDto.email) {
        const email = await this.baseRepository.getByEmail(updateDto.email);
        if (email) {
          logger.warn(
            `[${this.collectionNameService} Service] ${this.collectionNameService} with email ${updateDto.email} already exists`,
          );
          throw createHttpError(StatusCodes.BAD_REQUEST, "Email already exists!", {
            resource: this.collectionNameService,
          });
        }
      }

      // If (updateDto.password) {
      //   UpdateDto.password = await hash(updateDto.password, env.HASH!);
      // }

      updateDto.updatedAt = new Date();

      return await this.baseRepository.update(id, updateDto);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionNameService} Service] Error updating ${this.collectionNameService}`,
          {
            id,
            updateDto,
            error: error.message,
          },
        );
        throw new Error(`Error updating ${this.collectionNameService}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionNameService} Service] Unknown error occurred while updating ${this.collectionNameService}`,
      );
      throw new Error(`Unknown error occurred while updating ${this.collectionNameService}`);
    }
  };
}


File: src/entities/user/user.route.ts
--------------------------------------------------
Content of src/entities/user/user.route.ts:
import { createUserSchema, updateUserSchema } from "@/entities/user/user.dto";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { UserController } from "@/entities/user/user.controller";
import { authMiddleware } from "@/middlewares";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import { zodValidation } from "@/middlewares/zod-validation";
import { z } from "zod";
import { findByQuerySchema } from "@/schemas/find-by-query";
import { Router } from "express";
import { importFileSchema } from "@/schemas/import-file";
import { uploadImportMiddleware } from "@/common/multer/multer";
import { userSchema } from "@/generated/zod";

const userRouter = Router();
userRouter.use(authMiddleware);

const TAG = "User";
const ROUTE = `/${TAG.toLowerCase()}`;

export const userRegistry = new OpenAPIRegistry();
const userController = new UserController();

userRegistry.register(TAG, userSchema);

userRegistry.registerPath({
  method: "get",
  path: ROUTE,
  summary: `Get all ${TAG}`,
  tags: [TAG],
  responses: createApiResponse(z.array(userSchema), "Success"),
});
userRouter.get("/", userController.getAll);

//====================================================================================================

userRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/import`,
  tags: [TAG],
  summary: `Import ${TAG}`,
  request: {
    body: {
      content: { "multipart/form-data": { schema: importFileSchema } },
    },
  },
  responses: createApiResponse(z.null(), `${TAG}s Imported Successfully`),
});
userRouter.post("/import", uploadImportMiddleware, userController.import);

//====================================================================================================

userRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/export`,
  summary: `Export ${TAG}`,
  tags: [TAG],
  responses: createApiResponse(z.null(), `${TAG}s Exported Successfully`),
});
userRouter.get("/export", userController.export);

//====================================================================================================

userRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  summary: `Get ${TAG} by id`,
  request: {
    params: z.object({ id: z.string() }),
  },
  responses: createApiResponse(userSchema, "Success"),
});
userRouter.get("/:id", userController.getById);

//====================================================================================================

userRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/email/{email}`,
  tags: [TAG],
  summary: `Get ${TAG} by email`,
  request: {
    params: z.object({ email: z.string() }),
  },
  responses: createApiResponse(userSchema, "Success"),
});
userRouter.get("/email/:email", userController.getByEmail);

//====================================================================================================

userRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/find`,
  tags: [TAG],
  summary: `Find ${TAG} by query`,
  request: {
    body: {
      content: { "application/json": { schema: findByQuerySchema } },
    },
  },
  responses: createApiResponse(z.array(findByQuerySchema), "Success"),
});
userRouter.post("/find", zodValidation(findByQuerySchema), userController.findByQuery);

//====================================================================================================

userRegistry.registerPath({
  method: "post",
  path: ROUTE,
  tags: [TAG],
  summary: `Create ${TAG}`,
  request: {
    body: {
      content: { "application/json": { schema: createUserSchema } },
    },
  },
  responses: createApiResponse(createUserSchema, `${TAG} Created Successfully`),
});
userRouter.post("/", zodValidation(createUserSchema), userController.create);

//====================================================================================================

userRegistry.registerPath({
  method: "put",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  summary: `Update ${TAG}`,
  request: {
    params: z.object({ id: z.string() }),
    body: {
      content: { "application/json": { schema: updateUserSchema } },
    },
  },
  responses: createApiResponse(userSchema, `${TAG} Updated Successfully`),
});
userRouter.put("/:id", zodValidation(updateUserSchema), userController.update);

//====================================================================================================

userRegistry.registerPath({
  method: "delete",
  path: `${ROUTE}/bulk`,
  tags: [TAG],
  summary: `Delete ${TAG} in bulk`,
  request: {
    body: {
      content: { "application/json": { schema: z.object({ ids: z.array(z.string()) }) } },
    },
  },
  responses: createApiResponse(z.null(), `${TAG}s Deleted Successfully`),
});
userRouter.delete(
  "/bulk",
  zodValidation(z.object({ ids: z.array(z.string()) })),
  userController.deleteMany,
);

//====================================================================================================

userRegistry.registerPath({
  method: "delete",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  summary: `Delete ${TAG}`,
  request: {
    params: z.object({ id: z.string() }),
  },
  responses: createApiResponse(z.null(), `${TAG} Deleted Successfully`),
});
userRouter.delete("/:id", userController.delete);

export default userRouter;


