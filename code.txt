Directory Structure:
-------------------
/
├── .husky/
│   └── pre-commit
├── .vscode/
│   └── launch.json
├── prisma/
│   └── schema.prisma
├── src/
│   ├── common/
│   │   ├── base/
│   │   │   ├── base.controller.ts
│   │   │   ├── base.repository.ts
│   │   │   └── base.services.ts
│   │   ├── jwt/
│   │   │   └── jwt.ts
│   │   ├── mail-sender/
│   │   │   └── mail-sender.ts
│   │   ├── multer/
│   │   │   ├── delete-file-from-disk.ts
│   │   │   ├── multer.ts
│   │   │   ├── save-file-to-disk.ts
│   │   │   └── update-file-to-disk.ts
│   │   ├── swagger/
│   │   │   ├── swagger-document-generator.ts
│   │   │   ├── swagger-response-builder.ts
│   │   │   ├── swagger-response.ts
│   │   │   └── swagger.router.ts
│   │   └── winston/
│   │       └── winston.ts
│   ├── config/
│   │   ├── prisma/
│   │   │   ├── errors.prisma.ts
│   │   │   └── prisma.ts
│   │   ├── redis/
│   │   │   └── redis.ts
│   │   └── env.ts
│   ├── entities/
│   │   ├── auth/
│   │   │   ├── auth.controller.ts
│   │   │   ├── auth.dto.ts
│   │   │   ├── auth.route.ts
│   │   │   └── auth.services.ts
│   │   ├── file/
│   │   │   ├── file.controller.ts
│   │   │   ├── file.dto.ts
│   │   │   ├── file.route.ts
│   │   │   └── file.service.ts
│   │   ├── health/
│   │   │   ├── health.controller.ts
│   │   │   ├── health.helper.ts
│   │   │   └── health.route.ts
│   │   └── user/
│   │       ├── user.controller.ts
│   │       ├── user.dto.ts
│   │       ├── user.route.ts
│   │       └── user.service.ts
│   ├── generated/
│   │   └── zod/
│   │       └── index.ts
│   ├── middlewares/
│   │   ├── auth-middleware.ts
│   │   ├── cors.ts
│   │   ├── error-middleware.ts
│   │   ├── index.ts
│   │   └── zod-validation.ts
│   ├── routes/
│   │   └── routes.ts
│   ├── schemas/
│   │   ├── find-by-query.ts
│   │   ├── import-file.ts
│   │   └── query-examples.txt
│   ├── template/
│   │   ├── create-template.ts
│   │   └── forgot-password.hbs
│   ├── types/
│   │   ├── pagination.ts
│   │   └── request.ts
│   ├── utils/
│   │   ├── create-response.ts
│   │   ├── csv-to-json.ts
│   │   └── utils.ts
│   ├── .DS_Store
│   ├── app.ts
│   └── server.ts
├── tests/
│   ├── auth.validation.test.ts
│   ├── files.test.ts
│   └── test.helper.ts
├── .DS_Store
├── .env
├── .env.example
├── .gitignore
├── .prettierignore
├── .prettierrc
├── eslint.config.mjs
├── jest.config.ts
├── jest.setup.ts
├── nodemon.json
├── package.json
├── README.md
├── test-data.example.json
├── test-data.json
└── tsconfig.json

File: ./.prettierignore
--------------------------------------------------
Content of ./.prettierignore:
# Ignore artifacts:
node_modules
build
coverage
dist

File: ./README.md
--------------------------------------------------
Content of ./README.md:
# express-typescript-boilerplate-advance

repo to file command
python3 repo2file/dump.py ./advance-expressjs-boilerplate ./advance-expressjs-boilerplate/code.txt node_modules

File: ./jest.setup.ts
--------------------------------------------------
Content of ./jest.setup.ts:
afterAll(async () => {
  // eslint-disable-next-line no-underscore-dangle
  const app = (global as any).__APP__; // eslint-disable-line @typescript-eslint/no-explicit-any
  if (app && app.close) {
    await app.close(); // Gracefully shutdown app instance if applicable
  }
});


File: ./.gitignore
--------------------------------------------------
Content of ./.gitignore:
# Node modules
node_modules/

# Build output
dist/
build/

# TypeScript files
*.tsbuildinfo

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE and editor folders
.vscode/
.idea/
*.swp
*.swo
*.sublime-project
*.sublime-workspace

# Temporary files
.DS_Store
Thumbs.db
*.tmp
*.temp

# OS generated files
ehthumbs.db
Icon?
Desktop.ini

# Coverage directory used by tools like istanbul
coverage/

# Jest test results
jest/

uploads/
test-data.json

File: ./package.json
--------------------------------------------------
Content of ./package.json:
{
  "name": "advance-expressjs-boilerplate",
  "version": "3.0.0",
  "description": "",
  "main": "build/src/server.js",
  "scripts": {
    "clean": "rimraf build/",
    "build": "npm run clean && tsc && tsc-alias",
    "start": "npm run build && node --optimize_for_size build/src/server.js",
    "dev": "nodemon -exec --config nodemon.json 'ts-node' src/server.ts",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "prisma:pull": "prisma db pull --force",
    "prisma:push": "prisma db push",
    "prisma:gen": "prisma generate",
    "prisma:validate": "prisma validate",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "prettier": "prettier --write src/**",
    "prettier:check": "prettier --check src/**",
    "prepare": "husky"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/TKAkhter/express-typescript-boilerplate-advance"
  },
  "bugs": {
    "url": "https://github.com/TKAkhter/express-typescript-boilerplate-advance/issues"
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ]
  },
  "homepage": "https://github.com/TKAkhter/express-typescript-boilerplate-advance#readme",
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@asteasolutions/zod-to-openapi": "^7.2.0",
    "@prisma/client": "^6.5.0",
    "@typescript-eslint/eslint-plugin": "^8.15.0",
    "@typescript-eslint/parser": "^8.15.0",
    "axios": "^1.7.7",
    "bcrypt": "^5.1.1",
    "colors": "^1.4.0",
    "compression": "^1.7.5",
    "connect-timeout": "^1.9.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "csv-parser": "^3.1.0",
    "dotenv": "^16.4.5",
    "express": "^4.21.1",
    "express-rate-limit": "^7.4.1",
    "express-slow-down": "^2.0.3",
    "form-data": "^4.0.1",
    "handlebars": "^4.7.8",
    "helmet": "^8.0.0",
    "hpp": "^0.2.3",
    "http-errors": "^2.0.0",
    "http-status-codes": "^2.3.0",
    "ioredis": "^5.4.1",
    "json2csv": "^6.0.0-alpha.2",
    "jsonwebtoken": "^9.0.2",
    "juice": "^11.0.0",
    "lodash": "^4.17.21",
    "mailgun.js": "^11.1.0",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "nocache": "^4.0.0",
    "nodemon": "^3.1.7",
    "prisma-zod-generator": "^0.8.13",
    "redis": "^4.7.0",
    "reflect-metadata": "^0.2.2",
    "response-time": "^2.3.3",
    "swagger-ui-express": "^5.0.1",
    "winston": "^3.17.0",
    "winston-daily-rotate-file": "^5.0.0",
    "winston-mongodb": "^6.0.0",
    "zod": "^3.23.8",
    "zod-prisma-types": "^3.2.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.15.0",
    "@types/bcrypt": "^5.0.2",
    "@types/compression": "^1.7.5",
    "@types/connect-timeout": "^0.0.39",
    "@types/cookie-parser": "^1.4.7",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.0",
    "@types/hpp": "^0.2.6",
    "@types/jest": "^29.5.14",
    "@types/json2csv": "^5.0.7",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/lodash": "^4.17.14",
    "@types/morgan": "^1.9.9",
    "@types/multer": "^1.4.12",
    "@types/node": "^22.9.0",
    "@types/response-time": "^2.3.8",
    "@types/supertest": "^6.0.2",
    "@types/swagger-ui-express": "^4.1.7",
    "eslint": "^9.15.0",
    "eslint-plugin-import": "^2.31.0",
    "globals": "^15.12.0",
    "husky": "^9.1.7",
    "jest": "^29.7.0",
    "lint-staged": "^15.2.10",
    "prettier": "^3.3.3",
    "prisma": "^6.5.0",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "tsc-alias": "^1.8.10",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.2",
    "typescript-eslint": "^8.14.0"
  }
}

File: ./.prettierrc
--------------------------------------------------
Content of ./.prettierrc:
{
  "bracketSameLine": false,
  "bracketSpacing": true,
  "endOfLine": "lf",
  "semi": true,
  "singleQuote": false,
  "tabWidth": 2,
  "trailingComma": "all",
  "useTabs": false,
  "printWidth": 100,
  "arrowParens": "always",
  "embeddedLanguageFormatting": "auto"
}


File: ./test-data.example.json
--------------------------------------------------
Content of ./test-data.example.json:
{
  "register": {
    "name": "name",
    "email": "email",
    "password": "password",
    "confirmPassword": "confirmPassword"
  },
  "login": {
    "email": "email",
    "password": "password"
  },
  "newPassword": "newPassword",
  "invalidLogin": {
    "email": "email",
    "password": "password"
  }
}


File: ./tsconfig.json
--------------------------------------------------
Content of ./tsconfig.json:
{
  "compilerOptions": {
    "incremental": true,
    "target": "es2019",
    "module": "commonjs",
    "declaration": true,
    "sourceMap": true,
    "removeComments": true,
    "outDir": "./build",
    "skipLibCheck": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictBindCallApply": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": "./",
    "resolveJsonModule": true,
    "paths": {
      "@/*": ["./src/*"]
    },
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "tsc-alias": {
    "verbose": false,
    "resolveFullPaths": true
  },
  "include": ["src", "src/types", "./node_modules/@types", "@types/jest", "tests"],
  "exclude": ["node_modules", "build"]
}


File: ./.env.example
--------------------------------------------------
Content of ./.env.example:
NODE_ENV=NODE_ENV
TZ=TZ
BASE_URL=BASE_URL
BASE_URL_HTTPS=BASE_URL_HTTPS
PORT=PORT
SERVER_TIMEOUT=SERVER_TIMEOUT
LOG_FILE_DURATION=LOG_FILE_DURATION
ALLOW_ORIGIN=ALLOW_ORIGIN
APP_URL=APP_URL
LOGS_DIRECTORY=LOGS_DIRECTORY

## -- Basic Auth secrets --
JWT_SECRET=JWT_SECRET
JWT_SECRET_EXPIRATION=JWT_SECRET_EXPIRATION
HASH=HASH

## -- Redis --
REDIS_URL=REDIS_URL

# MongoDB
MONGODB_URI=MONGODB_URI

ENABLE_WINSTON=ENABLE_WINSTON
ENABLE_LOGS=ENABLE_LOGS
ENABLE_ERROR_LOGS=ENABLE_ERROR_LOGS
LOGS_TYPE=LOGS_TYPE
MONGODB_ERROR_COLLECTION_NAME=MONGODB_ERROR_COLLECTION_NAME
MONGODB_MEMORY_LIMIT=MONGODB_MEMORY_LIMIT

# Mail Sender
MAILGUN_API_KEY=MAILGUN_API_KEY
MAILGUN_DOMAIN=MAILGUN_DOMAIN
MAILGUN_NAME=MAILGUN_NAME
MAILGUN_SENDER_EMAIL=MAILGUN_SENDER_EMAIL


File: ./eslint.config.mjs
--------------------------------------------------
Content of ./eslint.config.mjs:
import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";
import importPlugin from "eslint-plugin-import";


export default [{ files: ["**/*.{js,mjs,cjs,ts}"] },
{ languageOptions: { globals: globals.browser } },
pluginJs.configs.recommended,
...tseslint.configs.recommended,
{
  plugins: {
    importPlugin
  },
  "rules": {
    "accessor-pairs": ["error"],
    // "array-bracket-newline": ["error"],
    "array-bracket-spacing": ["error"],
    "array-callback-return": ["error"],
    // "array-element-newline": ["error"],
    // "arrow-body-style": ["error"],
    "arrow-parens": ["error"],
    "arrow-spacing": ["error"],
    "block-scoped-var": ["error"],
    "block-spacing": ["error"],
    // "brace-style": ["error"],
    "camelcase": ["error"],
    "capitalized-comments": ["error"],
    // "class-methods-use-this": "off",
    "comma-dangle": ["error"],
    "comma-spacing": ["error"],
    // "comma-style": ["error"],
    "computed-property-spacing": ["error"],
    "consistent-this": ["error"],
    "constructor-super": ["error"],
    "curly": ["error"],
    "default-case": ["error"],
    "default-case-last": ["error"],
    "default-param-last": ["error"],
    "dot-location": ["error"],
    "dot-notation": ["error"],
    "eol-last": ["error"],
    "eqeqeq": ["error"],
    "for-direction": ["error"],
    "func-call-spacing": ["error"],
    "func-name-matching": ["error"],
    "func-names": ["error"],
    // "function-call-argument-newline": ["error"],
    // "function-paren-newline": ["error"],
    "generator-star-spacing": ["error"],
    "getter-return": ["error"],
    "global-require": ["error"],
    "grouped-accessor-pairs": ["error"],
    "guard-for-in": ["error"],
    "handle-callback-err": ["error"],
    "id-blacklist": ["error"],
    "id-denylist": ["error"],
    "id-match": ["error"],
    // "implicit-arrow-linebreak": ["error"],
    "indent": ["error"],
    // "indent-legacy": ["error"],
    // "init-declarations": ["error"],
    "jsx-quotes": ["error"],
    "key-spacing": ["error"],
    "keyword-spacing": ["error"],
    // "linebreak-style": ["error"],
    // "lines-around-comment": ["error"],
    // "lines-around-directive": ["error"],
    "lines-between-class-members": "off",
    "logical-assignment-operators": ["error"],
    "max-classes-per-file": ["error"],
    "max-depth": ["error"],
    // "max-lines": ["error"],
    "max-nested-callbacks": ["error"],
    // "max-statements-per-line": ["error"],
    // "multiline-comment-style": ["error"],
    "multiline-ternary": ["error"],
    "new-parens": ["error"],
    // "newline-after-var": ["error"],
    // "newline-before-return": ["error"],
    // "newline-per-chained-call": ["error"],
    "no-alert": ["error"],
    "no-array-constructor": ["error"],
    "no-async-promise-executor": ["error"],
    "no-await-in-loop": ["error"],
    "no-bitwise": ["error"],
    "no-buffer-constructor": ["error"],
    "no-caller": ["error"],
    "no-case-declarations": ["error"],
    "no-catch-shadow": ["error"],
    "no-class-assign": ["error"],
    "no-compare-neg-zero": ["error"],
    "no-cond-assign": ["error"],
    "no-confusing-arrow": ["error"],
    "no-const-assign": ["error"],
    "no-constant-binary-expression": ["error"],
    "no-constant-condition": ["error"],
    "no-constructor-return": ["error"],
    "no-continue": ["error"],
    "no-control-regex": ["error"],
    "no-debugger": ["error"],
    "no-delete-var": ["error"],
    "no-div-regex": ["error"],
    "no-dupe-args": ["error"],
    "no-dupe-class-members": ["error"],
    "no-dupe-else-if": ["error"],
    "no-dupe-keys": ["error"],
    "no-duplicate-case": ["error"],
    "no-duplicate-imports": ["error"],
    "no-else-return": ["error"],
    "no-empty": ["error"],
    "no-empty-character-class": ["error"],
    "no-empty-function": ["error"],
    "no-empty-pattern": ["error"],
    "no-empty-static-block": ["error"],
    "no-eq-null": ["error"],
    "no-eval": ["error"],
    "no-ex-assign": ["error"],
    "no-extend-native": ["error"],
    "no-extra-bind": ["error"],
    "no-extra-boolean-cast": ["error"],
    "no-extra-label": ["error"],
    "no-extra-parens": ["error"],
    "no-extra-semi": ["error"],
    "no-fallthrough": ["error"],
    "no-floating-decimal": ["error"],
    "no-func-assign": ["error"],
    "no-global-assign": ["error"],
    "no-implicit-coercion": ["error"],
    "no-implicit-globals": ["error"],
    "no-implied-eval": ["error"],
    "no-import-assign": ["error"],
    "no-inner-declarations": ["error"],
    "no-invalid-regexp": ["error"],
    "no-invalid-this": ["error"],
    "no-irregular-whitespace": ["error"],
    "no-iterator": ["error"],
    "no-label-var": ["error"],
    "no-labels": ["error"],
    "no-lone-blocks": ["error"],
    "no-lonely-if": ["error"],
    "no-loop-func": ["error"],
    "no-loss-of-precision": ["error"],
    "no-misleading-character-class": ["error"],
    "no-mixed-operators": ["error"],
    "no-mixed-requires": ["error"],
    "no-mixed-spaces-and-tabs": ["error"],
    "no-multi-assign": ["error"],
    "no-multi-spaces": ["error"],
    "no-multi-str": ["error"],
    "no-multiple-empty-lines": ["error", { max: 1 }],
    "no-native-reassign": ["error"],
    // "no-negated-condition": ["error"],
    "no-negated-in-lhs": ["error"],
    "no-new": ["error"],
    "no-new-func": ["error"],
    "no-new-native-nonconstructor": ["error"],
    "no-new-object": ["error"],
    "no-new-require": ["error"],
    "no-new-symbol": ["error"],
    "no-new-wrappers": ["error"],
    "no-nonoctal-decimal-escape": ["error"],
    "no-obj-calls": ["error"],
    "no-object-constructor": ["error"],
    "no-octal": ["error"],
    "no-octal-escape": ["error"],
    "no-param-reassign": ["error"],
    "no-path-concat": ["error"],
    "no-plusplus": ["error"],
    "no-process-exit": ["error"],
    "no-promise-executor-return": ["error"],
    "no-proto": ["error"],
    "no-prototype-builtins": ["error"],
    "no-redeclare": ["error"],
    "no-regex-spaces": ["error"],
    "no-restricted-exports": ["error"],
    "no-restricted-globals": ["error"],
    "no-restricted-imports": ["error"],
    "no-restricted-modules": ["error"],
    "no-restricted-properties": ["error"],
    "no-restricted-syntax": ["error"],
    "no-return-assign": ["error"],
    "no-return-await": ["error"],
    "no-script-url": ["error"],
    "no-self-assign": ["error"],
    "no-self-compare": ["error"],
    "no-sequences": ["error"],
    "no-setter-return": ["error"],
    "no-shadow": ["error"],
    "no-shadow-restricted-names": ["error"],
    "no-spaced-func": ["error"],
    "no-sparse-arrays": ["error"],
    "no-sync": "off",
    "no-tabs": ["error"],
    "no-template-curly-in-string": ["error"],
    "no-this-before-super": ["error"],
    "no-throw-literal": ["error"],
    "no-trailing-spaces": ["error"],
    "no-undef-init": ["error"],
    // "no-undefined": ["error"],
    "no-underscore-dangle": ["error"],
    "no-unexpected-multiline": ["error"],
    "no-unmodified-loop-condition": ["error"],
    "no-unneeded-ternary": ["error"],
    "no-unreachable": ["error"],
    "no-unreachable-loop": ["error"],
    "no-unsafe-finally": ["error"],
    "no-unsafe-negation": ["error"],
    "no-unsafe-optional-chaining": ["error"],
    "no-unused-expressions": "off",
    "@typescript-eslint/no-unused-expressions": ["error", { "allowShortCircuit": true }],
    "no-unused-labels": ["error"],
    "no-unused-private-class-members": ["error"],
    "no-use-before-define": ["error"],
    "no-useless-assignment": ["error"],
    "no-useless-backreference": ["error"],
    "no-useless-call": ["error"],
    "no-useless-catch": ["error"],
    "no-useless-computed-key": ["error"],
    "no-useless-concat": ["error"],
    "no-useless-constructor": ["error"],
    "no-useless-escape": ["error"],
    "no-useless-rename": ["error"],
    "no-useless-return": ["error"],
    "no-var": ["error"],
    "no-void": ["error"],
    "no-warning-comments": ["error"],
    "no-whitespace-before-property": ["error"],
    "no-with": ["error"],
    "nonblock-statement-body-position": ["error"],
    // "object-curly-newline": ["error"],
    // "object-curly-spacing": ["error"],
    // "object-property-newline": ["error"],
    "object-shorthand": ["error"],
    "one-var-declaration-per-line": ["error"],
    "operator-assignment": ["error"],
    // "operator-linebreak": ["error"],
    "padded-blocks": "off",
    "padding-line-between-statements": "off",
    "prefer-arrow-callback": ["error"],
    "prefer-const": ["error"],
    "prefer-destructuring": ["error"],
    "prefer-exponentiation-operator": ["error"],
    "prefer-numeric-literals": ["error"],
    "prefer-object-has-own": ["error"],
    "prefer-object-spread": ["error"],
    "prefer-promise-reject-errors": ["error"],
    "prefer-reflect": ["error"],
    "prefer-regex-literals": ["error"],
    "prefer-rest-params": ["error"],
    "prefer-spread": ["error"],
    "prefer-template": ["error"],
    "quote-props": ["error"],
    "quotes": ["error"],
    "radix": ["error"],
    // "require-atomic-updates": "off",
    "require-yield": ["error"],
    "rest-spread-spacing": ["error"],
    "semi": ["error"],
    "semi-spacing": ["error"],
    // "semi-style": ["error"],
    "sort-imports": ["off"],
    // "space-before-blocks": ["error"],
    // "space-before-function-paren": ["error"],
    // "space-in-parens": ["error"],
    // "space-infix-ops": ["error"],
    // "space-unary-ops": ["error"],
    // "spaced-comment": ["error"],
    "strict": ["error"],
    // "switch-colon-spacing": ["error"],
    // "symbol-description": ["error"],
    // "template-curly-spacing": ["error"],
    // "template-tag-spacing": ["error"],
    "unicode-bom": ["error"],
    "use-isnan": ["error"],
    "valid-typeof": ["error"],
    "vars-on-top": ["error"],
    "wrap-iife": ["error"],
    "wrap-regex": ["error"],
    // "yield-star-spacing": ["error"],
    "yoda": ["error"],
  }
}
];

File: ./jest.config.ts
--------------------------------------------------
Content of ./jest.config.ts:
/**
 * For a detailed explanation regarding each configuration property, visit:
 * https://jestjs.io/docs/configuration
 */

import { pathsToModuleNameMapper, JestConfigWithTsJest } from "ts-jest";
import { compilerOptions } from "./tsconfig.json";

/** @type {import('jest').Config} */
const jestConfig: JestConfigWithTsJest = {
  // All imported modules in your tests should be mocked automatically
  // Automock: false,

  // Stop running tests after `n` failures
  // Bail: 0,

  // The directory where Jest should store its cached dependency information
  // CacheDirectory: "/private/var/folders/b9/m478lz_d2632k8g9wfsm5lj00000gn/T/jest_dx",

  // Automatically clear mock calls, instances, contexts and results before every test
  clearMocks: true,

  // Indicates whether the coverage information should be collected while executing the test
  // CollectCoverage: false,

  // An array of glob patterns indicating a set of files for which coverage information should be collected
  // CollectCoverageFrom: undefined,

  // The directory where Jest should output its coverage files
  // CoverageDirectory: undefined,

  // An array of regexp pattern strings used to skip coverage collection
  // CoveragePathIgnorePatterns: [
  //   "/node_modules/"
  // ],

  // Indicates which provider should be used to instrument code for coverage
  // CoverageProvider: "babel",

  // A list of reporter names that Jest uses when writing coverage reports
  // CoverageReporters: [
  //   "json",
  //   "text",
  //   "lcov",
  //   "clover"
  // ],

  // An object that configures minimum threshold enforcement for coverage results
  // CoverageThreshold: undefined,

  // A path to a custom dependency extractor
  // DependencyExtractor: undefined,

  // Make calling deprecated APIs throw helpful error messages
  // ErrorOnDeprecated: false,

  // The default configuration for fake timers
  // FakeTimers: {
  //   "enableGlobally": false
  // },

  // Force coverage collection from ignored files using an array of glob patterns
  // ForceCoverageMatch: [],

  // A path to a module which exports an async function that is triggered once before all test suites
  // GlobalSetup: undefined,

  // A path to a module which exports an async function that is triggered once after all test suites
  // GlobalTeardown: undefined,

  // A set of global variables that need to be available in all test environments
  // Globals: {},

  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.
  // MaxWorkers: "50%",

  // An array of directory names to be searched recursively up from the requiring module's location
  moduleDirectories: ["node_modules", "./src"],

  // An array of file extensions your modules use
  // ModuleFileExtensions: [
  //   "js",
  //   "mjs",
  //   "cjs",
  //   "jsx",
  //   "ts",
  //   "tsx",
  //   "json",
  //   "node"
  // ],

  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module
  moduleNameMapper: pathsToModuleNameMapper(compilerOptions.paths, { prefix: "<rootDir>/" }),

  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader
  // ModulePathIgnorePatterns: [],

  // Activates notifications for test results
  // Notify: false,

  // An enum that specifies notification mode. Requires { notify: true }
  // NotifyMode: "failure-change",

  // A preset that is used as a base for Jest's configuration
  preset: "ts-jest",

  // Run tests from one or more projects
  // Projects: undefined,

  // Use this configuration option to add custom reporters to Jest
  reporters: ["default"],

  // Automatically reset mock state before every test
  // ResetMocks: false,

  // Reset the module registry before running each individual test
  // ResetModules: false,

  // A path to a custom resolver
  // Resolver: undefined,

  // Automatically restore mock state and implementation before every test
  // RestoreMocks: false,

  // The root directory that Jest should scan for tests and modules within
  // RootDir: undefined,

  // A list of paths to directories that Jest should use to search for files in
  // Roots: [
  //   "<rootDir>"
  // ],

  // Allows you to use a custom runner instead of Jest's default test runner
  // Runner: "jest-runner",

  // The paths to modules that run some code to configure or set up the testing environment before each test
  // SetupFiles: [],

  // A list of paths to modules that run some code to configure or set up the testing framework before each test
  setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"],

  // The number of seconds after which a test is considered as slow and reported as such in the results.
  // SlowTestThreshold: 5,

  // A list of paths to snapshot serializer modules Jest should use for snapshot testing
  // SnapshotSerializers: [],

  // The test environment that will be used for testing
  testEnvironment: "node",

  // Options that will be passed to the testEnvironment
  // TestEnvironmentOptions: {},

  // Adds a location field to test results
  // TestLocationInResults: false,

  // The glob patterns Jest uses to detect test files
  // TestMatch: [
  //   "**/__tests__/**/*.[jt]s?(x)",
  //   "**/?(*.)+(spec|test).[tj]s?(x)"
  // ],

  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped
  // TestPathIgnorePatterns: [
  //   "/node_modules/"
  // ],

  // The regexp pattern or array of patterns that Jest uses to detect test files
  // TestRegex: [],

  // This option allows the use of a custom results processor
  // TestResultsProcessor: undefined,

  // This option allows use of a custom test runner
  // TestRunner: "jest-circus/runner",

  // A map from regular expressions to paths to transformers
  // Transform: undefined,

  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation
  // TransformIgnorePatterns: [
  //   "/node_modules/",
  //   "\\.pnp\\.[^\\/]+$"
  // ],

  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them
  // UnmockedModulePathPatterns: undefined,

  // Indicates whether each individual test should be reported during the run
  // Verbose: undefined,

  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode
  // WatchPathIgnorePatterns: [],

  // Whether to use watchman for file crawling
  // Watchman: true,
  testTimeout: 30000,
  // Silent: true,
  detectOpenHandles: true,
  forceExit: true,
};

export default jestConfig;


File: .husky/pre-commit
--------------------------------------------------
Content of .husky/pre-commit:
npx lint-staged


File: .husky/_/pre-rebase
--------------------------------------------------
Content of .husky/_/pre-rebase:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-applypatch
--------------------------------------------------
Content of .husky/_/pre-applypatch:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/husky.sh
--------------------------------------------------
Content of .husky/_/husky.sh:
echo "husky - DEPRECATED

Please remove the following two lines from $0:

#!/usr/bin/env sh
. \"\$(dirname -- \"\$0\")/_/husky.sh\"

They WILL FAIL in v10.0.0
"

File: .husky/_/pre-auto-gc
--------------------------------------------------
Content of .husky/_/pre-auto-gc:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-merge-commit
--------------------------------------------------
Content of .husky/_/pre-merge-commit:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/post-commit
--------------------------------------------------
Content of .husky/_/post-commit:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/applypatch-msg
--------------------------------------------------
Content of .husky/_/applypatch-msg:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/prepare-commit-msg
--------------------------------------------------
Content of .husky/_/prepare-commit-msg:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/h
--------------------------------------------------
Content of .husky/_/h:
#!/usr/bin/env sh
[ "$HUSKY" = "2" ] && set -x
n=$(basename "$0")
s=$(dirname "$(dirname "$0")")/$n

[ ! -f "$s" ] && exit 0

if [ -f "$HOME/.huskyrc" ]; then
	echo "husky - '~/.huskyrc' is DEPRECATED, please move your code to ~/.config/husky/init.sh"
fi
i="${XDG_CONFIG_HOME:-$HOME/.config}/husky/init.sh"
[ -f "$i" ] && . "$i"

[ "${HUSKY-}" = "0" ] && exit 0

export PATH="node_modules/.bin:$PATH"
sh -e "$s" "$@"
c=$?

[ $c != 0 ] && echo "husky - $n script failed (code $c)"
[ $c = 127 ] && echo "husky - command not found in PATH=$PATH"
exit $c


File: .husky/_/post-checkout
--------------------------------------------------
Content of .husky/_/post-checkout:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/post-applypatch
--------------------------------------------------
Content of .husky/_/post-applypatch:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/.gitignore
--------------------------------------------------
Content of .husky/_/.gitignore:
*

File: .husky/_/post-rewrite
--------------------------------------------------
Content of .husky/_/post-rewrite:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/commit-msg
--------------------------------------------------
Content of .husky/_/commit-msg:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-push
--------------------------------------------------
Content of .husky/_/pre-push:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/post-merge
--------------------------------------------------
Content of .husky/_/post-merge:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-commit
--------------------------------------------------
Content of .husky/_/pre-commit:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: prisma/schema.prisma
--------------------------------------------------
Content of prisma/schema.prisma:
generator client {
  provider = "prisma-client-js"
}

generator zod {
  provider                         = "zod-prisma-types"
  output                           = "../src/generated/zod"
  useMultipleFiles                 = false
  writeBarrelFiles                 = false
  createInputTypes                 = false
  createModelTypes                 = true
  addInputTypeValidation           = false
  addIncludeType                   = false
  addSelectType                    = false
  validateWhereUniqueInput         = false
  createOptionalDefaultValuesTypes = false
  createRelationValuesTypes        = false
  createPartialTypes               = false
  useDefaultValidators             = false
  coerceDate                       = false
  writeNullishInModelTypes         = false
}

datasource db {
  provider = "mongodb"
  url      = env("MONGODB_URI")
}

model user {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  name        String?
  email       String
  password    String?
  resetToken  String?
  createdAt   DateTime? @default(now())
  updatedAt   DateTime? @updatedAt
  phoneNumber String?
  bio         String?
  file        file[]
}

model file {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  user      user?     @relation(fields: [userId], references: [id])
  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt
  name      String?
  path      String?
  text      String?
  tags      String?
  views     Int?
  userId    String?   @db.ObjectId
}

model errorLogs {
  id         String    @id @default(auto()) @map("_id") @db.ObjectId
  status     String?
  message    String?
  method     String?
  url        String?
  loggedUser String?
  name       String?
  stack      String?
  details    Json?
  createdAt  DateTime? @default(now())
  updatedAt  DateTime? @updatedAt
}


File: tests/auth.validation.test.ts
--------------------------------------------------
Content of tests/auth.validation.test.ts:
import request from "supertest";
import app from "../src/app";
import { RedisClient } from "../src/config/redis/redis";
import { logger } from "../src/common/winston/winston";
import { loadTestData } from "./test.helper";
import { user as User } from "@prisma/client";

const ROUTE = "/api/auth";

// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "info").mockImplementation(() => {});
// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "warn").mockImplementation(() => {});
// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "error").mockImplementation(() => {});

describe("Auth API Tests", () => {
  let authToken: string;
  let testUser: User;

  afterAll(async () => {
    await RedisClient.disconnect();
  });

  test("User Registration - Success", async () => {
    const { register } = loadTestData();

    const res = await request(app).post(`${ROUTE}/register`).send(register);
    if (res.error) {
      console.log("User Login - Success", JSON.parse(res.text));
    }
    if (res.status >= 200) {
      authToken = res.body.data.token;
      testUser = res.body.data.user;
    }
    expect(res.status).toBe(200);
    expect(res.body).toHaveProperty("message", "User registered successfully");
  });

  test("User Login - Success", async () => {
    const { login } = loadTestData();

    const res = await request(app).post(`${ROUTE}/login`).send(login);

    if (res.error) {
      console.log("User Login - Success", JSON.parse(res.text));
    }

    expect(res.status).toBe(200);
    expect(res.body.data).toHaveProperty("token");
    authToken = res.body.data.token;
    testUser = res.body.data.user;
  });

  test("Login with Invalid Credentials - Failure", async () => {
    const { invalidLogin } = loadTestData();

    const res = await request(app).post(`${ROUTE}/login`).send(invalidLogin);

    expect(res.status).toBe(400);
  });

  test("Register with Existing Email - Failure", async () => {
    const { register } = loadTestData();

    const res = await request(app).post(`${ROUTE}/register`).send(register);

    expect(res.status).toBe(400);
  });

  test("Password Reset Request - Success", async () => {
    const res = await request(app).post(`${ROUTE}/forgot-password`).send({
      email: testUser.email,
    });

    if (res.error) {
      console.log("Password Reset Request - Success", JSON.parse(res.text));
    }

    expect(res.status).toBe(200);
  });

  test("Password Reset with Valid Token - Success", async () => {
    const { login, newPassword } = loadTestData();

    const loginRes = await request(app).post(`${ROUTE}/login`).send(login);

    const res = await request(app).post(`${ROUTE}/reset-password`).send({
      resetToken: loginRes.body.data.user.resetToken,
      password: newPassword,
      confirmPassword: newPassword,
    });

    if (res.error) {
      console.log("Password Reset with Valid Token - Failure", JSON.parse(res.text));
    }

    expect(res.status).toBe(200);
  });

  test("Password Reset with Invalid Token - Success", async () => {
    const { newPassword } = loadTestData();

    const res = await request(app).post(`${ROUTE}/reset-password`).send({
      resetToken: "invalidToken",
      password: newPassword,
      confirmPassword: newPassword,
    });

    expect(res.status).toBe(400);
  });

  test("Access Protected Route Without Token - Failure", async () => {
    const res = await request(app).get("/api/user");
    expect(res.status).toBe(401);
  });

  test("Access Protected Route With Valid Token - Failure", async () => {
    const res = await request(app).get("/api/user").set("Authorization", `Bearer ${authToken}`);
    expect(res.status).toBe(200);
  });

  // Test("Invalid Email Format in Registration - Failure", async () => {
  //   Const res = await request(app).post(`${ROUTE}/register`).send({
  //     Email: "invalid-email",
  //     Password: "Test@123",
  //     Name: "Test User"
  //   });
  //   Expect(res.status).toBe(400);
  // });

  // Test("Short Password in Registration - Failure", async () => {
  //   Const res = await request(app).post(`${ROUTE}/register`).send({
  //     Email: "valid@email.com",
  //     Password: "123",
  //     Name: "User"
  //   });
  //   Expect(res.status).toBe(400);
  // });
});


File: tests/test.helper.ts
--------------------------------------------------
Content of tests/test.helper.ts:
import fs from "fs";

const filePath = "./test-data.json";

// Export const saveTestData = (newData: object) => {
//     Let existingData = {};

//     If (fs.existsSync(filePath)) {
//         ExistingData = JSON.parse(fs.readFileSync(filePath, "utf-8"));
//     }

//     Const updatedData = { ...existingData, ...newData };
//     Fs.writeFileSync(filePath, JSON.stringify(updatedData, null, 2));

// };

export const loadTestData = () => {
  if (fs.existsSync(filePath)) {
    return JSON.parse(fs.readFileSync(filePath, "utf-8"));
  }
  return {};
};


File: tests/files.test.ts
--------------------------------------------------
Content of tests/files.test.ts:
import request from "supertest";
import path from "path";
import app from "../src/app";
import { RedisClient } from "../src/config/redis/redis";
import { logger } from "../src/common/winston/winston";
import { loadTestData } from "./test.helper";
import { user as User, file as File } from "@prisma/client";

const ROUTE = "/api/file";

// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "info").mockImplementation(() => {});
// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "warn").mockImplementation(() => {});
// eslint-disable-next-line no-empty-function
jest.spyOn(logger, "error").mockImplementation(() => {});

afterAll(async () => {
  await RedisClient.disconnect();
});

describe("Files API Tests", () => {
  let authToken: string;
  let testUser: User;
  let testFile: File;

  beforeAll(async () => {
    const { login } = loadTestData();
    // Authenticate user and get token
    const loginResponse = await request(app).post("/api/auth/login").send(login);

    authToken = loginResponse.body.data.token;
    testUser = loginResponse.body.data.user;
  });

  // Should successfully upload a file
  it("should successfully upload a file", async () => {
    const response = await request(app)
      .post(`${ROUTE}/upload`)
      .set("Authorization", `Bearer ${authToken}`)
      .field({
        tags: "test, file",
        userRef: testUser.id,
      })
      .attach("file", path.join(__dirname, "test-file.png"));

    testFile = response.body.data;

    expect(response.status).toBe(200);
    expect(response.body.data).toHaveProperty("filePath");
  });

  it("should fetch uploaded file", async () => {
    const response = await request(app).get(ROUTE).set("Authorization", `Bearer ${authToken}`);

    expect(response.status).toBe(200);
    expect(Array.isArray(response.body.data)).toBe(true);
  });

  it("should fetch uploaded file by id", async () => {
    const response = await request(app)
      .get(`${ROUTE}/id/${testFile.id}`)
      .set("Authorization", `Bearer ${authToken}`);

    expect(response.status).toBe(200);
  });

  it("should fetch uploaded file by user id", async () => {
    const response = await request(app)
      .get(`${ROUTE}/user/${testFile.userId}`)
      .set("Authorization", `Bearer ${authToken}`);

    expect(response.status).toBe(200);
  });
});


File: .vscode/launch.json
--------------------------------------------------
Content of .vscode/launch.json:
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "node",
            "request": "launch",
            "name": "Launch Program",
            "skipFiles": [
                "<node_internals>/**"
            ],
            "program": "${workspaceFolder}/src/app.ts",
            "outFiles": [
                "${workspaceFolder}/**/*.js"
            ]
        }
    ]
}

File: src/app.ts
--------------------------------------------------
Content of src/app.ts:
import { errorMiddleware, cors } from "@/middlewares";
import express, { NextFunction, Request, Response } from "express";
import { apiRoutes } from "@/routes/routes";
import { env } from "@/config/env";
import { logger, morganStream } from "@/common/winston/winston";
import { openAPIRouter } from "@/common/swagger/swagger.router";
import { slowDown } from "express-slow-down";
import compression from "compression";
import cookieParser from "cookie-parser";
import helmet from "helmet";
import hpp from "hpp";
import morgan from "morgan";
import nocache from "nocache";
import path from "node:path";
import rateLimit from "express-rate-limit";
import responseTime from "response-time";
import timeout from "connect-timeout";

const app = express();

// Set the trust proxy to handle X-Forwarded-For correctly
app.set("trust proxy", 1);

// Middlewares
app.use(
  helmet.crossOriginResourcePolicy({
    policy: "cross-origin",
  }),
);

// Additional Security Headers
app.use((_, res: Response, next: NextFunction) => {
  res.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload");
  res.setHeader("X-Frame-Options", "DENY");
  res.setHeader("X-XSS-Protection", "1; mode=block");
  // Cross-Domain Policy
  res.setHeader("X-Permitted-Cross-Domain-Policies", "none");
  res.setHeader("X-Download-Options", "noopen");
  // Feature Policy
  res.setHeader("Feature-Policy", "geolocation 'none'; microphone 'none'; camera 'none';");
  // Expect-CT Header
  res.setHeader("Expect-CT", "enforce, max-age=30");

  next();
});
logger.info("Additional security headers set");

// Rate limiting middleware
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 500, // Limit each IP to 500 requests per windowMs
  message: {
    success: false,
    message: "Too many requests, please try again later.",
  },
  headers: true,
});

// Slow down requests from a single IP to prevent abuse
const speedLimiter = slowDown({
  windowMs: 15 * 60 * 1000, // 15 minutes
  delayAfter: 1000, // Allow 1000 requests, then start delaying
  delayMs: (hits) => hits * 500, // Add a 500ms delay per request above 1000
});

// Apply middlewares
app.use(cors); // Make sure this middleware is defined properly
logger.info("CORS middleware applied");
app.use(cookieParser());

if (env.ENABLE_WINSTON === "1") {
  app.use(morgan("dev", { stream: morganStream }));
} else {
  app.use(morgan("dev"));
}

app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(compression());
app.use(nocache()); // Prevent caching
app.use(hpp());
app.use(limiter);
logger.info("Rate limiting middleware applied");
app.use(speedLimiter);
logger.info("Speed limiting middleware applied");

// Response Time Middleware
app.use(responseTime());
logger.info("Response time middleware applied");

// Timeout Middleware
app.use(timeout(env.SERVER_TIMEOUT)); // Set a 150-second timeout for all routes
logger.info("Timeout middleware applied"); // Log timeout middleware

// Permissions Policy
logger.info("Permissions policy applied"); // Log permissions policy setup
app.use((_, res, next) => {
  res.append("Permissions-Policy", "browsing-topics=()");
  next();
});

// Routes
app.use("/uploads", express.static(path.join(__dirname, "../uploads")));
logger.info("Uploads routes set up");

app.use("/logs", express.static(path.join(__dirname, "../logs")));
logger.info("Logs routes set up");

app.use("/api", apiRoutes);
logger.info("API routes set up");

// Swagger UI
app.use(openAPIRouter);
logger.info("Swagger UI routes set up");

// Custom Error Handler Middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  errorMiddleware(err, req, res, next);
});

// Catch 404 and forward to error handler
app.use((_: Request, res: Response) => {
  logger.warn("Route not found");
  res.status(404).send("Route not found");
});

export default app;


File: src/server.ts
--------------------------------------------------
Content of src/server.ts:
import app from "@/app";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";
import { checkRedis } from "@/entities/health/health.helper";
import { connectPrisma } from "@/config/prisma/prisma";
import { RedisClient } from "@/config/redis/redis";

const { PORT, NODE_ENV, BASE_URL, ALLOW_ORIGIN } = env;

/**
 * Function to check the connection status for Redis, and MongoDB.
 * Logs the success or failure of each connection check.
 */
async function checkConnections() {
  try {
    logger.info("Checking database connections...");
    await checkRedis();
    logger.info("Redis connections verified successfully.");
    await connectPrisma();
    logger.info("Prisma connections verified successfully.");
  } catch (error) {
    if (error instanceof Error) {
      logger.warn("MongoDB, or Redis connection failed", { error: error.message });
    } else {
      logger.warn("Unknown error occurred during connection checks");
    }

    // eslint-disable-next-line no-process-exit
    process.exit(1); // Exit the process if any connection check fails
  }
}

/**
 * Function to start the server and handle termination signals (SIGINT, SIGTERM).
 * Logs the server status on startup and graceful shutdown.
 */
checkConnections().then(() => {
  const server = app.listen(PORT, () =>
    logger.info(
      `Server running on PORT: ${PORT}, ==> ENV: ${NODE_ENV}, ==> API: ${BASE_URL}, ==> ALLOW_ORIGIN: ${ALLOW_ORIGIN}`,
    ),
  );

  // Graceful shutdown logic
  const onCloseSignal = async () => {
    logger.info("SIGTERM signal received. Closing server...");
    const redis = RedisClient.getInstance();

    // Close Prisma connection
    try {
      await redis.disconnect();
      logger.info("Prisma disconnected successfully.");
    } catch (err) {
      logger.error("Error disconnecting Prisma:", { err });
    }

    // Close Redis connection
    try {
      await redis.quit();
      logger.info("Redis disconnected successfully.");
    } catch (err) {
      logger.error("Error disconnecting Redis:", { err });
    }

    // Close Express server
    server.close(() => {
      logger.info("HTTP server closed.");
      // eslint-disable-next-line no-process-exit
      process.exit(); // Ensure the process exits after server closure
    });
  };

  process.on("SIGINT", onCloseSignal); // Gracefully handle SIGINT (Ctrl+C or control+C)
  process.on("SIGTERM", onCloseSignal); // Gracefully handle SIGTERM (from Docker, etc.)
});


File: src/generated/zod/index.ts
--------------------------------------------------
Content of src/generated/zod/index.ts:
import { z } from "zod";
import { Prisma } from "@prisma/client";

/////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////

// JSON
//------------------------------------------------------

export type NullableJsonInput =
  | Prisma.JsonValue
  | null
  | "JsonNull"
  | "DbNull"
  | Prisma.NullTypes.DbNull
  | Prisma.NullTypes.JsonNull;

export const transformJsonNull = (v?: NullableJsonInput) => {
  if (!v || v === "DbNull") {
    return Prisma.DbNull;
  }
  if (v === "JsonNull") {
    return Prisma.JsonNull;
  }
  return v;
};

export const JsonValueSchema: z.ZodType<Prisma.JsonValue> = z.lazy(() =>
  z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.literal(null),
    z.record(z.lazy(() => JsonValueSchema.optional())),
    z.array(z.lazy(() => JsonValueSchema)),
  ]),
);

export type JsonValueType = z.infer<typeof JsonValueSchema>;

export const NullableJsonValue = z
  .union([JsonValueSchema, z.literal("DbNull"), z.literal("JsonNull")])
  .nullable()
  .transform((v) => transformJsonNull(v));

export type NullableJsonValueType = z.infer<typeof NullableJsonValue>;

export const InputJsonValueSchema: z.ZodType<Prisma.InputJsonValue> = z.lazy(() =>
  z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.object({ toJSON: z.function(z.tuple([]), z.any()) }),
    z.record(z.lazy(() => z.union([InputJsonValueSchema, z.literal(null)]))),
    z.array(z.lazy(() => z.union([InputJsonValueSchema, z.literal(null)]))),
  ]),
);

export type InputJsonValueType = z.infer<typeof InputJsonValueSchema>;

/////////////////////////////////////////
// ENUMS
/////////////////////////////////////////

export const UserScalarFieldEnumSchema = z.enum([
  "id",
  "name",
  "email",
  "password",
  "resetToken",
  "createdAt",
  "updatedAt",
  "phoneNumber",
  "bio",
]);

export const FileScalarFieldEnumSchema = z.enum([
  "id",
  "createdAt",
  "updatedAt",
  "name",
  "path",
  "text",
  "tags",
  "views",
  "userId",
]);

export const ErrorLogsScalarFieldEnumSchema = z.enum([
  "id",
  "status",
  "message",
  "method",
  "url",
  "loggedUser",
  "name",
  "stack",
  "details",
  "createdAt",
  "updatedAt",
]);

export const SortOrderSchema = z.enum(["asc", "desc"]);

export const QueryModeSchema = z.enum(["default", "insensitive"]);
/////////////////////////////////////////
// MODELS
/////////////////////////////////////////

/////////////////////////////////////////
// USER SCHEMA
/////////////////////////////////////////

export const userSchema = z.object({
  id: z.string(),
  name: z.string().nullable(),
  email: z.string(),
  password: z.string().nullable(),
  resetToken: z.string().nullable(),
  createdAt: z.date().nullable(),
  updatedAt: z.date().nullable(),
  phoneNumber: z.string().nullable(),
  bio: z.string().nullable(),
});

export type user = z.infer<typeof userSchema>;

/////////////////////////////////////////
// FILE SCHEMA
/////////////////////////////////////////

export const fileSchema = z.object({
  id: z.string(),
  createdAt: z.date().nullable(),
  updatedAt: z.date().nullable(),
  name: z.string().nullable(),
  path: z.string().nullable(),
  text: z.string().nullable(),
  tags: z.string().nullable(),
  views: z.number().nullable(),
  userId: z.string().nullable(),
});

export type file = z.infer<typeof fileSchema>;

/////////////////////////////////////////
// ERROR LOGS SCHEMA
/////////////////////////////////////////

export const errorLogsSchema = z.object({
  id: z.string(),
  status: z.string().nullable(),
  message: z.string().nullable(),
  method: z.string().nullable(),
  url: z.string().nullable(),
  loggedUser: z.string().nullable(),
  name: z.string().nullable(),
  stack: z.string().nullable(),
  details: JsonValueSchema.nullable(),
  createdAt: z.date().nullable(),
  updatedAt: z.date().nullable(),
});

export type errorLogs = z.infer<typeof errorLogsSchema>;


File: src/types/pagination.ts
--------------------------------------------------
Content of src/types/pagination.ts:
export interface FilterCondition {
  $eq?: string | number;
  $regex?: string;
  $between?: [string | number, string | number];
  $gte?: number;
  $lte?: number;
  $isNull?: boolean;
  $isNotNull?: boolean;
}

export type Filter = Record<string, FilterCondition>;

export interface LogicalFilter {
  $and?: Filter[];
  $or?: Filter[];
}

export interface OrderBy {
  sort: string;
  order: "asc" | "desc";
}

export interface Paginate {
  page: number;
  perPage: number;
}

export interface QueryOptions {
  filter?: Filter;
  paginate?: Paginate;
  orderBy?: OrderBy[];
}

export interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  perPage: number;
}


File: src/types/request.ts
--------------------------------------------------
Content of src/types/request.ts:
import { Request } from "express";

export interface CustomRequest extends Request {
  loggedUser?: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  file?: any;
}


File: src/config/env.ts
--------------------------------------------------
Content of src/config/env.ts:
import dotenv from "dotenv";
import { z } from "zod";

dotenv.config();

const envSchema = z.object({
  NODE_ENV: z.enum(["development", "test", "production"]).default("development"),
  TZ: z.string().default("UTC"),
  BASE_URL: z.string().url(),
  BASE_URL_HTTPS: z.string().url().optional(),
  PORT: z.string().transform((val) => parseInt(val, 10)),
  SERVER_TIMEOUT: z.string().default("150s"),
  LOG_FILE_DURATION: z.string().default("3d"),
  ALLOW_ORIGIN: z.string(),
  APP_URL: z.string().url(),
  LOGS_DIRECTORY: z.string(),

  // Basic Auth Secrets
  JWT_SECRET: z.string(),
  JWT_SECRET_EXPIRATION: z.string().default("1d"),
  HASH: z.string().transform((val) => parseInt(val, 10)),
  GENERATED_PASSWORD_LENGTH: z.string().default("10"),

  // DB Configuration
  REDIS_URL: z.string(),
  MONGODB_URI: z.string().url(),

  ENABLE_WINSTON: z.enum(["0", "1"]).default("0"),
  LOGS_TYPE: z.enum(["mongodb", "directory"]).default("mongodb"),
  MONGODB_ERROR_COLLECTION_NAME: z.string(),

  // Mail sender
  MAILGUN_API_KEY: z.string().optional(),
  MAILGUN_DOMAIN: z.string().optional(),
  MAILGUN_SENDER_EMAIL: z.string().optional(),
  MAILGUN_NAME: z.string().optional(),
});

export const env = envSchema.parse(process.env);


File: src/config/redis/redis.ts
--------------------------------------------------
Content of src/config/redis/redis.ts:
import Redis from "ioredis";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";

class RedisClient {
  private static instance: Redis;

  static getInstance(): Redis {
    if (!RedisClient.instance) {
      RedisClient.instance = new Redis(env.REDIS_URL);
      RedisClient.instance.on("connect", () => logger.info("Redis connected"));
      RedisClient.instance.on("end", () => logger.info("Redis disconnected"));
    }
    return RedisClient.instance;
  }

  static async disconnect(): Promise<void> {
    if (RedisClient.instance) {
      await RedisClient.instance.quit();
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      RedisClient.instance = undefined as any;
    }
  }
}

export { RedisClient };


File: src/config/prisma/prisma.ts
--------------------------------------------------
Content of src/config/prisma/prisma.ts:
import { logger } from "@/common/winston/winston";
import { PrismaClient } from "@prisma/client";

const prisma = prismaInstance();

export const connectPrisma = async () => {
  try {
    await prisma.$connect();
  } catch (error) {
    logger.error("Error connecting to Prisma:", { error });
    throw new Error("Error connecting to Prisma");
  }
};


File: src/config/prisma/errors.prisma.ts
--------------------------------------------------
Content of src/config/prisma/errors.prisma.ts:
import { Prisma } from "@prisma/client";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const formatValidationError = (error: any): string => {
  const { message } = error;
  const match = message.match(/Unknown argument `(\w+)`. Did you mean `(\w+)`?/);

  const unknownArg = match?.[1] || "Unknown";
  const suggestedArg = match?.[2] || "Check schema";

  return `-> Prisma Validation Error:
    - Unknown argument: \`${unknownArg}\`
    - Suggested fix: Replace \`${unknownArg}\` with \`${suggestedArg}\`
    - Full Message: ${message}`;
};

const formatKnownRequestError = (error: Prisma.PrismaClientKnownRequestError): string => {
  switch (error.code) {
    case "P2002":
      return "-> Unique Constraint Violation: A record with this value already exists.";
    case "P2025":
      return "-> Record Not Found: The requested record does not exist.";
    default:
      return `-> Prisma Request Error (${error.code}): ${error.message}`;
  }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const formatPrismaError = (error: any): string => {
  if (error instanceof Prisma.PrismaClientValidationError) {
    return formatValidationError(error);
  } else if (error instanceof Prisma.PrismaClientKnownRequestError) {
    return formatKnownRequestError(error);
  } else if (error instanceof Prisma.PrismaClientUnknownRequestError) {
    return `-> Prisma Unknown Request Error: ${error.message}`;
  } else if (error instanceof Prisma.PrismaClientInitializationError) {
    return `-> Prisma Initialization Error: ${error.message}`;
  } else if (error instanceof Prisma.PrismaClientRustPanicError) {
    return `-> Prisma Rust Panic Error: ${error.message}`;
  }
  return `-> Unknown Error: ${error.message || error}`;
};


File: src/template/forgot-password.hbs
--------------------------------------------------
Content of src/template/forgot-password.hbs:
<html
  xmlns:v="urn:schemas-microsoft-com:vml"
  xmlns:o="urn:schemas-microsoft-com:office:office"
  lang="en"
>

  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reset password requested</title>
    <style>
      .email-container * { font-family: 'Barlow'; font-size: 16px; } p { font-family: 'Barlow';
      font-style: normal; font-weight: 400; font-size: 18px; line-height: 24px; color: #181920; }
      .button-reset { max-width: 120px; text-decoration: none; cursor: pointer; font-size:
      16px;padding: 10px 20px; position: absolute; height: 44px; background: #36854C; border-radius:
      50px; border: none; }
    </style>
  </head>

  <body>
    <div class="email-container" style="padding-left: 10px; padding-top: 10px;">
      <p style="text-transform: capitalize;">Hi {{accountName}},</p>
      <p>We received a request to reset the password for your account.</p>
      <p>To reset your Password, click on the button below:</p>
      <a
        class="button-reset"
        href="{{URL}}"
        style="font-weight:700;color:#ffffff;max-width: 120px;justify-content: center;align-items: center;"
      >
        Reset Password
      </a>
      <br />
      <br />
      <p style="margin-bottom: 30px;">Or copy and paste the URL into your browser:</p>
      <a href="{{URL}}">{{URL}}</a>
      <br />
      <br />
      <p>If you did not request a password reset, please ignore this email or reply to let us know.</p>
      <p>This password reset link is only valid for 10 minutes.</p>
      <br />
      <p>Thank you,</p>
      <p>The Bulletproof Team</p>
    </div>
  </body>
</html>

File: src/template/create-template.ts
--------------------------------------------------
Content of src/template/create-template.ts:
import fs from "fs";
import path from "path";
import handlebars from "handlebars";
import juice from "juice";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function createTemplate(name: string, context: any) {
  if (!/^[a-zA-Z0-9-_]+$/.test(name)) {
    throw new Error("Invalid template name");
  }

  const templatePath = path.join(__dirname, `${name}.hbs`);

  if (!fs.existsSync(templatePath)) {
    throw new Error("Template not found");
  }

  const source = fs.readFileSync(templatePath, "utf8");
  const template = handlebars.compile(source);
  const html = template(context);
  return juice(html);
}


File: src/middlewares/auth-middleware.ts
--------------------------------------------------
Content of src/middlewares/auth-middleware.ts:
import { NextFunction, Response } from "express";
import { CustomRequest } from "@/types/request";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { verifyToken } from "@/common/jwt/jwt";
import { winstonLogger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const authMiddleware = (req: CustomRequest, _: Response, next: NextFunction): any => {
  const token = req.headers.authorization?.split(" ")[1];
  if (!token) {
    throw createHttpError(StatusCodes.UNAUTHORIZED, "Unauthorized", {
      resource: "Auth Middleware",
    });
  }

  const verify = verifyToken(token);
  req.loggedUser = verify.email || verify.type;
  winstonLogger.defaultMeta = { loggedUser: verify.email || verify.type };
  next();
};


File: src/middlewares/error-middleware.ts
--------------------------------------------------
Content of src/middlewares/error-middleware.ts:
import { NextFunction, Response } from "express";
import { HttpError } from "http-errors";
import { StatusCodes } from "http-status-codes";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import { PrismaClient } from "@prisma/client";

const prisma = prismaInstance();

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const findDeep = (obj: any, keys: string[]): any => {
  if (!obj || typeof obj !== "object") {
    return null;
  }
  for (const key of keys) {
    if (key in obj) {
      return obj[key];
    }
  }
  for (const value of Object.values(obj)) {
    const found = findDeep(value, keys);
    if (found) {
      return found;
    }
  }
  return null;
};

/**
 * Error middleware for catching and logging errors.
 *
 * Params:
 * - err: The error object (could be a HttpError or general error).
 * - req: The request object (with optional user data).
 * - res: The response object.
 * - _: The NextFunction (unused in this case).
 *
 * Response:
 * - Responds with the appropriate status code and error message in the response.
 * - If not in production, detailed error info is included (method, URL, stack trace).
 */
export const errorMiddleware = (
  err: Error | HttpError,
  req: CustomRequest,
  res: Response,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _: NextFunction,
): Response => {
  const { message, ...details } = err;
  const isHttpError = err instanceof HttpError;

  const statusCode = isHttpError
    ? err.status || StatusCodes.INTERNAL_SERVER_ERROR
    : StatusCodes.INTERNAL_SERVER_ERROR;

  const appName = isHttpError ? err.name : "AppError";

  const loggedUser = req.loggedUser || "Unknown User";
  const { method } = req;
  const url = req.originalUrl;

  const stack = err.stack || "";

  // Extract email or id using the helper function
  const email = findDeep(req.body, ["email"]);
  const id = findDeep(req.body, ["id"]);

  // Extract common properties
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { code, meta, name, response }: any = details;

  const transformDetails = {
    code,
    meta: { ...meta },
    data: { ...response?.data },
    status: response?.status,
    statusText: response?.statusText,
    name,
    email,
    id,
  };

  const errorPayload = {
    status: statusCode,
    message: message.trim(),
    method,
    url,
    loggedUser,
    name: appName,
    details: transformDetails,
    stack,
  };

  logger.error(errorPayload.message, errorPayload);

  if (env.ENABLE_WINSTON !== "1") {
    const errorLogs = {
      level: "error",
      message,
      metadata: errorPayload,
    };

    prisma.errorLogs
      .create({
        data: errorLogs,
      })
      .then(() => logger.info("Error logs saved successfully"))
      .catch((error) => logger.error("Error saving error logs", error));
  }

  const responsePayload = {
    status: statusCode,
    message: message.trim(),
    ...(env.NODE_ENV !== "production" && {
      method,
      url,
      loggedUser,
      name,
      details: transformDetails,
      stack,
    }),
  };

  return res.status(statusCode).json(responsePayload);
};


File: src/middlewares/index.ts
--------------------------------------------------
Content of src/middlewares/index.ts:
export { cors } from "@/middlewares/cors";
export { authMiddleware } from "@/middlewares/auth-middleware";
export { errorMiddleware } from "@/middlewares/error-middleware";
export { zodValidation } from "@/middlewares/zod-validation";


File: src/middlewares/cors.ts
--------------------------------------------------
Content of src/middlewares/cors.ts:
import corsLibrary from "cors";
import { StatusCodes } from "http-status-codes";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";

const allowedOrigins = (env.ALLOW_ORIGIN || "").split(",");

/**
 * CORS configuration to check allowed origins and set the appropriate headers
 *
 * Params:
 * - origin (string | undefined): Origin of the request, or undefined if not present.
 * - callback (function): Callback to confirm if origin is allowed or not.
 *
 * Response:
 * - Calls the callback with null and true if origin is allowed, otherwise calls callback with an error.
 */
export const config = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  origin: (origin: string | undefined, callback: any) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      logger.warn("Origin not allowed by CORS", { origin });

      callback(new Error("Not allowed by CORS"));
    }
  },
  optionsSuccessStatus: StatusCodes.OK,
  methods: "GET,HEAD,OPTIONS,PUT,POST,DELETE",
  credentials: true,
  exposedHeaders: ["Content-Type", "set-cookie"],
  options: {
    "Access-Control-Allow-Origin": env.ALLOW_ORIGIN || "*",
    "Access-Control-Allow-Headers": "Origin, X-Requested-With, Content-Type, Accept",
    "Access-Control-Allow-Methods": "GET,HEAD,OPTIONS,PUT,POST,DELETE",
  },
};

// Initialize the CORS middleware with the configured settings
export const cors = corsLibrary(config);

export default { cors, config };


File: src/middlewares/zod-validation.ts
--------------------------------------------------
Content of src/middlewares/zod-validation.ts:
import { NextFunction, Request, Response } from "express";
import { StatusCodes } from "http-status-codes";
import { ZodError, ZodTypeAny } from "zod";
import { logger } from "@/common/winston/winston";
import { createResponse } from "@/utils/create-response";

export const zodValidation =
  (zSchema: ZodTypeAny) =>
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async (req: Request, res: Response, next: NextFunction): Promise<any> => {
    try {
      const data = zSchema.parse(req.body);
      if (data) {
        req.body = data;
        next();
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      const errorMessage = `Validation Error: ${(error as ZodError).errors.map((e) => e.message).join(", ")}`;
      logger.warn(errorMessage, error);
      return res.status(StatusCodes.BAD_REQUEST).json(
        createResponse({
          req,
          data: error,
          message: errorMessage,
          status: StatusCodes.BAD_REQUEST,
        }),
      );
    }
  };


File: src/utils/create-response.ts
--------------------------------------------------
Content of src/utils/create-response.ts:
import { Request } from "express";
import { StatusCodes, ReasonPhrases } from "http-status-codes";

export const createResponse = ({
  req,
  data,
  message = ReasonPhrases.OK,
  status = StatusCodes.OK,
  success = true,
}: {
  req?: Request;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  data: any;
  message?: string;
  status?: number;
  success?: boolean;
}) => {
  if (req) {
    return {
      success,
      statusCode: status,
      message,
      method: req.method,
      url: req.originalUrl,
      data,
    };
  }
  return {
    success,
    statusCode: status,
    message,
    data,
  };
};


File: src/utils/utils.ts
--------------------------------------------------
Content of src/utils/utils.ts:
import { env } from "@/config/env";

export const generatePassword = (): string => {
  const getRandomChar = (characters: string): string =>
    characters[Math.floor(Math.random() * characters.length)];

  const categories = [
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ", // Uppercase letters
    "abcdefghijklmnopqrstuvwxyz", // Lowercase letters
    "0123456789", // Digits
    "!@#$%^&*()_-+=<>?/", // Special characters
  ];

  const password = categories.map(getRandomChar).join("");

  const remainingLength = Number(env.GENERATED_PASSWORD_LENGTH || 10) - password.length;
  const allCharacters = categories.join("");
  const randomChars = Array.from({ length: remainingLength }, () => getRandomChar(allCharacters));

  console.log(`Generated Password ==> ${password + randomChars.join("")}`);
  return password + randomChars.join("");
};

export const extractDomainFromEmailAddress = (email: string): string | null => {
  const match = email.match(/@([\w.-]+)/);
  if (!match) {
    return null;
  }

  return match[1].toLowerCase();
};


File: src/utils/csv-to-json.ts
--------------------------------------------------
Content of src/utils/csv-to-json.ts:
import * as fs from "fs";
import csv from "csv-parser";
import { Readable } from "stream";
import _ from "lodash";
import { hash } from "bcrypt";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const transformData = async (value: string, key?: string): Promise<any> => {
  if (key?.toLowerCase() === "password") {
    try {
      return await hash(value, env.HASH!);
    } catch (error) {
      logger.info(`Error hashing password: ${error}`);
      throw new Error(`Error hashing password: ${error}`);
    }
  }
  if (value === "NULL") {
    return null;
  }
  if (value === "FALSE") {
    return false;
  }
  if (value === "TRUE") {
    return true;
  }
  if (value === "UNDEFINED") {
    return undefined;
  }
  return value;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const sanitizeEntry = ([key, value]: [string, any]): [string, any] => {
  const sanitizedKey = _.trim(_.toLower(key.replace(/\s+/g, "")));
  const sanitizedValue = _.trim(value);
  return [sanitizedKey, sanitizedValue];
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const csvToJson = (filePath: string): Promise<any[]> => {
  return new Promise((resolve, reject) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result: any[] = [];
    const stream = fs.createReadStream(filePath);

    stream
      .pipe(csv())
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      .on("data", (row: Record<string, any>) => {
        result.push(
          Object.entries(row).reduce(
            (acc, entry) => {
              const [sanitizedKey, sanitizedValue] = sanitizeEntry(entry);
              acc[sanitizedKey] = transformData(sanitizedValue, sanitizedKey); // Collect promises
              return acc;
            },
            {
              // Add default fields here
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
            } as Record<string, any>,
          ),
        );
      })
      .on("end", async () => {
        try {
          // Wait for all promises to resolve
          const resolvedResults = await Promise.all(
            result.map(async (row) => {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const resolvedRow: Record<string, any> = {};
              for (const [key, value] of Object.entries(row)) {
                // eslint-disable-next-line no-await-in-loop
                resolvedRow[key] = await value;
              }
              return resolvedRow;
            }),
          );
          resolve(resolvedResults);
        } catch (err) {
          reject(err);
        } finally {
          fs.unlinkSync(filePath);
        }
      })
      .on("error", (error) => {
        reject(error);
        fs.unlinkSync(filePath);
      });
  });
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const csvBufferToJson = (buffer: string): Promise<any[]> => {
  return new Promise((resolve, reject) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result: any[] = [];
    const stream = Readable.from(buffer.toString());

    stream
      .pipe(csv())
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      .on("data", (row: Record<string, any>) => {
        result.push(
          Object.entries(row).reduce(
            (acc, entry) => {
              const [sanitizedKey, sanitizedValue] = sanitizeEntry(entry);
              acc[sanitizedKey] = transformData(sanitizedValue, sanitizedKey); // Collect promises
              return acc;
            },
            {
              // Add default fields here
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
            } as Record<string, any>,
          ),
        );
      })
      .on("end", async () => {
        try {
          // Wait for all promises to resolve
          const resolvedResults = await Promise.all(
            result.map(async (row) => {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const resolvedRow: Record<string, any> = {};
              for (const [key, value] of Object.entries(row)) {
                // eslint-disable-next-line no-await-in-loop
                resolvedRow[key] = await value;
              }
              return resolvedRow;
            }),
          );
          resolve(resolvedResults);
        } catch (err) {
          reject(err);
        }
      })
      .on("error", (err) => reject(err));
  });
};


File: src/schemas/query-examples.txt
--------------------------------------------------
Content of src/schemas/query-examples.txt:
1. Simple Equality Filter
{
  "filter": {
    "data.number": { "$eq": "12345" }
  },
  "paginate": {
    "page": 1,
      "perPage": 10
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" }
  ]
}

2. Case-Insensitive Text Search
{
  "filter": {
    "data.email": { "$regex": "test" }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.email", "order": "desc" }
  ]
}

3. Range Filter
json
{
  "filter": {
    "data.age": { "$between": [25, 35] }
  },
  "paginate": {
    "page": 2,
    "perPage": 20
  },
  "orderBy": [
    { "sort": "data.age", "order": "asc" }
  ]
}

4. Null and Not Null Filters
{
  "filter": {
    "data.address": { "$isNull": true }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.id", "order": "asc" }
  ]
}
{
  "filter": {
    "data.phone": { "$isNotNull": true }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.phone", "order": "asc" }
  ]
}

5. Combining $or and $and
{
  "filter": {
    "$or": [
      {
        "$and": [
          { "data.number": { "$eq": "12345" } },
          { "data.email": { "$regex": "test" } }
        ]
      },
      {
        "data.age": { "$gte": 30 }
      }
    ]
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" }
  ]
}

6. Using $and with Multiple Conditions
{
  "filter": {
    "$and": [
      { "data.status": { "$eq": "active" } },
      { "data.created_at": { "$between": ["2024-01-01", "2024-12-31"] } }
    ]
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.created_at", "order": "desc" }
  ]
}

7. $or Condition with Multiple Filters
{
  "filter": {
    "$or": [
      { "data.name": { "$regex": "john" } },
      { "data.email": { "$regex": "example" } },
      { "data.age": { "$lt": 30 } }
    ]
  },
  "paginate": {
    "page": 3,
    "perPage": 15
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" },
    { "sort": "data.age", "order": "desc" }
  ]
}

8. Filter with Multiple $and and $or Combinations
{
  "filter": {
    "$and": [
      {
        "$or": [
          { "data.city": { "$eq": "New York" } },
          { "data.city": { "$eq": "Los Angeles" } }
        ]
      },
      { "data.status": { "$eq": "verified" } },
      {
        "$or": [
          { "data.age": { "$gte": 25 } },
          { "data.email": { "$regex": "test" } }
        ]
      }
    ]
  },
  "paginate": {
    "page": 2,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.city", "order": "asc" },
    { "sort": "data.age", "order": "desc" }
  ]
}

9. Sorting by Multiple Columns
{
  "filter": {
    "data.status": { "$eq": "active" }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" },
    { "sort": "data.created_at", "order": "desc" }
  ]
}

10. Combining All Features
{
  "filter": {
    "$and": [
      { "data.status": { "$eq": "active" } },
      {
        "$or": [
          { "data.number": { "$eq": "12345" } },
          { "data.email": { "$regex": "test" } }
        ]
      },
      { "data.age": { "$between": [20, 30] } },
      { "data.address": { "$isNotNull": true } }
    ]
  },
  "paginate": {
    "page": 4,
    "perPage": 20
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" },
    { "sort": "data.age", "order": "desc" },
    { "sort": "data.created_at", "order": "asc" }
  ]
}

File: src/schemas/find-by-query.ts
--------------------------------------------------
Content of src/schemas/find-by-query.ts:
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { z } from "zod";

extendZodWithOpenApi(z);

// See query examples in query-examples.txt

const orderBySchema = z.object({
  sort: z.string().default("id"),
  order: z.enum(["asc", "desc"]),
});

const paginateSchema = z.object({
  page: z.number().min(1).default(1),
  perPage: z.number().min(1).default(10),
});

export const findByQuerySchema = z.object({
  filter: z.object({}),
  paginate: paginateSchema.optional(),
  orderBy: z.array(orderBySchema).optional(),
});

export interface FindByQueryResult<T> {
  data: T[];
  total: number;
  page: number;
  perPage: number;
  totalPages: number;
}

export interface ImportResult<T> {
  createdEntities: T[];
  createdCount: number;
  skippedCount: number;
}

export type FindByQueryDto = z.infer<typeof findByQuerySchema>;


File: src/schemas/import-file.ts
--------------------------------------------------
Content of src/schemas/import-file.ts:
import { z } from "zod";

export const importFileSchema = z.object({
  file: z
    .any()
    .openapi({
      type: "string",
      format: "binary",
    })
    .describe("The file to upload"),
});


File: src/common/jwt/jwt.ts
--------------------------------------------------
Content of src/common/jwt/jwt.ts:
import { sign, verify } from "jsonwebtoken";
import { env } from "@/config/env";
import { StatusCodes } from "http-status-codes";
import createHttpError from "http-errors";

export const generateToken = (payload: object): string => {
  // @ts-expect-error - The payload is an object
  return sign(payload, env.JWT_SECRET, { expiresIn: env.JWT_SECRET_EXPIRATION });
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const verifyToken = (token: string): any => {
  try {
    return verify(token, env.JWT_SECRET);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  } catch (error) {
    throw createHttpError(StatusCodes.FORBIDDEN, "Invalid or expired token", {
      resource: "Auth Middleware",
    });
  }
};


File: src/common/swagger/swagger.router.ts
--------------------------------------------------
Content of src/common/swagger/swagger.router.ts:
import express, { type Request, type Response, type Router } from "express";
import { generateOpenAPIDocument } from "@/common/swagger/swagger-document-generator";
import swaggerUi from "swagger-ui-express";
import { env } from "@/config/env";

export const openAPIRouter: Router = express.Router();
const openAPIDocument = generateOpenAPIDocument();

if (!["testing", "production"].includes(env.NODE_ENV!)) {
  openAPIRouter.get("/docs/swagger.json", (_req: Request, res: Response) => {
    res.setHeader("Content-Type", "application/json");
    res.send(openAPIDocument);
  });

  openAPIRouter.use("/docs", swaggerUi.serve, swaggerUi.setup(openAPIDocument));
}


File: src/common/swagger/swagger-response-builder.ts
--------------------------------------------------
Content of src/common/swagger/swagger-response-builder.ts:
import { ServiceResponseSchema } from "@/common/swagger/swagger-response";
import { StatusCodes } from "http-status-codes";
import type { z } from "zod";

export function createApiResponse(
  schema: z.ZodTypeAny,
  description: string,
  statusCode = StatusCodes.OK,
) {
  return {
    [statusCode]: {
      description,
      content: {
        "application/json": {
          schema: ServiceResponseSchema(schema),
        },
      },
    },
  };
}

// Use if you want multiple responses for a single endpoint

// Import { ResponseConfig } from '@asteasolutions/zod-to-openapi';
// Import { ApiResponseConfig } from '@common/models/openAPIResponseConfig';
// Export type ApiResponseConfig = {
//   Schema: z.ZodTypeAny;
//   Description: string;
//   StatusCode: StatusCodes;
// };
// Export function createApiResponses(configs: ApiResponseConfig[]) {
//   Const responses: { [key: string]: ResponseConfig } = {};
//   Configs.forEach(({ schema, description, statusCode }) => {
//     Responses[statusCode] = {
//       Description,
//       Content: {
//         'application/json': {
//           Schema: ServiceResponseSchema(schema),
//         },
//       },
//     };
//   });
//   Return responses;
// }


File: src/common/swagger/swagger-response.ts
--------------------------------------------------
Content of src/common/swagger/swagger-response.ts:
import { StatusCodes } from "http-status-codes";
import { z } from "zod";

export class ServiceResponse<T = null> {
  readonly success: boolean;
  readonly message: string;
  readonly data: T;
  readonly statusCode: number;

  private constructor(success: boolean, message: string, data: T, statusCode: number) {
    this.success = success;
    this.message = message;
    this.data = data;
    this.statusCode = statusCode;
  }

  // eslint-disable-next-line no-shadow
  static success<T>(message: string, data: T, statusCode: number = StatusCodes.OK) {
    return new ServiceResponse(true, message, data, statusCode);
  }

  // eslint-disable-next-line no-shadow
  static failure<T>(message: string, data: T, statusCode: number = StatusCodes.BAD_REQUEST) {
    return new ServiceResponse(false, message, data, statusCode);
  }
}

export const ServiceResponseSchema = <T extends z.ZodTypeAny>(dataSchema: T) =>
  z.object({
    success: z.boolean(),
    statusCode: z.number(),
    message: z.string(),
    data: dataSchema.optional(),
  });


File: src/common/swagger/swagger-document-generator.ts
--------------------------------------------------
Content of src/common/swagger/swagger-document-generator.ts:
import { OpenAPIRegistry, OpenApiGeneratorV3 } from "@asteasolutions/zod-to-openapi";
import { env } from "@/config/env";
import { healthRegistry } from "@/entities/health/health.route";
import { authRegistry } from "@/entities/auth/auth.route";
import { userRegistry } from "@/entities/user/user.route";
import { fileRegistry } from "@/entities/file/file.route";

export function generateOpenAPIDocument() {
  const registry = new OpenAPIRegistry([healthRegistry, authRegistry, userRegistry, fileRegistry]);

  registry.registerComponent("securitySchemes", "bearerAuth", {
    type: "http",
    scheme: "bearer",
    bearerFormat: "JWT",
  });

  const generator = new OpenApiGeneratorV3(registry.definitions);

  return generator.generateDocument({
    openapi: "3.1.0",
    info: {
      version: "1.0.0",
      title: "Swagger API",
      description:
        "This is a simple CRUD API application made with Express and documented with Swagger",
      termsOfService: "http://swagger.io/terms/",
    },
    externalDocs: {
      description: "View the raw OpenAPI Specification in JSON format",
      url: "/swagger.json",
    },
    servers: [
      {
        url: `${env.BASE_URL}/api`,
        description: "http protocol",
      },
      ...(env.BASE_URL_HTTPS
        ? [
            {
              url: `${env.BASE_URL_HTTPS}/api`,
              description: "https protocol",
            },
          ]
        : []),
    ],
    security: [
      {
        bearerAuth: [],
      },
    ],
  });
}


File: src/common/multer/multer.ts
--------------------------------------------------
Content of src/common/multer/multer.ts:
import { Request } from "express";
import multer from "multer";
import path from "path";
import fs from "fs";

//====================================================================================================

const storage = multer.memoryStorage();

const fileFilter = (_: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ["image/jpeg", "image/png", "video/mp4", "video/mkv"];

  if (!allowedTypes.includes(file.mimetype)) {
    return cb(
      new Error("Invalid file type. Only images (JPEG, PNG) and videos (MP4, MKV) are allowed."),
    );
  }

  cb(null, true);
};

const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024,
  },
});

export const uploadMiddleware = upload.single("file");

//====================================================================================================

const importStorage = multer.diskStorage({
  destination: (_, __, cb) => {
    const uploadDir = "./uploads";
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir);
    }
    cb(null, uploadDir);
  },
  filename: (_, file, cb) => {
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;
    cb(null, `${file.fieldname}-${uniqueSuffix}${path.extname(file.originalname)}`);
  },
});

const importFileFilter = (_: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ["text/csv"];

  if (!allowedTypes.includes(file.mimetype)) {
    return cb(new Error("Invalid file type. Only CSV file is allowed."));
  }

  cb(null, true);
};

const importUpload = multer({
  storage: importStorage,
  fileFilter: importFileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024,
  },
});

export const uploadImportMiddleware = importUpload.single("file");


File: src/common/multer/save-file-to-disk.ts
--------------------------------------------------
Content of src/common/multer/save-file-to-disk.ts:
import path from "path";
import fs from "fs";
import { logger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const saveFileToDisk = async (file: any) => {
  try {
    const fileBuffer = file.buffer;

    const uploadDir = "./uploads";
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;
    const fileName = `${file.fieldname}-${uniqueSuffix}${path.extname(file.originalname)}`;
    const filePath = path.join(uploadDir, fileName);

    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir);
    }

    fs.writeFile(filePath, fileBuffer, (err) => {
      if (err) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        logger.warn("Error saving file to disk:", err as any);
        throw new Error("Failed to save file.");
      }

      logger.info(`File saved to: ${filePath}`);
    });
    return { name: fileName, path: filePath };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    logger.warn("Error saving file:", error);
    throw new Error("Failed to save file.");
  }
};


File: src/common/multer/update-file-to-disk.ts
--------------------------------------------------
Content of src/common/multer/update-file-to-disk.ts:
import fs from "fs";
import path from "path";
import { logger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const updateImageToDisk = async (fileName: string, file: any) => {
  try {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let response: any;
    const uploadDir = "./uploads";

    const newFilePath = path.join(uploadDir, fileName);
    const tempFilePath = path.join(uploadDir, `${fileName}_temp${path.extname(file.originalname)}`);

    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir);
    }

    fs.writeFile(tempFilePath, file.buffer, (err) => {
      if (err) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        logger.warn("Error saving file to disk:", err as any);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        throw new Error(err as any);
      }

      response = fs.rename(tempFilePath, newFilePath, (renameErr) => {
        if (renameErr) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          logger.warn("Error replacing file:", renameErr as any);

          return false;
        }

        logger.info(`Image updated successfully: ${newFilePath}`);
        // Was removed from the response
        return { fileName, filePath: newFilePath };
      });
    });
    // Added return statement
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    logger.warn("Error updating image:", error);
    throw new Error(error);
  }
};


File: src/common/multer/delete-file-from-disk.ts
--------------------------------------------------
Content of src/common/multer/delete-file-from-disk.ts:
import fs from "fs";
import path from "path";
import { logger } from "@/common/winston/winston";

export const deleteFileFromDisk = async (fileName: string) => {
  try {
    const uploadDir = "./uploads";
    const filePath = path.join(uploadDir, fileName);

    if (!fs.existsSync(filePath)) {
      throw new Error("File not found.");
    }

    fs.unlink(filePath, (err) => {
      if (err) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        logger.warn("Error deleting file:", err as any);
        throw new Error("Failed to delete the file.");
      }

      logger.info(`File deleted successfully: ${filePath}`);
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    logger.warn("Error deleting file:", error);
    throw new Error("Failed to delete the file.");
  }
};


File: src/common/mail-sender/mail-sender.ts
--------------------------------------------------
Content of src/common/mail-sender/mail-sender.ts:
import { env } from "@/config/env";
import formData from "form-data";
import Mailgun from "mailgun.js";

const mailgun = new Mailgun(formData);

const options = {
  auth: {
    api_key: env.MAILGUN_API_KEY as string,
    domain: env.MAILGUN_DOMAIN as string,
  },
};

const mg = mailgun.client({ username: "api", key: options.auth.api_key }).messages;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const sendMail = async (mail: any) => {
  try {
    return await mg.create(options.auth.domain, mail);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    throw new Error(error);
  }
};


File: src/common/base/base.repository.ts
--------------------------------------------------
Content of src/common/base/base.repository.ts:
import { FindByQueryDto, FindByQueryResult, ImportResult } from "@/schemas/find-by-query";
import { logger } from "@/common/winston/winston";
import { formatPrismaError } from "@/config/prisma/errors.prisma";

export class BaseRepository<T, TCreateDto, TUpdateDto> {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private model: any;
  private collectionName: string;
  private ignoreFields: Record<string, boolean>;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string, ignoreFields: Record<string, boolean> = {}) {
    this.model = model;
    this.collectionName = collectionName;
    this.ignoreFields = ignoreFields;
  }

  /**
   * Fetches all entities from the collection.
   * @returns Array of entities
   */
  getAll = async (): Promise<T[]> => {
    try {
      logger.info(`[${this.collectionName} Repository] Fetching all from ${this.collectionName}`);
      const getAll = await this.model.findMany({ omit: this.ignoreFields });
      return getAll;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error fetching all from ${this.collectionName}`,
        {
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Fetches an entity by ID.
   * @param id - Entity's unique identifier
   * @returns Entity data or null if not found
   */
  getById = async (id: string): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Fetching ${this.collectionName} with id: ${id}`,
      );
      return await this.model.findUnique({ where: { id }, omit: this.ignoreFields });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error fetching ${this.collectionName} by id`,
        {
          id,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Fetches a entity or entities by their userId.
   * @param id - entity's unique identifier
   * @returns entity data or null if not found
   */
  getByUser = async (userId: string): Promise<T | T[] | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Fetching ${this.collectionName} with userId: ${userId}`,
      );
      return await this.model.findMany({ where: { userId }, omit: this.ignoreFields });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error fetching ${this.collectionName} by userId`,
        {
          userId,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Fetches a entity by their email.
   * @param email - entity's email
   * @returns entity data or null if not found
   */
  getByEmail = async (email: string): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Fetching ${this.collectionName} with email: ${email}`,
      );
      return await this.model.findFirst({ where: { email } });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error fetching ${this.collectionName} by email`,
        {
          email,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Fetches a document based on a specified field and its value.
   * @param field - The field name to search by.
   * @param value - The value to match for the specified field.
   * @returns The matched document or null if not found.
   */
  getByField = async (field: string, value: string | number): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Fetching ${this.collectionName} where ${field}: ${value}`,
      );
      return await this.model.findMany({ where: { [field]: value }, omit: this.ignoreFields });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error fetching ${this.collectionName} by ${field}`,
        {
          field,
          value,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Finds entities with pagination.
   * @param options - Query options
   * @returns Paginated data
   */
  findByQuery = async (options: FindByQueryDto): Promise<FindByQueryResult<T>> => {
    const { filter = {}, paginate = { page: 1, perPage: 10 }, orderBy = [] } = options;
    const { page, perPage } = paginate;

    try {
      const sortOptions = orderBy.reduce(
        (acc, { sort, order }) => {
          acc[sort] = order;
          return acc;
        },
        {} as Record<string, "asc" | "desc">,
      );

      const [data, total] = await Promise.all([
        this.model.findMany({
          where: filter,
          orderBy: sortOptions,
          skip: (page - 1) * perPage,
          take: perPage,
          omit: this.ignoreFields,
        }),
        this.model.count({ where: filter }),
      ]);

      return { data, total, page, perPage, totalPages: Math.ceil(total / perPage) };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`[${this.collectionName} Repository] Error querying ${this.collectionName}`, {
        options,
        error: error.message,
      });
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Creates a new entity.
   * @param createDto - Data for creating a new entity
   * @returns Created entity data
   */
  create = async (createDto: TCreateDto): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Creating document in ${this.collectionName}`,
      );
      const created = await this.model.create({ data: createDto });
      return created;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error creating entry in ${this.collectionName}`,
        {
          createDto,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Updates an existing entity.
   * @param id - Entity's unique identifier
   * @param updateDto - Data to update the entity
   * @returns Updated entity data
   */
  update = async (id: string, updateDto: TUpdateDto): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Updating ${this.collectionName} with id: ${id}`,
      );
      return await this.model.update({ where: { id }, data: updateDto });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`[${this.collectionName} Repository] Error updating ${this.collectionName}`, {
        id,
        updateDto,
        error: error.message,
      });
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Deletes an entity by id.
   * @param id - Entity's unique identifier
   * @returns Deleted entity data
   */
  delete = async (id: string): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Deleting ${this.collectionName} with id: ${id}`,
      );
      return await this.model.delete({ where: { id } });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`[${this.collectionName} Repository] Error deleting ${this.collectionName}`, {
        id,
        error: error.message,
      });
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Deletes multiple entities by their ids.
   * @param ids - List of entity ids to delete
   * @returns Deletion result
   */
  deleteMany = async (ids: string[]): Promise<{ deletedCount: number }> => {
    try {
      const result = await this.model.deleteMany({ where: { id: { in: ids } } });
      return { deletedCount: result.count };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error deleting multiple ${this.collectionName}`,
        {
          ids,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };

  /**
   * Imports multiple entity objects into the database.
   * Skips objects where email already exist in the database.
   * @param entities - Array of entity objects to be saved
   * @returns Object containing created entities, created count, and skipped count
   */
  import = async (entities: TCreateDto[]): Promise<ImportResult<T>> => {
    try {
      logger.info(
        `[${this.collectionName} Repository] Importing ${entities.length} documents into ${this.collectionName}`,
      );

      const uniqueEntities = [];
      const skippedEntities = [];
      let createdEntities = [];

      for (const entity of entities) {
        // eslint-disable-next-line no-await-in-loop
        const exists = await this.model.findFirst({
          where: {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            OR: [{ email: (entity as any).email }],
          },
        });

        if (exists) {
          skippedEntities.push(entity);
        } else {
          uniqueEntities.push(entity);
        }
      }
      if (uniqueEntities.length !== 0) {
        createdEntities = await this.model.createMany({
          data: uniqueEntities,
        });
      }

      logger.info(`[${this.collectionName} Repository] Import Summary:`, {
        createdEntities: uniqueEntities,
        createdCount: createdEntities.count ?? createdEntities.length,
        skippedCount: skippedEntities.length,
      });

      return {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        createdEntities: uniqueEntities as any,
        createdCount: createdEntities.count ?? createdEntities.length,
        skippedCount: skippedEntities.length,
      };

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(
        `[${this.collectionName} Repository] Error importing into ${this.collectionName}`,
        {
          totalEntities: entities.length,
          error: error.message,
        },
      );
      throw new Error(formatPrismaError(error));
    }
  };
}


File: src/common/base/base.services.ts
--------------------------------------------------
Content of src/common/base/base.services.ts:
import { BaseRepository } from "@/common/base/base.repository";
import { FindByQueryDto, FindByQueryResult, ImportResult } from "@/schemas/find-by-query";
import { logger } from "@/common/winston/winston";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { parseAsync } from "json2csv";

export class BaseService<T, TCreateDto, TUpdateDto> {
  private collectionName: string;
  protected baseRepository: BaseRepository<T, TCreateDto, TUpdateDto>;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string, ignoreFields?: Record<string, boolean>) {
    this.collectionName = collectionName;
    this.baseRepository = new BaseRepository<T, TCreateDto, TUpdateDto>(
      model,
      collectionName,
      ignoreFields,
    );
  }

  /**
   * Fetches all entities from the database.
   * @returns Array of entities
   */
  getAll = async (): Promise<T[]> => {
    try {
      logger.info(`[${this.collectionName} Service] Fetching all ${this.collectionName}`);
      const data = await this.baseRepository.getAll();
      return data;
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error fetching all ${this.collectionName}`, {
          error: error.message,
        });
        throw new Error(`Error fetching ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while fetching all ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName}`);
    }
  };

  /**
   * Fetches a entity by their id.
   * @param id - entity's unique identifier
   * @returns entity data
   */
  getById = async (id: string): Promise<T> => {
    try {
      logger.info(
        `[${this.collectionName} Service] Fetching ${this.collectionName} with id: ${id}`,
      );
      const data = await this.baseRepository.getById(id);

      if (!data) {
        logger.warn(
          `[${this.collectionName} Service] ${this.collectionName} with id ${id} not found`,
        );
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} not found`, {
          resource: this.collectionName,
        });
      }

      return data;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Service] Error fetching ${this.collectionName} by id`,
          {
            id,
            error: error.message,
          },
        );
        throw new Error(`Error fetching ${this.collectionName} by id: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while fetching ${this.collectionName} by id`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName} by id`);
    }
  };

  /**
   * Fetches a entity by their email.
   * @param email - entity's email
   * @returns entity data or false if not found
   */
  getByEmail = async (email: string): Promise<T | false> => {
    try {
      logger.info(
        `[${this.collectionName} Service] Fetching ${this.collectionName} with email: ${email}`,
      );
      const data = await this.baseRepository.getByEmail(email);

      if (!data) {
        logger.warn(
          `[${this.collectionName} Service] ${this.collectionName} with email ${email} not found`,
        );
        return false;
      }

      return data;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Service] Error fetching ${this.collectionName} by email`,
          {
            email,
            error: error.message,
          },
        );
        throw new Error(`Error fetching ${this.collectionName} by email: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while fetching ${this.collectionName} by email`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName} by email`);
    }
  };

  /**
   * Finds entities based on query parameters.
   * @param options - Query parameters like pagination, sorting, and filtering
   * @returns Paginated entity data
   */
  findByQuery = async (options: FindByQueryDto): Promise<FindByQueryResult<T>> => {
    try {
      logger.info(
        `[${this.collectionName} Service] Querying ${this.collectionName} with options: ${JSON.stringify(options)}`,
      );
      return await this.baseRepository.findByQuery(options);
    } catch (error) {
      logger.warn(`[${this.collectionName} Service] Error querying ${this.collectionName}`, {
        options,
        error: error instanceof Error ? error.message : "Unknown error",
      });
      throw new Error(`Error querying ${this.collectionName}`);
    }
  };

  /**
   * Creates a new entity.
   * @param createDto - Data for creating a new entity
   * @returns Created entity data
   */
  create = async (createDto: TCreateDto): Promise<T | null> => {
    try {
      logger.info(`[${this.collectionName} Service] Creating ${this.collectionName} ${createDto}`);
      return await this.baseRepository.create(createDto);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error creating ${this.collectionName}`, {
          createDto,
          error: error.message,
        });
        throw new Error(`Error creating ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while creating ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while creating ${this.collectionName}`);
    }
  };

  /**
   * Updates an existing entity.
   * @param id - entity's unique identifier
   * @param updateDto - Data to update the entity with
   * @returns Updated entity data
   */
  update = async (id: string, updateDto: TUpdateDto): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Service] Updating ${this.collectionName} with id: ${id}`,
      );
      return await this.baseRepository.update(id, updateDto);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error updating ${this.collectionName}`, {
          id,
          updateDto,
          error: error.message,
        });
        throw new Error(`Error updating ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while updating ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while updating ${this.collectionName}`);
    }
  };

  /**
   * Deletes a entity.
   * @param id - entity's unique identifier
   * @returns Deletion result
   */
  delete = async (id: string): Promise<T | null> => {
    try {
      logger.info(
        `[${this.collectionName} Service] Deleting ${this.collectionName} with id: ${id}`,
      );
      const data = await this.getById(id);

      if (!data) {
        logger.warn(
          `[${this.collectionName} Service] ${this.collectionName} with id ${id} does not exist!`,
        );
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: this.collectionName,
        });
      }

      return await this.baseRepository.delete(id);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error deleting ${this.collectionName}`, {
          id,
          error: error.message,
        });
        throw new Error(`Error deleting ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while deleting ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while deleting ${this.collectionName}`);
    }
  };

  /**
   * Deletes multiple entities by their ids.
   * @param ids - List of entity ids to delete
   * @returns Deletion result
   */
  deleteMany = async (ids: string[]): Promise<{ deletedCount: number }> => {
    if (!Array.isArray(ids) || ids.length === 0) {
      logger.warn(`[${this.collectionName} Service] Invalid array of ids for bulk delete`);
      throw new Error("Invalid array of ids");
    }

    const result = await this.baseRepository.deleteMany(ids);

    if (result.deletedCount === 0) {
      logger.warn(`[${this.collectionName} Service] No ${this.collectionName} found to delete`, {
        ids,
      });
      throw new Error(`No ${this.collectionName} found to delete`);
    }

    return result;
  };

  /**
   * Import entities.
   * @param importDto - Data for creating entities
   * @param accountId - account id for creating entities
   * @returns number of imported entities
   */
  import = async (importDto: TCreateDto[]): Promise<ImportResult<T>> => {
    try {
      logger.info(`[${this.collectionName} Service] Starting import ${this.collectionName}`);

      const imported = await this.baseRepository.import(importDto);

      logger.info(
        `[${this.collectionName} Service] ${imported.createdCount} completed, ${imported.skippedCount} skipped for ${this.collectionName}`,
      );

      return imported;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error creating ${this.collectionName}`, {
          importDto,
          error: error.message,
        });
        throw new Error(`Error creating ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while creating ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while creating ${this.collectionName}`);
    }
  };

  /**
   * Export entities from the database.
   * @returns csv of entities
   */
  export = async (): Promise<string> => {
    try {
      logger.info(`[${this.collectionName} Service] Fetching all ${this.collectionName}`);
      const data = await this.baseRepository.getAll();

      if (data.length === 0) {
        throw createHttpError(StatusCodes.NOT_FOUND, `No ${this.collectionName} found to export`);
      }

      const csv = await parseAsync(data);

      return csv;
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error fetching all ${this.collectionName}`, {
          error: error.message,
        });
        throw new Error(`Error fetching ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionName} Service] Unknown error occurred while fetching all ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName}`);
    }
  };
}


File: src/common/base/base.controller.ts
--------------------------------------------------
Content of src/common/base/base.controller.ts:
import { NextFunction, Response } from "express";
import { BaseService } from "@/common/base/base.services";
import { CustomRequest } from "@/types/request";
import { logger } from "@/common/winston/winston";
import { StatusCodes } from "http-status-codes";
import createHttpError from "http-errors";
import { csvBufferToJson, csvToJson } from "@/utils/csv-to-json";
import { createResponse } from "@/utils/create-response";

export class BaseController<T, TCreateDto, TUpdateDto> {
  public collectionName: string;
  protected baseService: BaseService<T, TCreateDto, TUpdateDto>;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string, ignoreFields?: Record<string, boolean>) {
    this.collectionName = collectionName;
    this.baseService = new BaseService<T, TCreateDto, TUpdateDto>(
      model,
      collectionName,
      ignoreFields,
    );
  }

  /**
   * Get all entities objects
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON list of entities
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getAll = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    try {
      logger.info(`[${this.collectionName} Controller] Fetching all ${this.collectionName}`, {
        loggedUser,
      });
      const data = await this.baseService.getAll();

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Controller] Error fetching all ${this.collectionName}`,
          {
            error: error.message,
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Get entity by ID
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON entity object
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getById = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { id } = req.params;
    try {
      logger.info(`[${this.collectionName} Controller] Fetching ${this.collectionName} by ID`, {
        id,
        loggedUser,
      });
      const data = await this.baseService.getById(id);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Controller] Error fetching ${this.collectionName} by ID`,
          {
            error: error.message,
            id,
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Get entity by email
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON entity object
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getByEmail = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { email } = req.params;
    try {
      logger.info(`[${this.collectionName} Controller] Fetching ${this.collectionName} by email`, {
        email,
        loggedUser,
      });
      const data = await this.baseService.getByEmail(email);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Controller] Error fetching ${this.collectionName} by email`,
          {
            error: error.message,
            email,
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Find entities by query (pagination, sorting, filtering)
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON result of the query
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  findByQuery = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { paginate, orderBy, filter } = req.body;
    try {
      const queryOptions = { paginate, orderBy, filter };
      logger.info(`[${this.collectionName} Controller] Finding ${this.collectionName} by query`, {
        queryOptions,
        loggedUser,
      });

      const data = await this.baseService.findByQuery(queryOptions);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Controller] Error finding ${this.collectionName} by query`,
          {
            error: error.message,
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Create a new entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON created entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  create = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const createDto = req.body;
    try {
      logger.info(`[${this.collectionName} Controller] Creating new ${this.collectionName}`, {
        createDto,
        loggedUser,
      });
      const created = await this.baseService.create(createDto);
      return res.json(createResponse({ data: created, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error creating ${this.collectionName}`, {
          error: error.message,
          createDto,
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Update an existing entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON updated entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  update = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { id } = req.params;
    const updateDto = req.body;
    try {
      logger.info(`[${this.collectionName} Controller] Updating ${this.collectionName}`, {
        id,
        updateDto,
        loggedUser,
      });
      const updated = await this.baseService.update(id, updateDto);
      return res.json(createResponse({ data: updated }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error updating ${this.collectionName}`, {
          error: error.message,
          id,
          updateDto,
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Delete a entity by ID
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON success message
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  delete = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { id } = req.params;
    try {
      logger.info(`[${this.collectionName} Controller] Deleting ${this.collectionName} by id`, {
        id,
        loggedUser,
      });
      const data = await this.baseService.delete(id);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error deleting ${this.collectionName}`, {
          error: error.message,
          id,
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Delete multiple entities
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON success message
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  deleteMany = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { ids } = req.body;
    try {
      if (!Array.isArray(ids) || ids.length === 0) {
        throw createHttpError(StatusCodes.BAD_REQUEST, "Invalid or empty array of ids", {
          resource: this.collectionName,
          loggedUser,
        });
      }

      logger.info(`[${this.collectionName} Controller] Deleting multiple ${this.collectionName}`, {
        ids,
        loggedUser,
      });
      const data = await this.baseService.deleteMany(ids);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error deleting ${this.collectionName}`, {
          error: error.message,
          ids,
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Import entities
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON created entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  import = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser, file } = req;
    if (!file) {
      return next(createHttpError(StatusCodes.BAD_REQUEST, "No file uploaded."));
    }
    try {
      logger.info(`[${this.collectionName} Controller] Importing new ${this.collectionName}`, {
        loggedUser,
      });
      let importEntries;

      if (file.buffer) {
        importEntries = await csvBufferToJson(file.buffer);
      } else {
        importEntries = await csvToJson(file.path);
      }

      const imported = await this.baseService.import(importEntries);

      return res.json(createResponse({ data: imported }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error creating ${this.collectionName}`, {
          error: error.message,
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Export entities
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON list of entities
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  export = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    try {
      logger.info(`[${this.collectionName} Controller] Exporting ${this.collectionName}`, {
        loggedUser,
      });
      const csv = await this.baseService.export();
      res.setHeader("Content-Type", "text/csv");
      res.attachment(`${this.collectionName}.csv`);
      res.status(StatusCodes.OK).send(csv);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error exporting ${this.collectionName}`, {
          error: error.message,
          loggedUser,
        });
      }
      next(error);
    }
  };
}


File: src/common/winston/winston.ts
--------------------------------------------------
Content of src/common/winston/winston.ts:
import "winston-daily-rotate-file";
import { createLogger, format, transports, Logger } from "winston";
import { StatusCodes } from "http-status-codes";
import { env } from "@/config/env";
import fs from "fs";
import colors from "colors/safe";
import "winston-mongodb";

const isWinstonEnabled = env.ENABLE_WINSTON === "1";
const logsDirectory = env.LOGS_DIRECTORY;
const logsType = env.LOGS_TYPE;
const timeZone = env.TZ;
const logsFileDuration = env.LOG_FILE_DURATION;
const mongodbURI = env.MONGODB_URI;

if (!fs.existsSync(logsDirectory) && isWinstonEnabled && logsType !== "mongodb") {
  fs.mkdirSync(logsDirectory);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const formatConsoleMetaData = (metadata: any) => {
  if (!metadata) {
    return "";
  }

  // Extract common properties
  const { code, message, meta, name, response, details, status } = metadata;

  // Use details as a fallback for missing properties in metadata
  const resolvedDetails = details || {};

  return {
    details: {
      code: code || resolvedDetails.code || null,
      message: message || resolvedDetails.message || null,
      meta: { ...(meta || resolvedDetails.meta || {}) },
      data: {
        ...(response?.data || resolvedDetails?.data || {}),
      },
      status: response?.status || resolvedDetails?.status || status || null,
      statusText: response?.statusText || resolvedDetails?.statusText || null,
      name: name || resolvedDetails.name || null,
    },
  };
};

// NestJS-like console log format
const consoleFormat = format.combine(
  format.colorize({ all: true }),
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  format.printf(({ level, message, timestamp, ...meta }: any) => {
    const metadata = meta && Object.keys(meta).length ? JSON.stringify(meta, null, 2) : "";
    return `[${colors.cyan(timestamp)} ${timeZone}] ${level}: ${meta.loggedUser ?? ""} ${message} ${metadata}`;
  }),
);

const fileFormat = format.combine(
  format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
  format.json(),
);

const createMongoTransport = () =>
  new transports.MongoDB({
    db: mongodbURI,
    dbName: env.NODE_ENV,
    collection: env.MONGODB_ERROR_COLLECTION_NAME,
    level: "error",
    format: format.combine(
      format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
      format.errors({ stack: true }),
      format.json(),
    ),
  });

const createDailyRotateTransport = (level: string) =>
  new transports.DailyRotateFile({
    filename: `${level}-%DATE%.log`,
    dirname: logsDirectory,
    datePattern: "YYYY-MM-DD",
    level,
    zippedArchive: true,
    maxSize: "20m",
    maxFiles: logsFileDuration,
    format: format.combine(
      // eslint-disable-next-line no-extra-parens
      format((info) => (info.level === level ? info : false))(),
      fileFormat,
    ),
  });

const logLevels = {
  levels: {
    error: 0,
    warn: 1,
    http: 2,
    info: 3,
    debug: 4,
  },
  colors: {
    error: "red",
    warn: "yellow",
    info: "green",
    http: "blue",
    debug: "magenta",
  },
};

const transportsList = [];
if (isWinstonEnabled) {
  transportsList.push(new transports.Console({ level: "info", format: consoleFormat }));
  if (logsType === "mongodb") {
    transportsList.push(createMongoTransport());
  } else {
    transportsList.push(createDailyRotateTransport("info"));
    transportsList.push(createDailyRotateTransport("error"));
  }
}

export const winstonLogger: Logger = createLogger({
  levels: logLevels.levels,
  format: format.combine(
    format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
    format.errors({ stack: true }),
    format.splat(),
    format.align(),
  ),
  transports: transportsList,
});

// Export logger functions with fallback to console logs if disabled
export const logger = {
  // eslint-disable-next-line no-extra-parens
  info: (message: string, metadata?: Record<string, unknown>) =>
    isWinstonEnabled
      ? winstonLogger.info(message, metadata)
      : console.log(colors.green(message), metadata ?? ""),
  // eslint-disable-next-line no-extra-parens
  debug: (message: string, metadata?: Record<string, unknown>) =>
    isWinstonEnabled
      ? winstonLogger.debug(message, metadata)
      : console.log(colors.magenta(message), metadata ?? ""),
  // eslint-disable-next-line no-extra-parens
  warn: (message: string, metadata?: Record<string, unknown>) =>
    isWinstonEnabled
      ? winstonLogger.warn(message, metadata)
      : console.log(colors.yellow(message), metadata ?? ""),
  // eslint-disable-next-line no-extra-parens
  http: (message: string, metadata?: Record<string, unknown>) =>
    isWinstonEnabled
      ? winstonLogger.http(message, metadata)
      : console.log(colors.blue(message), metadata ?? ""),
  // eslint-disable-next-line no-extra-parens
  error: (message: string, metadata?: Record<string, unknown>) =>
    isWinstonEnabled
      ? winstonLogger.error(message, metadata)
      : console.log(colors.red(message), formatConsoleMetaData(metadata) ?? ""),
};

export const morganStream = {
  write: (message: string) => {
    const statusCode = parseInt(message.split(" ")[2], 10);
    if (statusCode >= StatusCodes.BAD_REQUEST) {
      logger.warn(message.trim());
    } else {
      logger.http(message.trim());
    }
  },
};


File: src/routes/routes.ts
--------------------------------------------------
Content of src/routes/routes.ts:
import { Router } from "express";
import authRouter from "@/entities/auth/auth.route";
import userRouter from "@/entities/user/user.route";
import fileRouter from "@/entities/file/file.route";
import healthRouter from "@/entities/health/health.route";

export const apiRoutes = Router();

apiRoutes.use("/health", healthRouter);
apiRoutes.use("/auth", authRouter);
apiRoutes.use("/user", userRouter);
apiRoutes.use("/file", fileRouter);


File: src/entities/file/file.service.ts
--------------------------------------------------
Content of src/entities/file/file.service.ts:
import createHttpError from "http-errors";
import { logger } from "@/common/winston/winston";
import { BaseService } from "@/common/base/base.services";
import { UpdateFileDto, UploadFileDto } from "./file.dto";
import { file as File } from "@prisma/client";

export class FileService extends BaseService<File, UploadFileDto, UpdateFileDto> {
  private collectionNameService: string;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string, ignoreFields?: Record<string, boolean>) {
    super(model, collectionName, ignoreFields);
    this.collectionNameService = collectionName;
  }

  /**
   * Fetches a entity by their userId.
   * @param userId - entity's userId
   * @returns entity data or false if not found
   */
  getByUser = async (userId: string): Promise<File | File[] | false> => {
    try {
      logger.info(
        `[${this.collectionNameService} Service] Fetching ${this.collectionNameService} with userId: ${userId}`,
      );
      const data = await this.baseRepository.getByUser(userId);

      if (!data) {
        logger.warn(
          `[${this.collectionNameService} Service] ${this.collectionNameService} with userId ${userId} not found`,
        );
        return false;
      }

      return data;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionNameService} Service] Error fetching ${this.collectionNameService} by userId`,
          {
            userId,
            error: error.message,
          },
        );
        throw new Error(`Error fetching ${this.collectionNameService} by email: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionNameService} Service] Unknown error occurred while fetching ${this.collectionNameService} by email`,
      );
      throw new Error(
        `Unknown error occurred while fetching ${this.collectionNameService} by email`,
      );
    }
  };
}


File: src/entities/file/file.dto.ts
--------------------------------------------------
Content of src/entities/file/file.dto.ts:
import { fileSchema } from "@/generated/zod";
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { z } from "zod";

extendZodWithOpenApi(z);

const fileUploadSchema = {
  file: z
    .any()
    .openapi({
      type: "string",
      format: "binary",
    })
    .describe("The file to upload")
    .optional(),
  views: z
    .string()
    .refine((data) => !Number.isNaN(Number(data)), "ID must be a numeric value")
    .transform(Number)
    .refine((num) => num > 0, "ID must be a positive number"),
};

export const uploadFileSchema = fileSchema
  .omit({
    id: true,
    path: true,
    text: true,
    views: true,
    createdAt: true,
    updatedAt: true,
  })
  .extend(fileUploadSchema)
  .partial();

export const updateFileSchema = fileSchema
  .omit({
    id: true,
    path: true,
    text: true,
    views: true,
    createdAt: true,
    updatedAt: true,
  })
  .extend(fileUploadSchema)
  .partial();

export type UploadFileDto = z.infer<typeof uploadFileSchema>;
export type UpdateFileDto = z.infer<typeof updateFileSchema>;


File: src/entities/file/file.route.ts
--------------------------------------------------
Content of src/entities/file/file.route.ts:
import { Router } from "express";
import { uploadMiddleware } from "@/common/multer/multer";
import { FileController } from "@/entities/file/file.controller";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { updateFileSchema, uploadFileSchema } from "@/entities/file/file.dto";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import { z } from "zod";
import { authMiddleware, zodValidation } from "@/middlewares";
import { findByQuerySchema } from "@/schemas/find-by-query";
import { fileSchema } from "@/generated/zod";

const fileRouter = Router();
fileRouter.use(authMiddleware);

const TAG = "File";
const ROUTE = `/${TAG.toLowerCase()}`;

export const fileRegistry = new OpenAPIRegistry();
const fileController = new FileController();

fileRegistry.register(TAG, fileSchema);

fileRegistry.registerPath({
  method: "get",
  path: ROUTE,
  summary: `Get all ${TAG}`,
  tags: [TAG],
  responses: createApiResponse(z.array(fileSchema), "Success"),
});
fileRouter.get("/", fileController.getAll);

//====================================================================================================

fileRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  summary: `Get ${TAG} by id`,
  request: {
    params: z.object({ id: z.string() }),
  },
  responses: createApiResponse(fileSchema, "Success"),
});
fileRouter.get("/:id", fileController.getById);

//====================================================================================================

fileRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/user/{userId}`,
  tags: [TAG],
  summary: `Get ${TAG} by userId`,
  request: {
    params: z.object({ userId: z.string() }),
  },
  responses: createApiResponse(fileSchema, "Success"),
});
fileRouter.get("/user/:userId", fileController.getByUser);

//====================================================================================================

fileRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/find`,
  tags: [TAG],
  summary: `Find ${TAG} by query`,
  request: {
    body: {
      content: { "application/json": { schema: findByQuerySchema } },
    },
  },
  responses: createApiResponse(z.array(findByQuerySchema), "Success"),
});
fileRouter.post("/find", zodValidation(findByQuerySchema), fileController.findByQuery);

//====================================================================================================

fileRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/upload`,
  tags: [TAG],
  summary: `Upload ${TAG}`,
  request: {
    body: {
      content: { "multipart/form-data": { schema: uploadFileSchema } },
    },
  },
  responses: createApiResponse(uploadFileSchema, "File uploaded Successfully"),
});
fileRouter.post(
  "/upload",
  uploadMiddleware,
  zodValidation(uploadFileSchema),
  fileController.upload,
);

//====================================================================================================

fileRegistry.registerPath({
  method: "put",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  request: {
    params: z.object({ id: z.string() }),
    body: {
      content: { "multipart/form-data": { schema: updateFileSchema } },
    },
  },
  responses: createApiResponse(updateFileSchema, "File updated Successfully"),
});
fileRouter.put("/:id", uploadMiddleware, zodValidation(updateFileSchema), fileController.update);

//====================================================================================================

fileRegistry.registerPath({
  method: "delete",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  summary: `Delete ${TAG}`,
  request: {
    params: z.object({ id: z.string() }),
  },
  responses: createApiResponse(z.null(), `${TAG} Deleted Successfully`),
});
fileRouter.delete("/:id", fileController.delete);

export default fileRouter;


File: src/entities/file/file.controller.ts
--------------------------------------------------
Content of src/entities/file/file.controller.ts:
import { NextFunction, Response } from "express";
import { UpdateFileDto, UploadFileDto } from "@/entities/file/file.dto";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import { saveFileToDisk } from "@/common/multer/save-file-to-disk";
import { updateImageToDisk } from "@/common/multer/update-file-to-disk";
import { deleteFileFromDisk } from "@/common/multer/delete-file-from-disk";
import { BaseController } from "@/common/base/base.controller";
import { createResponse } from "@/utils/create-response";
import { StatusCodes } from "http-status-codes";
import { FileService } from "@/entities/file/file.service";
import { PrismaClient, file as File } from "@prisma/client";
import _ from "lodash";

const prisma = prismaInstance();
const IGNORE_FIELDS = {};

export class FileController extends BaseController<File, UploadFileDto, UpdateFileDto> {
  public collectionName: string;
  public fileService: FileService;

  constructor() {
    super(prisma.file, "File", IGNORE_FIELDS);
    this.collectionName = "File";
    this.fileService = new FileService(prisma.file, this.collectionName, IGNORE_FIELDS);
  }

  /**
   * Get entity by ID
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON entity object
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getByUser = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { userId } = req.params;
    const { loggedUser } = req;
    try {
      logger.info(`[${this.collectionName} Controller] Fetching ${this.collectionName} by userId`, {
        loggedUser,
        userId,
      });
      const data = await this.fileService.getByUser(userId);

      return res.json(createResponse({ data }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionName} Controller] Error fetching ${this.collectionName} by userId`,
          {
            error: error.message,
            loggedUser,
            userId,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Upload an entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON updated entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  upload = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    try {
      const { tags, userId, name, views } = req.body;

      const { path } = await saveFileToDisk(req.file);
      logger.info(`[${this.collectionName} Controller] Creating new ${this.collectionName}`, {
        loggedUser,
        tags,
        name,
        path,
      });

      const fileUpload = {
        name,
        path,
        userId,
        tags,
        views: views ?? 0,
      };
      const created = await this.baseService.create(fileUpload);

      return res.json(createResponse({ data: created, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn("Error uploading file", { error: error.message, loggedUser });
      }
      next(error);
    }
  };

  /**
   * Update an existing entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON updated entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  update = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { id } = req.params;
    try {
      const updateData = req.body;
      const existFile = await this.baseService.getById(id);
      if (!existFile) {
        throw new Error("File not found");
      }
      const fileName = existFile.path!.split("/").pop();
      if (req.file) {
        await updateImageToDisk(fileName!, req.file);
      }
      const fileData = {
        name: _.isEmpty(updateData.name) ? existFile.name : updateData.name,
        userId: _.isEmpty(updateData.userId) ? existFile.userId : updateData.userId,
        tags: _.isEmpty(updateData.tags) ? existFile.tags : updateData.tags,
        views: _.isEmpty(updateData.views) ? existFile.views : updateData.views,
      };
      const updated = await this.baseService.update(id, fileData);

      return res.json(createResponse({ data: updated, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn("Error updating file", { error: error.message, loggedUser, id });
      }
      next(error);
    }
  };

  /**
   * Delete an existing entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON updated entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  delete = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser } = req;
    const { id } = req.params;
    try {
      const existFile = await this.baseService.getById(id);
      if (!existFile) {
        throw new Error("File not found");
      }
      const fileName = existFile.path!.split("/").pop();
      await deleteFileFromDisk(fileName!);
      const deleted = await this.baseService.delete(id);

      return res.json(createResponse({ data: deleted, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn("Error deleting file", { error: error.message, loggedUser, id });
      }
      next(error);
    }
  };
}


File: src/entities/auth/auth.controller.ts
--------------------------------------------------
Content of src/entities/auth/auth.controller.ts:
import { NextFunction, Response } from "express";
import { AuthDto, RegisterDto, ResetPasswordDto } from "@/entities/auth/auth.dto";
import { AuthService } from "@/entities/auth/auth.services";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import { StatusCodes } from "http-status-codes";
import { createResponse } from "@/utils/create-response";
import { PrismaClient } from "@prisma/client";

const prisma = prismaInstance();

export class AuthController {
  private collectionName: string;
  private authService: AuthService;

  constructor() {
    this.collectionName = "User";
    this.authService = new AuthService(prisma.user, "User");
  }

  /**
   * Handles user login by verifying credentials and returning a token.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  login = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const loginDto: AuthDto = req.body;
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] login API invoked`, {
      email: loginDto.email,
      loggedUser,
    });

    try {
      const data = await this.authService.login(loginDto);
      logger.info(`[${this.collectionName} Controller] User login successful`, {
        email: loginDto.email,
        loggedUser,
      });

      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] login API error`, {
          email: loginDto.email,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(`[${this.collectionName} Controller] login API error: Unknown error occurred`, {
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Handles user registration by creating a new user and returning the registered user details.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  register = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const registerDto: RegisterDto = req.body;
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] Register API invoked`, {
      email: registerDto.email,
      loggedUser,
    });

    try {
      const data = await this.authService.register(registerDto);
      logger.info(`[${this.collectionName} Controller] User registration successful`, {
        email: registerDto.email,
        loggedUser,
      });

      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Register API error`, {
          email: registerDto.email,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(
          `[${this.collectionName} Controller] Register API error: Unknown error occurred`,
          {
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Handles user logout by invalidating the user's token.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  logout = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const token = req.headers.authorization?.split(" ")[1];
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] Logout API invoked`, { token, loggedUser });

    try {
      const data = await this.authService.logout(token!);
      logger.info(`[${this.collectionName} Controller] User logout successful`, {
        token,
        loggedUser,
      });

      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Logout API error`, {
          token,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(
          `[${this.collectionName} Controller] Logout API error: Unknown error occurred`,
          { loggedUser },
        );
      }
      next(error);
    }
  };

  /**
   * Extends the user's token and returns a new token.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extendToken = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const token = req.headers.authorization?.split(" ")[1];
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] ExtendToken API invoked`, {
      token,
      loggedUser,
    });

    try {
      const data = await this.authService.extendToken(token!);
      logger.info(`[${this.collectionName} Controller] Token extended successfully`, {
        data,
        loggedUser,
      });
      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] ExtendToken API error`, {
          token,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(
          `[${this.collectionName} Controller] ExtendToken API error: Unknown error occurred`,
          {
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Initiates the forgot password process for a user.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  forgotPassword = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { email } = req.body;
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] Forgot password API invoked`, {
      email,
      loggedUser,
    });

    try {
      const data = await this.authService.forgotPassword(email);
      logger.info(`[${this.collectionName} Controller] Forgot password successful`, {
        email,
        loggedUser,
      });
      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Forgot password API error`, {
          email,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(
          `[${this.collectionName} Controller] Forgot password API error: Unknown error occurred`,
          {
            loggedUser,
          },
        );
      }
      next(error);
    }
  };

  /**
   * Initiates the reset password process for a user.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  resetPassword = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { resetToken, password, confirmPassword } = req.body;
    const { loggedUser } = req;
    logger.info(`[${this.collectionName} Controller] Reset password API invoked`, {
      resetToken,
      loggedUser,
    });

    const resetPasswordDto: ResetPasswordDto = {
      password,
      confirmPassword,
      resetToken,
    };
    try {
      const data = await this.authService.resetPassword(resetPasswordDto);
      logger.info(`[${this.collectionName} Controller] Reset password successful`, {
        resetToken,
        loggedUser,
      });
      return res.json(createResponse({ data, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Reset password API error`, {
          resetToken,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(
          `[${this.collectionName} Controller] Reset password API error: Unknown error occurred`,
          {
            loggedUser,
          },
        );
      }
      next(error);
    }
  };
}


File: src/entities/auth/auth.dto.ts
--------------------------------------------------
Content of src/entities/auth/auth.dto.ts:
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { z } from "zod";

extendZodWithOpenApi(z);

const passwordSchema = z
  .string()
  .min(8)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  .superRefine((value: string, context: any) => {
    if (value === value.toLowerCase()) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a capital letter",
      });
    }

    if (value === value.toUpperCase()) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a lowercase letter",
      });
    }

    if (!/\d/.test(value)) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a number",
      });
    }

    // eslint-disable-next-line no-useless-escape
    if (!/[!"#$%&'()*+,./:;<=>?@[\\\]^_`{|}~\-]/.test(value)) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a special character",
      });
    }
  });

export const loginSchema = z.object({
  email: z.string().email(),
  password: passwordSchema,
});

export const logoutSchema = z.object({
  success: z.boolean(),
});

export const extendTokenSchema = z.object({
  token: z.string(),
});

export const forgotPasswordSchema = z.object({
  email: z.string().email().trim(),
});

export const resetPasswordSchema = z
  .object({
    resetToken: z.string(),
    password: passwordSchema,
    confirmPassword: z.string().min(8),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });

export const registerSchema = z
  .object({
    email: z.string().email(),
    password: passwordSchema,
    confirmPassword: z.string().min(8),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });

export type RegisterDto = z.infer<typeof registerSchema>;
export type AuthDto = z.infer<typeof loginSchema>;
export type ResetPasswordDto = z.infer<typeof resetPasswordSchema>;


File: src/entities/auth/auth.route.ts
--------------------------------------------------
Content of src/entities/auth/auth.route.ts:
import { Router } from "express";
import { authMiddleware, zodValidation } from "@/middlewares";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import {
  loginSchema,
  extendTokenSchema,
  forgotPasswordSchema,
  logoutSchema,
  registerSchema,
  resetPasswordSchema,
} from "@/entities/auth/auth.dto";
import { AuthController } from "@/entities/auth/auth.controller";

const authRouter = Router();

const TAG = "Auth";
const ROUTE = `/${TAG.toLowerCase()}`;

export const authRegistry = new OpenAPIRegistry();
const authController = new AuthController();

authRegistry.register(TAG, loginSchema);

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/login`,
  tags: [TAG],
  summary: "Login",
  request: {
    body: {
      content: { "application/json": { schema: loginSchema } },
    },
  },
  responses: createApiResponse(loginSchema, "Login Successfully"),
});
authRouter.post("/login", zodValidation(loginSchema), authController.login);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/register`,
  tags: [TAG],
  summary: "Register",
  request: {
    body: {
      content: { "application/json": { schema: registerSchema } },
    },
  },
  responses: createApiResponse(registerSchema, "Register Successfully"),
});
authRouter.post("/register", zodValidation(registerSchema), authController.register);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/extend-token`,
  tags: [TAG],
  summary: "Extend Token",
  request: {
    body: {
      content: { "application/json": { schema: extendTokenSchema } },
    },
  },
  responses: createApiResponse(extendTokenSchema, "Token Extended Successfully"),
});
authRouter.post(
  "/extend-token",
  authMiddleware,
  zodValidation(extendTokenSchema),
  authController.extendToken,
);

//====================================================================================================

authRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/logout`,
  tags: [TAG],
  summary: "Logout",
  responses: createApiResponse(logoutSchema, "Logout Successfully"),
});
authRouter.get("/logout", authMiddleware, authController.logout);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/forgot-password`,
  tags: [TAG],
  summary: "Forgot Password",
  request: {
    body: {
      content: { "application/json": { schema: forgotPasswordSchema } },
    },
  },
  responses: createApiResponse(forgotPasswordSchema, "Reset link sent. Check you email"),
});
authRouter.post(
  "/forgot-password",
  zodValidation(forgotPasswordSchema),
  authController.forgotPassword,
);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/reset-password`,
  tags: [TAG],
  summary: "Reset Password",
  request: {
    body: {
      content: { "application/json": { schema: resetPasswordSchema } },
    },
  },
  responses: createApiResponse(resetPasswordSchema, "Password reset successful"),
});
authRouter.post(
  "/reset-password",
  zodValidation(resetPasswordSchema),
  authController.resetPassword,
);

export default authRouter;


File: src/entities/auth/auth.services.ts
--------------------------------------------------
Content of src/entities/auth/auth.services.ts:
import { compare, hash } from "bcrypt";
import { logger } from "@/common/winston/winston";
import { AuthDto, RegisterDto, ResetPasswordDto } from "@/entities/auth/auth.dto";
import { generateToken, verifyToken } from "@/common/jwt/jwt";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { UserService } from "@/entities/user/user.service";
import { sendMail } from "@/common/mail-sender/mail-sender";
import { BaseRepository } from "@/common/base/base.repository";
import { CreateUserDto, UpdateUserDto } from "@/entities/user/user.dto";
import { env } from "@/config/env";
import { createTemplate } from "@/template/create-template";
import { user as User } from "@prisma/client";

export class AuthService {
  private collectionName: string;
  private userService: UserService;
  private userRepository: BaseRepository<User, UpdateUserDto, CreateUserDto>;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string) {
    this.collectionName = collectionName;
    this.userService = new UserService(model, "User");
    this.userRepository = new BaseRepository(model, "User");
  }

  /**
   * Handles user login by verifying the credentials and generating a token.
   * @param authData - Object containing user login credentials.
   * @returns Object containing the generated token.
   * @throws HTTP error if user not found or password is invalid.
   */
  login = async (authData: AuthDto) => {
    logger.info(`[${this.collectionName} Service] login service invoked`, {
      email: authData.email,
    });

    try {
      const user = await this.userService.getByEmail(authData.email);

      if (!user) {
        logger.warn(
          `[${this.collectionName} Service] ${this.collectionName} not found during login`,
          {
            email: authData.email,
          },
        );
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: "Auth",
        });
      }

      if (!(await compare(authData.password, user.password as string))) {
        logger.warn(`[${this.collectionName} Service] Invalid password during login`, {
          email: authData.email,
        });
        throw createHttpError(StatusCodes.BAD_REQUEST, "Invalid email or password", {
          resource: "Auth",
        });
      }

      const token = generateToken({
        id: user.id,
        name: user.name,
        email: user.email,
      });

      logger.info(`[${this.collectionName} Service] Token received successfully`, {
        email: authData.email,
      });
      return { user, token };
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error during login`, {
          error: error.message,
          email: authData.email,
        });
        throw new Error(`Error while login: ${error.message}`);
      }
      logger.warn(`[${this.collectionName} Service] Unknown error during login`, {
        email: authData.email,
      });
      throw new Error("Unknown error occurred while login");
    }
  };

  /**
   * Registers a new user and generates a token for the user.
   * @param registerDto - Registration data for a new user.
   * @returns Object containing the registered user and generated token.
   * @throws HTTP error if user already exists.
   */
  register = async (registerDto: RegisterDto) => {
    logger.info(`[${this.collectionName} Service] Register service invoked`, {
      email: registerDto.email,
    });

    try {
      await this.userService.create(registerDto);

      const login = await this.login(registerDto);

      logger.info(
        `[${this.collectionName} Service] ${this.collectionName} registered successfully`,
        {
          email: registerDto.email,
        },
      );
      return login;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error during registration`, {
          error: error.message,
          email: registerDto.email,
        });
        throw new Error(`[${this.collectionName} Service] Error while login: ${error.message}`);
      }
      logger.warn(`[${this.collectionName} Service] Unknown error during registration`, {
        email: registerDto.email,
      });
      throw new Error(`[${this.collectionName} Service] Unknown error occurred while login`);
    }
  };

  /**
   * Extends the user's token and returns a new token.
   * @param token - The current token to extend.
   * @returns The newly extended token.
   * @throws Error if token extension fails.
   */
  extendToken = async (token: string) => {
    logger.info(`[${this.collectionName} Service] Extend token service invoked`, { token });

    try {
      const payload = verifyToken(token);
      const newToken = generateToken({
        id: payload.id,
        name: payload.name,
        email: payload.email,
      });
      logger.info(`[${this.collectionName} Service] Token extended successfully`, { newToken });
      return newToken;
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error extending token`, {
          error: error.message,
          token,
        });
        throw new Error(`[${this.collectionName} Service] Error extend token: ${error.message}`);
      }
      logger.warn(`[${this.collectionName} Service] Unknown error while extending token`, {
        token,
      });
      throw new Error(`[${this.collectionName} Service] Unknown error occurred while extend token`);
    }
  };

  /**
   * Logs out the user by invalidating the token.
   * @param token - The token to invalidate.
   * @returns Object with the invalidated token and success status.
   * @throws Error if logout fails.
   */
  logout = async (token: string) => {
    logger.info(`[${this.collectionName} Service] Logout service invoked`, { token });

    try {
      return { token, success: true };
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error during logout`, {
          error: error.message,
          token,
        });
        throw new Error(`Error logout: ${error.message}`);
      }
      logger.warn(`[${this.collectionName} Service] Unknown error during logout`, { token });
      throw new Error("Unknown error occurred while logout");
    }
  };

  /**
   * Initiates the forgot password process for a user.
   * @param email User's email address
   * @returns message that email sent.
   * @throws HTTP error if any error occur.
   */
  forgotPassword = async (email: string) => {
    logger.info(`[${this.collectionName} Service] Forgot password service invoked`, { email });

    try {
      const user = await this.userService.getByEmail(email);

      if (!user) {
        logger.warn(`[${this.collectionName} Service] ${this.collectionName} does not exists!`, {
          email,
        });
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: "Auth",
        });
      }

      const resetToken = generateToken({
        id: user.id,
        name: user.name,
        email: user.email,
      });

      await this.userService.update(user.id as string, {
        resetToken,
        name: user.name!,
        email: user.email,
        updatedAt: new Date(),
      });

      // Send email
      try {
        const context = {
          accountName: user.name,
          URL: `${env.APP_URL}/reset-password?token=${resetToken}`,
        };

        const options = {
          from: `${env.MAILGUN_NAME} <${env.MAILGUN_SENDER_EMAIL}>`,
          to: email,
          subject: "Reset Password Requested",
          html: createTemplate("forgot-password", context),
        };

        await sendMail(options);
      } catch (error) {
        console.log(`Error: ${error}`);
        throw new Error(`Error while sending email: ${error}`);
      }

      logger.info(`[${this.collectionName} Service] Email reset link successfully sent`, {
        email,
        resetToken,
      });
      return { message: "Reset link sent. Check your inbox" };
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error during registration`, {
          error: error.message,
          email,
        });
        throw new Error(
          `[${this.collectionName} Service] Error while forgot password: ${error.message}`,
        );
      }
      logger.warn(`[${this.collectionName} Service] Unknown error during registration`, {
        email,
      });
      throw new Error(
        `[${this.collectionName} Service] Unknown error occurred while forgot password`,
      );
    }
  };

  resetPassword = async (resetPasswordDto: ResetPasswordDto) => {
    logger.info(`[${this.collectionName} Service] reset password service invoked`, {
      resetToken: resetPasswordDto.resetToken,
    });

    try {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const user: any = await this.userRepository.getByField(
        "resetToken",
        resetPasswordDto.resetToken,
      );

      if (user.length === 0) {
        logger.warn(`[${this.collectionName} Service] ${this.collectionName} does not exists!`, {
          resetToken: resetPasswordDto.resetToken,
        });
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: "Auth",
        });
      }

      if (!user[0].resetToken || resetPasswordDto.resetToken !== user[0].resetToken) {
        throw createHttpError(StatusCodes.BAD_REQUEST, "Invalid or expired reset token.");
      }

      const hashedPassword = await hash(resetPasswordDto.password, env.HASH!);

      await this.userService.update(user[0].id, {
        password: hashedPassword,
        resetToken: null,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any);

      logger.info(`[${this.collectionName} Service] Password reset successful`, {
        resetToken: resetPasswordDto.resetToken,
      });
      return { message: "Password reset successful" };
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Service] Error during registration`, {
          error: error.message,
          resetToken: resetPasswordDto.resetToken,
        });
        throw new Error(
          `[${this.collectionName} Service] Error while reset password: ${error.message}`,
        );
      }
      logger.warn(`[${this.collectionName} Service] Unknown error during registration`, {
        resetToken: resetPasswordDto.resetToken,
      });
      throw new Error(
        `[${this.collectionName} Service] Unknown error occurred while reset password`,
      );
    }
  };
}


File: src/entities/health/health.controller.ts
--------------------------------------------------
Content of src/entities/health/health.controller.ts:
import { NextFunction, Response } from "express";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import {
  checkRedis,
  createHealthCheckResponse,
  formatMemoryUsage,
} from "@/entities/health/health.helper";
import { StatusCodes } from "http-status-codes";
import fs from "fs";
import { env } from "@/config/env";
import path from "path";
import { RedisClient } from "@/config/redis/redis";

export class HealthController {
  private logFileName: string;

  constructor() {
    this.logFileName = "[Auth Controller]";
  }

  /**
   * Handles health of server.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  health = async (_: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    try {
      const healthCheck = {
        redis: await checkRedis(),
        server: {
          status: "healthy",
          uptime: process.uptime(),
          memoryUsage: formatMemoryUsage(),
        },
      };

      const overallStatus = Object.values(healthCheck)
        .map((service) => service.status)
        .includes("unhealthy")
        ? "unhealthy"
        : "healthy";

      res
        .status(overallStatus === "healthy" ? StatusCodes.OK : StatusCodes.INTERNAL_SERVER_ERROR)
        .json(createHealthCheckResponse(overallStatus, healthCheck));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} health API error`, {
          error: error.message,
        });
      } else {
        logger.warn(`${this.logFileName} health API error: Unknown error occurred`);
      }
      next(error);
    }
  };

  /**
   * * Clear Redis API cache.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  clearCache = async (_: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    try {
      const redis = RedisClient.getInstance();
      const stream = redis.scanStream({
        match: "apiResponseCache*", // Pattern to match keys
        count: 100, // Process 100 keys per iteration
      });

      const keysToDelete: string[] = [];

      for await (const keys of stream) {
        keysToDelete.push(...keys);
      }

      if (keysToDelete.length > 0) {
        await redis.del(...keysToDelete);
        logger.info(`Cleared ${keysToDelete.length} keys with prefix apiResponseCache`);
      } else {
        logger.info("No keys found with prefix apiResponseCache");
      }
      res.json({ message: "Cache cleared successfully" });
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} clearCache API error`, {
          error: error.message,
        });
      } else {
        logger.warn(`${this.logFileName} clearCache API error: Unknown error occurred`);
      }
      next(error);
    }
  };

  /**
   * Handles health of server.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  clearLogFiles = async (_: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!fs.existsSync(env.LOGS_DIRECTORY)) {
        fs.mkdirSync(env.LOGS_DIRECTORY);
      }

      const files = fs.readdirSync(env.LOGS_DIRECTORY);

      files.forEach((file) => {
        const filePath = path.join(env.LOGS_DIRECTORY, file);
        fs.unlinkSync(filePath);
      });

      res.json({ message: "All log files have been cleared." });
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} clearLogFiles API error`, {
          error: error.message,
        });
      } else {
        logger.warn(`${this.logFileName} clearLogFiles API error: Unknown error occurred`);
      }
      next(error);
    }
  };
}


File: src/entities/health/health.helper.ts
--------------------------------------------------
Content of src/entities/health/health.helper.ts:
import { RedisClient } from "@/config/redis/redis";

export const checkRedis = async () => {
  try {
    const redis = RedisClient.getInstance();
    await redis.ping();
    return { status: "healthy", details: {} };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    return { status: "unhealthy", details: { error: error.message } };
  }
};

export const formatMemoryUsage = () => {
  const memoryUsage = process.memoryUsage();
  return {
    rss: `${(memoryUsage.rss / 1024 / 1024).toFixed(2)} MB`,
    heapTotal: `${(memoryUsage.heapTotal / 1024 / 1024).toFixed(2)} MB`,
    heapUsed: `${(memoryUsage.heapUsed / 1024 / 1024).toFixed(2)} MB`,
    external: `${(memoryUsage.external / 1024 / 1024).toFixed(2)} MB`,
  };
};

export const createHealthCheckResponse = (status: string, details: Record<string, unknown>) => ({
  status,
  details,
});


File: src/entities/health/health.route.ts
--------------------------------------------------
Content of src/entities/health/health.route.ts:
import { Router } from "express";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import { HealthController } from "@/entities/health/health.controller";
import { z } from "zod";

const healthRouter = Router();

const TAG = "Health";
const ROUTE = `/${TAG.toLowerCase()}`;

export const healthRegistry = new OpenAPIRegistry();
const healthController = new HealthController();

healthRegistry.register(TAG, z.any());

//====================================================================================================

healthRegistry.registerPath({
  method: "get",
  path: ROUTE,
  summary: "Get health check",
  tags: [TAG],
  security: [],
  responses: createApiResponse(z.any(), "Success"),
});

healthRouter.get("/", healthController.health);

//====================================================================================================

healthRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/clear-cache`,
  summary: "Clear cache",
  tags: [TAG],
  security: [],
  responses: createApiResponse(z.any(), "Success"),
});

healthRouter.get("/clear-cache", healthController.clearCache);

//====================================================================================================

healthRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/clear-logs`,
  summary: "Clear log files",
  tags: [TAG],
  security: [],
  responses: createApiResponse(z.any(), "Success"),
});

healthRouter.get("/clear-logs", healthController.clearLogFiles);

export default healthRouter;


File: src/entities/user/user.dto.ts
--------------------------------------------------
Content of src/entities/user/user.dto.ts:
import { userSchema } from "@/generated/zod";
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { z } from "zod";

extendZodWithOpenApi(z);

export const createUserSchema = userSchema
  .omit({
    id: true,
    createdAt: true,
    updatedAt: true,
  })
  .partial();

export const updateUserSchema = userSchema
  .omit({
    id: true,
    password: true,
    createdAt: true,
  })
  .partial();

export type UserDto = z.infer<typeof userSchema>;
export type CreateUserDto = z.infer<typeof createUserSchema>;
export type UpdateUserDto = z.infer<typeof updateUserSchema>;


File: src/entities/user/user.controller.ts
--------------------------------------------------
Content of src/entities/user/user.controller.ts:
import { NextFunction, Response } from "express";
import { UserService } from "@/entities/user/user.service";
import { StatusCodes } from "http-status-codes";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import { createResponse } from "@/utils/create-response";
import { BaseController } from "@/common/base/base.controller";
import { CreateUserDto, UpdateUserDto } from "@/entities/user/user.dto";
import { PrismaClient, user as User } from "@prisma/client";

const prisma = prismaInstance();
const IGNORE_FIELDS = { password: true };

export class UserController extends BaseController<User, CreateUserDto, UpdateUserDto> {
  public collectionName: string;
  public userService: UserService;

  constructor() {
    super(prisma.user, "User", IGNORE_FIELDS);
    this.collectionName = "User";
    this.userService = new UserService(prisma.user, this.collectionName, IGNORE_FIELDS);
  }

  /**
   * Create a new entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON created entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  create = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const createDto = req.body;
    const { loggedUser } = req;
    try {
      logger.info(`[${this.collectionName} Controller] Creating new ${this.collectionName}`, {
        loggedUser,
        createDto,
      });
      const created = await this.userService.create(createDto);
      return res.json(createResponse({ data: created, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error creating ${this.collectionName}`, {
          error: error.message,
          loggedUser,
          createDto,
        });
      }
      next(error);
    }
  };

  /**
   * Update an existing entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON updated entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  update = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { id } = req.params;
    const updateDto = req.body;
    const { loggedUser } = req;
    try {
      logger.info(`[${this.collectionName} Controller] Updating ${this.collectionName}`, {
        loggedUser,
        id,
        updateDto,
      });
      const updatedData = await this.userService.update(id, updateDto);
      return res.json(createResponse({ data: updatedData, status: StatusCodes.CREATED }));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`[${this.collectionName} Controller] Error updating ${this.collectionName}`, {
          error: error.message,
          loggedUser,
          id,
          updateDto,
        });
      }
      next(error);
    }
  };
}


File: src/entities/user/user.service.ts
--------------------------------------------------
Content of src/entities/user/user.service.ts:
import { UpdateUserDto, CreateUserDto } from "@/entities/user/user.dto";
import { env } from "@/config/env";
import { hash } from "bcrypt";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { logger } from "@/common/winston/winston";
import { BaseService } from "@/common/base/base.services";
import { user as User } from "@prisma/client";

export class UserService extends BaseService<User, CreateUserDto, UpdateUserDto> {
  private collectionNameService: string;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(model: any, collectionName: string, ignoreFields?: Record<string, boolean>) {
    super(model, collectionName, ignoreFields);
    this.collectionNameService = collectionName;
  }

  /**
   * Creates a new entity.
   * @param createDto - Data for creating a new entity
   * @returns Created entity data
   */
  create = async (createDto: CreateUserDto): Promise<User | null> => {
    try {
      logger.info(
        `[${this.collectionNameService} Service] Creating ${this.collectionNameService} with email: ${createDto.email}`,
      );
      const data = await this.baseRepository.getByEmail(createDto.email!);

      if (data) {
        logger.warn(
          `[${this.collectionNameService} Service] ${this.collectionNameService} with email ${createDto.email} already exists`,
        );
        throw createHttpError(
          StatusCodes.BAD_REQUEST,
          `${this.collectionNameService} already exists!`,
          {
            resource: this.collectionNameService,
          },
        );
      }

      const hashedPassword = await hash(createDto.password!, env.HASH!);

      const newDto = {
        name: createDto.name,
        email: createDto.email,
        password: hashedPassword,
      };

      return await this.baseRepository.create(newDto);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionNameService} Service] Error creating ${this.collectionNameService}`,
          {
            createDto,
            error: error.message,
          },
        );
        throw new Error(`Error creating ${this.collectionNameService}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionNameService} Service] Unknown error occurred while creating ${this.collectionNameService}`,
      );
      throw new Error(`Unknown error occurred while creating ${this.collectionNameService}`);
    }
  };

  /**
   * Updates an existing entity.
   * @param id - entity's unique identifier
   * @param updateDto - Data to update the entity with
   * @returns Updated entity data
   */
  update = async (id: string, updateDto: UpdateUserDto): Promise<User | null> => {
    try {
      logger.info(
        `[${this.collectionNameService} Service] Updating ${this.collectionNameService} with id: ${id}`,
      );
      const data = await this.getById(id);

      if (!data) {
        logger.warn(
          `[${this.collectionNameService} Service] ${this.collectionNameService} with id ${id} does not exist!`,
        );
        throw createHttpError(
          StatusCodes.BAD_REQUEST,
          `${this.collectionNameService} does not exist!`,
          {
            resource: this.collectionNameService,
          },
        );
      }

      if (updateDto.email) {
        const email = await this.baseRepository.getByEmail(updateDto.email);
        if (email) {
          logger.warn(
            `[${this.collectionNameService} Service] ${this.collectionNameService} with email ${updateDto.email} already exists`,
          );
          throw createHttpError(StatusCodes.BAD_REQUEST, "Email already exists!", {
            resource: this.collectionNameService,
          });
        }
      }

      // If (updateDto.password) {
      //   UpdateDto.password = await hash(updateDto.password, env.HASH!);
      // }

      updateDto.updatedAt = new Date();

      return await this.baseRepository.update(id, updateDto);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(
          `[${this.collectionNameService} Service] Error updating ${this.collectionNameService}`,
          {
            id,
            updateDto,
            error: error.message,
          },
        );
        throw new Error(`Error updating ${this.collectionNameService}: ${error.message}`);
      }
      logger.warn(
        `[${this.collectionNameService} Service] Unknown error occurred while updating ${this.collectionNameService}`,
      );
      throw new Error(`Unknown error occurred while updating ${this.collectionNameService}`);
    }
  };
}


File: src/entities/user/user.route.ts
--------------------------------------------------
Content of src/entities/user/user.route.ts:
import { createUserSchema, updateUserSchema } from "@/entities/user/user.dto";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { UserController } from "@/entities/user/user.controller";
import { authMiddleware } from "@/middlewares";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import { zodValidation } from "@/middlewares/zod-validation";
import { z } from "zod";
import { findByQuerySchema } from "@/schemas/find-by-query";
import { Router } from "express";
import { importFileSchema } from "@/schemas/import-file";
import { uploadImportMiddleware } from "@/common/multer/multer";
import { userSchema } from "@/generated/zod";

const userRouter = Router();
userRouter.use(authMiddleware);

const TAG = "User";
const ROUTE = `/${TAG.toLowerCase()}`;

export const userRegistry = new OpenAPIRegistry();
const userController = new UserController();

userRegistry.register(TAG, userSchema);

userRegistry.registerPath({
  method: "get",
  path: ROUTE,
  summary: `Get all ${TAG}`,
  tags: [TAG],
  responses: createApiResponse(z.array(userSchema), "Success"),
});
userRouter.get("/", userController.getAll);

//====================================================================================================

userRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/import`,
  tags: [TAG],
  summary: `Import ${TAG}`,
  request: {
    body: {
      content: { "multipart/form-data": { schema: importFileSchema } },
    },
  },
  responses: createApiResponse(z.null(), `${TAG}s Imported Successfully`),
});
userRouter.post("/import", uploadImportMiddleware, userController.import);

//====================================================================================================

userRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/export`,
  summary: `Export ${TAG}`,
  tags: [TAG],
  responses: createApiResponse(z.null(), `${TAG}s Exported Successfully`),
});
userRouter.get("/export", userController.export);

//====================================================================================================

userRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  summary: `Get ${TAG} by id`,
  request: {
    params: z.object({ id: z.string() }),
  },
  responses: createApiResponse(userSchema, "Success"),
});
userRouter.get("/:id", userController.getById);

//====================================================================================================

userRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/email/{email}`,
  tags: [TAG],
  summary: `Get ${TAG} by email`,
  request: {
    params: z.object({ email: z.string() }),
  },
  responses: createApiResponse(userSchema, "Success"),
});
userRouter.get("/email/:email", userController.getByEmail);

//====================================================================================================

userRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/find`,
  tags: [TAG],
  summary: `Find ${TAG} by query`,
  request: {
    body: {
      content: { "application/json": { schema: findByQuerySchema } },
    },
  },
  responses: createApiResponse(z.array(findByQuerySchema), "Success"),
});
userRouter.post("/find", zodValidation(findByQuerySchema), userController.findByQuery);

//====================================================================================================

userRegistry.registerPath({
  method: "post",
  path: ROUTE,
  tags: [TAG],
  summary: `Create ${TAG}`,
  request: {
    body: {
      content: { "application/json": { schema: createUserSchema } },
    },
  },
  responses: createApiResponse(createUserSchema, `${TAG} Created Successfully`),
});
userRouter.post("/", zodValidation(createUserSchema), userController.create);

//====================================================================================================

userRegistry.registerPath({
  method: "put",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  summary: `Update ${TAG}`,
  request: {
    params: z.object({ id: z.string() }),
    body: {
      content: { "application/json": { schema: updateUserSchema } },
    },
  },
  responses: createApiResponse(updateUserSchema, `${TAG} Updated Successfully`),
});
userRouter.put("/:id", zodValidation(updateUserSchema), userController.update);

//====================================================================================================

userRegistry.registerPath({
  method: "delete",
  path: `${ROUTE}/bulk`,
  tags: [TAG],
  summary: `Delete ${TAG} in bulk`,
  request: {
    body: {
      content: { "application/json": { schema: z.object({ ids: z.array(z.string()) }) } },
    },
  },
  responses: createApiResponse(z.null(), `${TAG}s Deleted Successfully`),
});
userRouter.delete(
  "/bulk",
  zodValidation(z.object({ ids: z.array(z.string()) })),
  userController.deleteMany,
);

//====================================================================================================

userRegistry.registerPath({
  method: "delete",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  summary: `Delete ${TAG}`,
  request: {
    params: z.object({ id: z.string() }),
  },
  responses: createApiResponse(z.null(), `${TAG} Deleted Successfully`),
});
userRouter.delete("/:id", userController.delete);

export default userRouter;


